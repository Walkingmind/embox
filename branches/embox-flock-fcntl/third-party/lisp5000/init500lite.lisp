(funcall #'(setf iref)
	 #'(lambda (object) (= (ldb (cons 2 0) (ival object)) 1))
	 'consp 5)
(funcall #'(setf iref)
	 #'(lambda (new-definition function-name)
	     (if (consp function-name)
		 (funcall #'(setf iref) new-definition
			  (car (cdr function-name)) 6)
		 (progn
		   (funcall #'(setf iref) new-definition function-name 5)
		   (funcall #'(setf iref)
			    (dpb 0 '(1 . 1) (iref function-name 8))
			    function-name 8)))
	     new-definition)
	 'fdefinition 6)
(funcall #'(setf iref)
	 #'(lambda (new-function symbol &optional environment)
	     (funcall #'(setf iref) new-function symbol 5)
	     (funcall #'(setf iref) (dpb 1 '(1 . 1) (iref symbol 8))
		      symbol 8)
	     new-function)
	 'macro-function 6)
(funcall #'(setf macro-function)
	 #'(lambda (name lambda-list &rest body)
	     (list 'progn
		   (list 'funcall '#'(setf macro-function)
			 (list 'function
			       (cons 'lambda (cons lambda-list body)))
			 (list 'quote name))
		   (list 'quote name)))
	 'defmacro)
(defmacro defun (name lambda-list &rest body)
  (list 'progn
	(list 'funcall '#'(setf fdefinition)
	      (list 'function
		    (list 'lambda lambda-list
			  (cons 'block (cons (if (consp name)
						 (car (cdr name))
						 name)
					     body))))
	      (list 'quote name))
	(list 'quote name)))
(defmacro setf (place new-value)
  (if (consp place)
      (cons 'funcall (cons (list 'function (list 'setf (car place)))
			   (cons new-value (cdr place))))
      (list 'setq place new-value)))
(defun append (&rest lists)
  (if (cdr lists)
      (let ((list (car lists))
	    (result nil)
	    (end nil))
	(if list
	    (tagbody
	     start
	       (if list
		   (progn
		     (setf end (if end
				   (setf (cdr end) (list (car list)))
				   (setf result (list (car list)))))
		     (setf list (cdr list))
		     (go start)))
	       (setf (cdr end) (apply #'append (cdr lists)))
	       (return-from append result))
	    (apply #'append (cdr lists))))
      (car lists)))
(defun backquote-expand (list level)
  (if (consp list) 
      (if (eq 'backquote (car list)) 
	  (list 'list ''backquote 
		(backquote-expand (car (cdr list)) (+ level 1))) 
	  (if (eq 'unquote (car list)) 
	      (if (= level 0) 
		  (car (cdr list)) 
		  (list 'list ''unquote 
			(backquote-expand (car (cdr list)) (- level 1)))) 
	      (if (eq 'unquote-splicing (car list)) 
		  (if (= level 0) 
		      (values (car (cdr list)) t) 
		      (list 'list ''unquote-splicing 
			    (backquote-expand (car (cdr list)) (- level 1)))) 
		  (labels ((collect (list) 
			     (if (consp list) 
				 (cons (multiple-value-call 
					   #'(lambda (value 
						      &optional splicingp) 
					       (if splicingp 
						   value 
						   (list 'list value))) 
				       (backquote-expand (car list) level)) 
				     (collect (cdr list))) 
				 (list (list 'quote list))))) 
		    (cons 'append (collect list)))))) 
      (list 'quote list))) 
(defmacro backquote (form)
  (backquote-expand form 0))

(defun macro-function (symbol &optional environment)
  "(dolist (binding environment)
    (when (and (consp (car binding))
	       (= (floor (ival (cdar binding)) 16) 1)
	       (eq (caar binding) symbol))
      (return-from macro-function 
	(when (= (ldb '(1 . 4) (ival (cdr binding))) 1)
	  (cdr binding)))))"
  (if (= (ldb '(1 . 1) (iref symbol 8)) 1)
      (iref symbol 5)))
(defun macroexpand-1 (form &optional env)
  (if (consp form)
      (let ((definition (macro-function (car form) env)))
	(if definition
	    (values (apply definition (cdr form)) t)
	    (values form nil)))
      (if (and form (symbolp form) (= (ldb '(1 . 0) (iref form 8)) 1))
	  (values (iref form 4) t)
	  (values form nil))))
(defun macroexpand (form &optional env)
  (multiple-value-bind (form expanded-p)
      (macroexpand-1 form env)
    (if expanded-p
	(tagbody
	 start
	   (multiple-value-bind (expansion expanded-p)
	       (macroexpand-1 form env)
	     (if expanded-p
		 (progn
		   (setq form expansion)
		   (go start))
		 (return-from macroexpand (values expansion t)))))
	(values form nil))))
(defmacro define-symbol-macro (symbol expansion)
  `(progn
    (setf (iref ',symbol 4) ',expansion)
    (setf (iref ',symbol 8) (dpb 1 (cons 1 0) (iref ',symbol 8)))
    ',symbol))
(defun special-operator-p (symbol)
  (member symbol '(block catch eval-when flet function go if labels let let*
		   load-time-value locally macrolet multiple-value-call
		   multiple-value-prog1 progn progv quote return-from setq
		   symbol-macrolet tagbody the throw unwind-protect)))
(defun constantp (form &optional environment)
  (not (or (and (symbolp form)
		(zerop (ldb '(1 . 4) (iref form 8))))
	   (and (consp form)
		(not (eq (car form) 'quote))))))
(defun null (object) (if object nil t))
(defun not (object) (if object nil t))
(defun length (sequence)
  (let ((tag (ldb '(2 . 0) (ival sequence))))
    (if (= tag 0)
	0
	(if (= tag 1)
	    (let ((i 0)) (dolist (elem sequence i) (setf i (+ 1 i))))
	    (if (= tag 2)
		(let ((subtag (iref sequence 1)))
		  (if (= subtag 3)
		      (/ (ival (iref sequence 0)) 256)
		      (if (= subtag 4)
			  (let ((dimensions/fill (iref sequence 3)))
			    (if (consp dimensions/fill)
				(error "not a sequence")
				(or dimensions/fill
				    (length (iref sequence 4)))))
			  0)))
		(let ((subtag (jref sequence 1)))
		  (if (= subtag 20)
		      (- (/ (jref sequence 0) 64) 4)
		      (if (= subtag 116)
			  (- (/ (jref sequence 0) 8) 31)
			  (error "not a sequence")))))))))
(defun mod (x y) (multiple-value-call #'(lambda (q r) r) (floor x y)))
(defun functionp (object) (eq (type-of object) 'function))
(defun coerce (object result-type)
  (if (typep object result-type)
      object
      (case result-type
	((t) object)
	(character (character object))
	(function (if (and (consp object) (eq (car object) 'lambda))
		      (eval (list 'function object))
		      (if (fboundp object)
			  (fdefinition object))
			  (error 'type-error :datum object
				 :expected-type result-type)))
	(t (error 'type-error :datum object :expected-type result-type)))))
(defun ensure-type (name expander)
  (let ((cons (assoc name *type-expanders*)))
    (if cons
	(setf (cdr cons) expander)
	(push (cons name expander) *type-expanders*))
    name))
(defmacro deftype (name lambda-list &rest forms)
  `(ensure-type ',name #'(lambda ,lambda-list (block ,name ,@forms))))
(defun *= (cons number)
  (or (not cons) (eq (car cons) '*) (= (car cons) number)))
(defun typep (object type-specifier &optional environment)
  (let ((tag (ldb '(2 . 0) (ival object))))
    (case type-specifier
      ((nil extended-char) nil)
      ((t *) t)
      (null (not object))
      (list (or (not object) (= tag 1)))
      (fixnum (and (= tag 0) (= (ldb '(5 . 0) (ival object)) 16)))
      (package (and (= tag 2) (= (iref object 1) 5)))
      (symbol (or (not object) (and (= tag 2) (= (iref object 1) 0))))
      ((character base-char)
       (and (= tag 0) (= (ldb '(5 . 0) (ival object)) 24)))
      (standard-char (and (= tag 0)
			  (= (ldb '(5 . 0) (ival object)) 24)
			  (let ((code (char-code object)))
			    (or (= code 10)
				(< 31 code 127)))))
      (bit (member object '(0 1)))
      (t (setq type-specifier (designator-list type-specifier))
	 (case (car type-specifier)
	   (cons (and (= tag 1)
		      (or (not (cdr type-specifier))
			  (typep (car object) (cadr type-specifier)))
		      (or (not (cddr type-specifier))
			  (typep (car object) (caddr type-specifier)))))
	   ((string base-string) (and (stringp object)
				      (*= (cdr type-specifier)
					  (length object))))
	   (satisfies (funcall (cadr type-specifier) object))
	   (member (member object (cdr type-specifier)))
	   (not (not (typep object (cadr type-specifier))))
	   (and (every #'(lambda (spec) (typep object spec))
		       (cdr type-specifier)))
	   (or (some #'(lambda (spec) (typep object spec))
		     (cdr type-specifier)))
	   (eql (eql object (cadr type-specifier)))
	   (t (when (= tag 2)
		(let ((class (iref object 1)))
		  (when (= (ldb '(2 . 0) (ival class)) 2)
		    (member (car type-specifier)
			    (mapcar #'class-name
				    (class-precedence-list class))))))))))))
(defun fboundp (function-name)
  (if (consp function-name)
      (iboundp (cadr function-name) 6)
      (iboundp function-name 5)))
(defun fdefinition (function-name)
  (if (consp function-name)
      (if (iboundp (cadr function-name) 6)
	  (iref (cadr function-name) 6)
	  (error 'undefined-error :name function-name))
      (if (iboundp function-name 5)
	  (iref function-name 5)
	  (error 'undefined-error :name function-name))))
(defun function-lambda-expression (function)
  (values (list* 'lambda (iref function 4) (iref function 5))
	  (iref function 3)
	  (iref function 6)))
(defmacro defconstant (name initial-value &optional documentation)
  `(progn
    (setf (iref ',name 4) ,initial-value)
    (setf (iref ',name 8) (dpb 1 '(1 . 4) (iref ',name 8)))
    ',name))
(defmacro defparameter (name initial-value &optional documentation)
  `(progn
    (setf (iref ',name 4) ,initial-value)
    (setf (iref ',name 8) (dpb 1 (cons 1 2) (iref ',name 8)))
    ',name))
(defparameter *type-expanders* nil)
(defconstant call-arguments-limit 65536)
(defconstant lambda-parameters-limit 65536)
(defconstant multiple-values-limit 65536)
(defconstant lambda-list-keywords
  '(&allow-other-keys &aux &body &environment &key &optional &rest &whole))
(defmacro defvar (name &rest rest)
  `(progn
    (unless (or (iboundp ',name 4) ,(not rest))
      (setf (iref ',name 4) ,(car rest)))
    (setf (iref ',name 8) (dpb 1 (cons 1 2) (iref ',name 8)))
    ',name))
(defmacro psetq (&rest rest)
  (let ((inits nil)
	(sets nil)
	(list rest))
    (tagbody
     start
       (when (cddr list)
	 (push (list (gensym) (cadr list)) inits)
	 (setq list (cddr list))
	 (go start)))
    (setq list inits)
    (tagbody
     start
       (when (cddr rest)
	 (push (caar list) sets)
	 (push (car rest) sets)
	 (setq list (cdr list))
	 (setq rest (cddr rest))
	 (go start)))
    `(let ,(reverse inits)
      (setq ,@sets ,@rest))))
(defmacro return (&optional result)
  `(return-from nil ,result))
(defmacro when (test-form &rest forms)
  `(if ,test-form (progn ,@forms)))
(defmacro unless (test-form &rest forms)
  `(if (not ,test-form) (progn ,@forms)))
(defmacro and (&rest forms)
  (if forms
      (if (cdr forms)
	  `(when ,(car forms) (and ,@(cdr forms)))
	(car forms))
    `t))
(defmacro or (&rest forms)
  (if forms
      (if (cdr forms)
	  (let ((temp (gensym)))
	    `(let ((,temp ,(car forms)))
	      (if ,temp
		  ,temp
		(or ,@(cdr forms)))))
	(car forms))
    `nil))
(defmacro cond (&rest clauses)
  (when clauses
    (if (cdar clauses)
	`(if ,(caar clauses)
	     (progn ,@(cdar clauses))
	     (cond ,@(cdr clauses)))
	`(or ,(caar clauses)
	     (cond ,@(cdr clauses))))))
(defmacro case (keyform &rest clauses)
  (let ((temp (gensym)))
    (labels ((recur (clauses)
	       (when clauses
		 (if (member (caar clauses) '(otherwise t))
		     `(progn ,@(cdar clauses))
		     `(if ,(if (listp (caar clauses))
			       `(member ,temp ',(caar clauses))
			       `(eql ,temp ',(caar clauses)))
		          (progn ,@(cdar clauses))
		          ,(recur (cdr clauses)))))))
      `(let ((,temp ,keyform))
	,(recur clauses)))))
(defun type-of (object)
  (case (ldb (cons 2 0) (ival object))
    (0 (if (eq object nil)
	   'null
	   (if (= (ldb (cons 2 3) (ival object)) 2)
	       'fixnum
	       'character)))
    (1 'cons)
    (2 (case (iref object 1)
	 (0 'symbol)
	 (3 'simple-vector)
	 (4 'array)
	 (5 'package)
	 (6 'function)
	 (t (class-name (iref object 1)))))
    (3 (case (jref object 1)
	 (20 'simple-string)
	 (84 'double)
	 (116 'simple-bit-vector)
	 (t 'file-stream)))))
(defmacro ecase (keyform &rest clauses)
  (let ((temp (gensym)))
    `(let ((,temp ,keyform))
      (case ,temp ,@clauses
	    (error 'type-error :datum ,temp
		   :expected-type `(member ,@(mapcan #'(lambda (x)
							 (if (listp (car x))
							     (car x)
							     (list (car x))))
						     clauses)))))))
(defmacro multiple-value-bind (vars values-form &rest forms)
  `(multiple-value-call #'(lambda (&optional ,@vars &rest ,(gensym))
			    ,@forms)
                        ,values-form))
(defmacro multiple-value-list (form)
  `(multiple-value-call #'list ,form))
(defun values-list (list)
  (apply #'values list))
(defmacro nth-value (n form)
  `(nth ,n (multiple-value-list ,form)))
(defmacro prog (inits &rest forms)
  `(block nil
    (let ,inits
      (tagbody ,@forms))))
(defmacro prog* (inits &rest forms)
  `(block nil
    (let* ,inits
      (tagbody ,@forms))))
(defmacro prog1 (first-form &rest forms)
  (let ((temp (gensym)))
    `(let ((,temp ,first-form))
      ,@forms
      ,temp)))
(defmacro prog2 (first-form second-form &rest forms)
  (let ((temp (gensym)))
    `(progn
      ,first-form
      (let ((,temp ,second-form))
	,@forms
	,temp))))
(defun eql (a b)
  (or (eq a b)
      (and (= (ldb '(2 . 0) (ival a)) 3)
	   (= (ldb '(2 . 0) (ival b)) 3)
	   (= (jref a 1) 84)
	   (= (jref b 1) 84)
	   (= a b))))
(defun equal (a b)
  (or (eql a b)
      (cond
	((not a) nil)
	((consp a) (and (consp b)
			(equal (car a) (car b))
			(equal (cdr a) (cdr b))))
	((stringp a) (and (stringp b)
			  (string= a b)))
	((bit-vector-p a) (and (bit-vector-p b)
			       (= (length a) (length b))
			       (dotimes (i (length a) t)
				 (when (/= (aref a i) (aref b i))
				   (return))))))))
(defun equalp (a b)
  (or (eql a b)
      (cond
	((not a) nil)
	((characterp a) (and (characterp b)
			     (char-equal a b)))
	((consp a) (and (consp b)
			(equalp (car a) (car b))
			(equalp (cdr a) (cdr b))))
	((arrayp a) (and (arrayp b)
			 (equal (array-dimensions a) (array-dimensions b))
			 (dotimes (i (apply #'* (array-dimensions a)) t)
			   (unless (equalp (row-major-aref a i)
					   (row-major-aref b i))
			     (return)))))
	((= (ldb '(2 . 0) (ival a)) 2)
	 (and (= (ldb '(2 . 0) (ival b)) 2)
	      (eq (iref a 1) (iref b 1))
	      (= (ldb '(2 . 0) (ival (iref a 1))) 2)
	      (dotimes (i (iref a 0) t)
		(unless (equalp (iref a (+ 2 i)) (iref b (+ 2 i)))
		  (return))))))))
(defun identity (object) object)
(defun complement (function)
  #'(lambda (&rest rest) (not (apply function rest))))
(defun constantly (value) #'(lambda (&rest rest) value))
(defmacro do (vars (end-test-form &rest result-forms) &rest forms)
  (let ((start (gensym))
	(inits nil)
	(steps nil))
  `(block nil
    (let ,(dolist (var vars (reverse inits))
	    (push (if (consp var)
		      (list (car var) (cadr var))
		      (list var)) inits))
      (tagbody
	 ,start
	 (if ,end-test-form (return (progn ,@result-forms)))
	 ,@forms
	 ,@(dolist (var vars (when steps `((psetq ,@(reverse steps)))))
	     (when (and (consp var) (cddr var))
	       (push (car var) steps)
	       (push (caddr var) steps)))
	 (go ,start))))))
(defmacro do* (vars (end-test-form &rest result-forms) &rest forms)
  (let ((start (gensym))
	(inits nil)
	(steps nil))
  `(block nil
    (let* ,(dolist (var vars (reverse inits))
	     (push (if (consp var)
		       (list (car var) (cadr var))
		       (list var)) inits))
      (tagbody
	 ,start
	 (if ,end-test-form (return (progn ,@result-forms)))
	 ,@forms
	 ,@(dolist (var vars (when steps `((setq ,@(reverse steps)))))
	     (when (and (consp var) (cddr var))
	       (push (car var) steps)
	       (push (caddr var) steps)))
	 (go ,start))))))
(defmacro dotimes ((var count-form &optional result-form) &rest forms)
  (let ((start (gensym))
	(count (gensym)))
    `(block nil
      (let ((,var 0)
	    (,count ,count-form))
	(tagbody
	   ,start
	   (when (< ,var ,count)
	     ,@forms
	     (incf ,var)
	     (go ,start)))
	,result-form))))
(defmacro dolist ((var list-form &optional result-form) &rest forms)
  (let ((start (gensym))
	(list (gensym)))
    `(block nil
      (let ((,list ,list-form)
	    (,var nil))
	(tagbody
	   ,start
	   (unless ,list
	     (setf ,var nil)
	     (return-from nil ,result-form))
	   (setf ,var (car ,list))
	   (setf ,list (cdr ,list))
	   ,@forms
	   (go ,start))))))
(defmacro check-type (place typespec &optional string)
  `(tagbody
    start
    (unless (typep ,place ',typespec)
      (restart-case
	  (error 'type-error :datum ,place :expected-type ',typespec)
	(store-value (value)
	  (setf ,place value)))
      (go start))))
(defun designator-condition (default-type datum arguments)
  (if (symbolp datum)
      (apply #'make-condition datum arguments)
      (if (or (stringp datum) (functionp datum))
	  (make-condition default-type
			  :format-control datum
			  :format-arguments arguments)
	  datum)))
(defun error (datum &rest arguments)
  (let ((condition (designator-condition 'simple-error datum arguments)))
    (when (typep condition *break-on-signals*)
      (invoke-debugger condition))
    (invoke-handler condition)
    (invoke-debugger condition)))
(defun cerror (continue-format-control datum &rest arguments)
  `(with-simple-restart (continue continue-format-control)
    (apply #'error datum arguments)))
(defun signal (datum &rest arguments)
  (let ((condition (designator-condition 'simple-condition datum arguments)))
    (when (typep condition *break-on-signals*)
      (invoke-debugger condition))
    (invoke-handler condition)
    nil))
(defun warn (datum &rest arguments)
  (restart-case
      (let ((warning (if (symbolp datum)
			 (apply #'make-condition 'warning datum arguments)
			 datum)))
	(signal warning)
	(print-object warning *error-output*))
    (muffle-warning () nil))
  nil)
(defun show-frame (frame index)
  (let* ((length (fref (- frame 2)))
	 (fn (fref (- frame length 3))))
    (when (and (= (ldb '(2 . 0) (ival fn)) 2) (= (iref fn 1) 6))
      (format *debug-io* "~A: (~A" index (iref fn 6))
      (dotimes (i length)
	(format *debug-io* " ~A" (fref (+ i (- frame length 2)))))
      (format *debug-io* ")~%"))))
(defun next-frame (frame)
  (- frame (fref (- frame 2)) 3))
(defun next-function-frame (frame)
  (do* ((f (next-frame frame) (next-frame f)))
       ((or (< f 6)
	    (let ((fn (fref (- f (fref (- f 2)) 3))))
	      (and (= (ldb '(2 . 0) (ival fn)) 2) (= (iref fn 1) 6))))
	(and (> f 5) f))))
(defun invoke-debugger (condition)
  (let ((debugger-hook *debugger-hook*)
	(*debugger-hook* nil))
    (when debugger-hook
      (funcall debugger-hook condition debugger-hook))
    (format *debug-io* "Entering debugger.~%")
    (princ condition *debug-io*)
    (terpri *debug-io*)
    (let ((restarts (compute-restarts condition))
	  (stack (makef))
	  (frame-depth 0)
	  (active-frame nil))
      (let ((count 0))
	(dolist (restart restarts)
	  (format *debug-io* "~A: " count)
	  (princ restart *debug-io*)
	  (terpri *debug-io*)
	  (incf count)))
      (setq active-frame (next-function-frame (- stack 20)))
      (show-frame active-frame 0)
      (tagbody
       start
	 (format *debug-io* ";~A> " frame-depth)
	 (let ((form (read)))
	   (case form
	     (:help (format *debug-io* "Type :help to get help.~%")
		    (format *debug-io* "Type :continue <index> to invoke the indexed restart.~%"))
	     (:back (do ((frame (next-function-frame (- stack 20))
				(next-function-frame frame))
			 (index 0 (+ 1 index)))
			((not frame))
		      (show-frame frame index)))
	     (:up (if (plusp frame-depth)
		      (progn
			(decf frame-depth)
			(do ((frame (next-function-frame (- stack 20))
				    (next-function-frame frame))
			     (index 0 (+ 1 index)))
			    ((= index frame-depth) (setq active-frame frame)))
			(show-frame active-frame frame-depth))
		      (format *debug-io* "Top of stack.~%")))
	     (:down (let ((frame (next-function-frame active-frame)))
		      (if frame
			  (progn
			    (incf frame-depth)
			    (setq active-frame frame)
			    (show-frame active-frame frame-depth))
			  (format *debug-io* "Bottom of stack.~%"))))
	     (:locals (do ((env (fref (- active-frame 1)) (cdr env)))
			  ((not env))
			(when (symbolp (caar env))
			  (format *debug-io* "~A~%" (caar env)))))
	     (:continue (let ((index (read)))
			  (invoke-restart-interactively (nth index restarts))))
	     (t (let ((values (multiple-value-list
			       (eval form (fref (- active-frame 1)))))
		      (count 0))
		  (if values
		      (dolist (value values)
			(format *debug-io* ";~A: ~S~%" count value)
			(incf count))
		      (format *debug-io* ";No values.~%")))))
	   (go start))))))
(defun break (&optional format-control &rest format-arguments)
  (with-simple-restart (continue "Return from BREAK.")
    (let ((*debugger-hook* nil))
      (invoke-debugger (make-condition 'simple-condition
				       :format-control format-control
				       :format-arguments format-arguments))))
  nil)
(defparameter *debugger-hook* nil)
(defparameter *break-on-signals* nil)
(defparameter *handlers* nil)
(defun invoke-handler (condition)
  (dolist (handler *handlers*)
    (when (typep condition (car handler))
      (setq *handlers* (caddr handler))
      (funcall (cadr handler) condition))))
(defmacro handler-bind (bindings &rest forms)
  (let ((form '*handlers*)
	(handlers (gensym)))
    (dolist (binding (reverse bindings))
      (setq form
	    `(cons (list ',(car binding) ,(cadr binding) ',handlers) ,form)))
    `(let ((handlers *handlers*)
	   (*handlers* ,form))
      ,@forms)))
(defmacro handler-case (expression &rest clauses)
  (let ((tag (gensym))
	(bindings nil))
    `(handler-bind
      ,(dolist (clause clauses (reverse bindings))
	 (let ((typespec (car clause))
	       (var-list (cadr clause))
	       (forms (cddr clauses)))
	   (push `(typespec #'(lambda (,(if var-list (car var-list) (gensym)))
				(return-from tag (progn ,@forms))))
		 bindings)))
      ,expression)))
(defmacro ignore-errors (&rest forms)
  `(handler-case (progn ,@forms)
    (error (condition) (values nil condition))))
(defparameter *restarts* nil)
(defun compute-restarts (&optional condition)
  "FIXME restarts associated with conditions"
  (if condition
      *restarts*
      *restarts*))
(defun find-restart (identifier &optional condition)
  (dolist (restart *restarts*)
    (when (eq restart identifier)
      (return restart))
    (when (eq (restart-name restart) identifier)
      (return restart))))
(defun designator-restart (designator)
  (if (restartp designator)
      designator
      (dolist (restart *restarts* (error 'type-error :datum designator
					 :expected-type 'restart))
	(when (eq (restart-name restart) designator)
	  (return restart)))))
(defun invoke-restart (restart &rest arguments)
  (setq restart (designator-restart restart))
  (apply (restart-function restart) arguments))
(defun invoke-restart-interactively (restart)
  (setq restart (designator-restart restart))
  (apply (restart-function restart)
	 (funcall (restart-interactive-function restart))))
(defmacro restart-bind (restart-bindings &rest forms)
  (let ((form '*restarts*))
    (dolist (binding (reverse restart-bindings))
      (setq form
	    `(cons (make-restart ',(car binding) ,@(cdr binding)) ,form)))
    `(let ((*restarts* ,form))
      ,@forms)))
(defmacro restart-case (restartable-form &rest clauses)
  (let ((catch-tag (gensym))
	(bindings nil))
    `(catch ',catch-tag
      (restart-bind
	  ,(dolist (clause clauses (reverse bindings))
	     (let ((name (car clause))
		   (lambda-list (cadr clause))
		   (rest (cddr clause))
		   (interactive '#'(lambda () nil))
		   (report '#'(lambda (stream)
				(format stream "~A" (car clause))))
		   (test '#'(lambda (condition) t)))
	       (tagbody
		start
		  (when (member (car rest) '(:interactive :report :test))
		    (let ((value (cadr rest)))
		      (case (car rest)
			(:interactive (setq interactive `(function ,value)))
			(:report (setq report
				       (if (stringp value)
					   `#'(lambda (stream)
						(write-string ,value stream))
					   `(function ,value))))
			(:test (setq test `(function ,value)))))
		    (setq rest (cddr rest))
		    (go start)))
	       (push `(,(car clause)
		       #'(lambda ,(cadr clause)
			   (throw ',catch-tag (progn ,@rest)))
		       :interactive-function ,interactive
		       :report-function ,report
		       :test-function ,test)
		     bindings)))
	,restartable-form))))
(defmacro with-simple-restart ((name format-control &rest format-arguments)
			       &rest forms)
  (let ((tag (gensym)))
    `(block ,tag
      (restart-bind
	  ((,name
	    #'(lambda () (return-from ,tag (values nil t)))
	     :interactive-function #'(lambda () nil)
	     :report-function #'(lambda (stream)
				  (apply #'format stream ',format-control
					 ',format-arguments))
	     :test-function #'(lambda () t)))
	,@forms))))
(defun abort (&optional condition)
  (invoke-restart (find-restart 'abort condition))
  (error 'control-error))
(defun continue (&optional condition)
  (invoke-restart (find-restart 'continue condition)))
(defun muffle-warning (&optional condition)
  (invoke-restart (find-restart 'muffle-warning condition))
  (error 'control-error))
(defun store-value (value &optional condition)
  (invoke-restart (find-restart 'store-value condition) value))
(defun use-value (value &optional condition)
  (invoke-restart (find-restart 'use-value condition) value))
(defun integer-string (integer &optional (radix 10))
  (if (= integer 0)
      "0"
      (labels ((recur (i l)
		 (if (= i 0)
		     l
		     (multiple-value-bind (ni r)
			 (floor i radix)
		       (recur ni (cons (code-char (+ (if (< r 10) 48 55) r))
				       l))))))
	(apply #'string (if (< 0 integer)
			    (recur integer nil)
			    (cons (code-char 45) (recur (- integer) nil)))))))
(defun designator-symbol (designator)
  (if (symbolp designator)
      designator
      (find-symbol designator)))
(defun symbolp (object) (or (null object) (eq (type-of object) 'symbol)))
(defun keywordp (object)
  (and (symbolp object)
       (string= (package-name (symbol-package object)) "KEYwORD")))
(defun make-symbol (name)
  (let ((symbol (makei 9 0 name nil nil nil nil (- 1) 0)))
    (imakunbound symbol 4)
    (imakunbound symbol 5)
    (imakunbound symbol 6)
    symbol))
(defun copy-symbol (symbol &optional copy-properties)
  (let ((new-symbol (make-symbol (iref symbol 2))))
    (cond
      (copy-properties
       (setf (iref new-symbol 4) (iref symbol 4))
       (setf (iref new-symbol 5) (iref symbol 5))
       (setf (iref new-symbol 6) (iref symbol 6))
       (setf (iref new-symbol 10) (iref symbol 10)))
      (t
       (imakunbound new-symbol 4)
       (imakunbound new-symbol 5)
       (imakunbound new-symbol 6)))
    new-symbol))
(defun fixnump (object)
  (= (ldb '(5 . 0) (ival object)) 16))
(defvar *gensym-counter* 0)
(defun gen-sym (&optional x)
  (let ((prefix (if (stringp x) x "G"))
	(suffix (if (fixnump x)
		    x
		    (let ((x *gensym-counter*))
		      (setf *gensym-counter* (+ 1 *gensym-counter*))))))
    (make-symbol (conc-string prefix (integer-string suffix)))))
(let ((gentemp-counter 0))
  (defun gentemp (&optional (prefix "T") (package *package*))
    (setf gentemp-counter (+ 1 gentemp-counter))
    (intern (conc-string prefix (integer-string gentemp-counter))
	    package)))
(defun symbol-function (symbol)
  (if (iboundp symbol 5)
      (iref symbol 5)
      (error 'undefined-function :name symbol)))
(defun (setf symbol-function) (new-contents symbol)
  (setf (iref symbol 5) new-contents))
(defun symbol-name (symbol) (iref symbol 2))
(defun symbol-package (symbol) (iref symbol 9))
(defun symbol-plist (symbol) (iref symbol 10))
(defun (setf symbol-plist) (new-plist symbol)
  (setf (iref symbol 10) new-plist))
(defun symbol-value (symbol)
  (if (iboundp symbol 4)
      (iref symbol 4)
      (error 'unbound-variable :name symbol)))
(defun (setf symbol-value) (new-value symbol) (setf (iref symbol 4) new-value))
(defun get (symbol indicator &optional default)
  (getf (symbol-plist symbol) indicator default))
(defun (setf get) (new-value symbol indicator &optional default)
  (setf (getf (symbol-plist symbol) indicator default) new-value))
(defun remprop (symbol indicator) (remf (symbol-plist symbol) indicator))
(defun boundp (symbol) (iboundp symbol 4))
(defun makunbound (symbol) (imakunbound symbol 4))
(defun set (symbol value) (setf (symbol-value symbol) value))
(defun designator-string (designator)
  (if (stringp designator)
      designator
      (if (characterp designator)
	  (string designator)
	  (symbol-name designator))))
(defvar *package* (car (cdr *packages*)))
(defun find-package (name)
  (if (packagep name)
      name
      (let ((string (designator-string name)))
	(dolist (package *packages*)
	  (dolist (package-name (iref package 2))
	    (when (string= package-name string)
	      (return-from find-package package)))))))
(defun export (symbols &optional (package *package*))
  (setq package (find-package package))
  (dolist (symbol (designator-list symbols))
    (setf symbol (designator-symbol symbol))
    (dolist (using-package (iref package 7))
      (when (find-symbol (symbol-name symbol) using-package)
	(cerror 'package-error :package using-package)))
    (unless (atom (package-get (iref package 3) (symbol-name symbol)))
      (unless (atom (package-get (iref package 4) (symbol-name symbol)))
	(cerror 'package-error :package package))
      (package-rem (iref package 4) symbol)
      (package-put (iref package 3) symbol))))
(defun package-rehash (old-vector new-vector)
  (let ((old-length (length old-vector))
	(new-length (length new-vector))
	(i 0))
    (tagbody
     start
       (when (< i old-length)
	 (dolist (symbol (iref old-vector (+ 2 i)))
	   (push symbol (iref new-vector (+ 2 (mod (hash (symbol-name symbol))
						   new-length)))))
	 (incf i)
	 (go start)))
    new-vector))
(defun package-get (vector string)
  (dolist (symbol (iref vector (+ 2 (mod (hash string) (length vector))))
	   '(nil))
    (when (string= (symbol-name symbol) string)
      (return symbol))))
(defun package-put (vector symbol)
  (push symbol (iref vector (+ 2 (mod (hash (symbol-name symbol))
				      (length vector))))))
(defun package-rem (vector string)
  (let ((index (+ 2 (mod (hash string) (length vector)))))
    (setf (iref vector index)
	  (delete string (iref vector index) :key #'symbol-name))))
(defun find-symbol (string &optional (package *package*))
  (setq package (find-package package))
  (unless package
    (error "Package does not exist."))
  (let ((symbol (package-get (iref package 4) string)))
    (if (atom symbol)
	(values symbol :internal)
	(let ((symbol (package-get (iref package 3) string)))
	  (if (atom symbol)
	      (values symbol :external)
	      (dolist (used-package (package-use-list package)
		       (values nil nil))
		(let ((symbol (package-get (iref used-package 3) string)))
		  (when (atom symbol)
		    (values symbol :inherited)))))))))
(defun find-all-symbols (string)
  (let ((symbols nil))
    (dolist (package *packages*)
      (let ((symbol (package-get (iref package 4) string)))
	(when (atom symbol)
	  (push symbol symbols)))
      (let ((symbol (package-get (iref package 3) string)))
	(when (atom symbol)
	  (push symbol symbols))))
    symbols))
(defun import (symbols &optional (package *package*))
  (setq package (find-package package))
  (dolist (symbol (designator-list symbols))
    (multiple-value-bind (symbol status)
	(find-symbol (symbol-name symbol) package)
      (case status
	(:inherited
	 (cerror 'package-error :package package))
	((nil)
	 (package-put (iref package 4) symbol)
	 (unless (iref symbol 9)
	   (setf (iref symbol 9) package))))))
  t)
(defun list-all-packages ()
  (copy-list *packages*))
(defun rename-package (package new-name &optional new-nicknames)
  (setq package (find-package package))
  (when (packagep new-name) (setq new-name (package-name new-name)))
  (setf new-nicknames (mapcar #'designator-string new-nicknames))
  (setf (iref package 2) (cons new-name new-nicknames))
  package)
(defun shadow (symbol-names &optional (package *package*))
  (setq package (find-package package))
  (dolist (symbol-name symbol-names)
    (multiple-value-bind (symbol status)
	(find-symbol symbol-name package)
      (unless (member status '(:internal :external))
	(setq symbol (make-symbol string))
	(setf (iref symbol 9) package)
	(package-put (iref package 4) symbol))
      (pushnew symbol (iref package 5))))
  t)
(defun shadowing-import (symbols &optional package)
  (setq package (find-package package))
  (dolist (symbol (designator-list symbols))
    (package-rem (iref package 3) (symbol-name symbol))
    (package-rem (iref package 4) (symbol-name symbol))
    (package-put (iref package 4) symbol)
    (push symbol (iref package 5)))
  t)
(defun delete-package (package)
  (setq package (find-package package))
  (when (iref package 7)
    (cerror 'package-error package))
  (prog1
      (package-name package)
    (setf (iref package 2) nil)))
(defun make-package (package-name &key nicknames (use '("cl")))
  (let ((all-names (cons package-name nicknames)))
    (mapc #'(lambda (name)
	      (when (find-package name)
		(cerror 'package-error :package name)))
	  all-names)
    (let ((package (makei 6 5 all-names (make-array 1021) (make-array 1021) nil
			  (mapcar #'find-package use))))
      (mapc #'(lambda (used-package)
		(push package (iref (find-package used-package) 7)))
	    use)
      (push package *packages*)
      package)))
(defun make-package-iterator (package symbol-types)
  (setq package (find-package package))
  (list nil package symbol-types))
(defun package-iterate (iterator)
  (unless (first iterator)
    (setf (first iterator)
	  (case (pop (third iterator))
	    (:internal (iref (second iterator) 4))
	    (:external (iref (second iterator) 3))
	    (:inherited "FIXME")
	    ((nil) (return-from package-iterate nil)))))
  (pop (first iterator)))
(defmacro with-package-iterator ((name package-list-form &rest symbol-types)
				 &rest forms)
  (let ((package (gensym))
	(iterator (gensym)))
    `(dolist (,package (designator-list ,package-list-form))
      (let ((,iterator (make-package-iterator ,package ',symbol-types)))
	(macrolet ((,name () (package-iterate ,iterator)))
	  ,@forms)))))
(defun unexport (symbols &optional (package *package*))
  (setq package (find-package package))
  (dolist (symbol (designator-list symbols))
    (setq symbol (designator-symbol symbol))
    (when symbol
      (when (atom (package-get (iref package 3) (symbol-name symbol)))
	(package-rem (iref package 3) (symbol-name symbol))
	(package-put (iref package 4) symbol))))
  t)
(defun unintern (symbol &optional (package *package*))
  (setq package (find-package package))
  (when (eq package (iref symbol 9))
    (setf (iref symbol 9) nil))
  (let* ((name (symbol-name symbol))
	 (present (or (atom (package-get (iref package 3) name))
		      (atom (package-get (iref package 4) name)))))
    (package-rem (iref package 3) name)
    (package-rem (iref package 4) name)
    (setf (iref package 5) (delete symbol (iref package 5)))
    present))
(defmacro in-package (name)
  `(setf *package* (find-package ',name)))
(defun unuse-package (packages-to-unuse &optional (package *package*))
  (setq package (find-package package))
  (dolist (package-to-unuse (designator-list packages-to-unuse))
    (setq package-to-unuse (find-package package-to-unuse))
    (setf (iref package 6) (delete package-to-unuse (iref package 6)))
    (setf (iref package-to-unuse 7)
	  (delete package (iref package-to-unuse 7))))
  t)
(defun use-package (packages-to-use &optional (package *package*))
  (setq package (find-package package))
  (dolist (package-to-use (designator-list packages-to-use))
    (setq package-to-use (find-package package-to-use))
    (push package-to-use (iref package 6))
    (push package (iref package-to-use 7)))
  t)
(defun ensure-package (name nicknames shadow shadowing-import-from use
		       import-from intern export)
  (let ((package (find-package name)))
    (unless package
      (setq package (make-package name :nicknames nicknames)))
    (shadow shadow package)
    (mapc #'(lambda (list)
	      (let ((imported-package (find-package (car list)))
		    (symbol-names (cdr list)))
		(shadowing-import (mapcar #'(lambda (symbol-name)
					      (find-symbol symbol-name
							   imported-package))
					  symbol-names)
				  package)))
	  shadowing-import-from)
    (use-package use package)
    (mapc #'(lambda (list)
	      (let ((imported-package (find-package (car list)))
		    (symbol-names (cdr list)))
		(import (mapcar #'(lambda (symbol-name)
				    (find-symbol symbol-name imported-package))
				symbol-names)
			package)))
	  import-from)
    (mapc #'(lambda (symbol-name) (intern symbol-name package)) intern)
    (export export package)
    package))
(defmacro defpackage (defined-package-name &rest options)
  (flet ((option (option-name)
	   (mapcan #'(lambda (option)
		       (when (eq (car option) option-name)
			 (mapcar #'designator-string (cdr option))))
		   options))
	 (options (option-name)
	   (mapcan #'(lambda (option)
		       (when (eq (car option) option-name)
			 (list (mapcar #'designator-string (cdr option)))))
		   options)))
    `(ensure-package ,(designator-string defined-package-name)
      ,(option :nicknames)
      ,(option :shadow) ,(options :shadowing-import-from) ,(option :use)
      ,(options :import-from) ,(option :intern) ,(option :export))))
(defmacro do-symbols ((var &optional (package *package*) result-form)
		      &rest forms)
  (let ((package-sym (gensym)))
    `(block nil
      (let ((,package-sym (find-package package))
	    (,var nil))
	(dolist (,var (iref ,package-sym 3))
	  ,@forms)
	(dolist (,var (iref ,pakcage-sym 4))
	  ,@forms)
	,result-form))))
(defmacro do-external-symbols ((var &optional (package *package*) result-form)
			       &rest forms)
  (let ((package-sym (gensym)))
    `(let ((,package-sym (find-package ,package)))
      (dolist (,var (iref ,package-sym 3) ,result-form)
	,@forms))))
(defmacro do-all-symbols ((var &optional result-form) &rest forms)
  (let ((package (gensym))
	(symbols (gensym))
	(first (gensym))
	(start-out (gensym))
	(start (gensym)))
    `(let ((,symbols nil)
	   (,first t))
      (dolist (,package *packages* ,result-form)
	,start-out
	(setq ,symbols (iref ,package (if ,first 3 4)))
	(setq ,first (not ,first))
	,start
	(when ,symbols
	  ,@forms
	  (go ,start))
	(when ,first
	  (go ,start-out))))))
(defun intern (string &optional (package *package*))
  (setq package (find-package package))
  (multiple-value-bind (symbol status)
      (find-symbol string package)
    (unless status
      (setq symbol (make-symbol string))
      (setf (iref symbol 9) package)
      (cond
	((string= (package-name package) "KEYWORD")
	 (package-put (iref package 3) symbol)
	 (setf (symbol-value symbol) symbol))
	(t
	 (package-put (iref package 4) symbol))))
    (values symbol status)))
(defun package-name (package) (car (iref (find-package package) 2)))
(defun package-nicknames (package) (cdr (iref (find-package package) 2)))
(defun package-shadowing-symbols (package) (iref (find-package package) 5))
(defun package-use-list (package) (iref (find-package package) 6))
(defun package-used-by-list (package) (iref (find-package package) 7))
(defun packagep (object) (eq (type-of object) 'package))
(defun /= (number &rest numbers)
  (tagbody
   start
     (when numbers
       (dolist (n numbers)
	 (when (= number n)
	   (return-from /=)))
       (setq number (pop numbers))
       (go start)))
  t)
(defun > (&rest numbers)
  (apply #'< (reverse numbers)))
(defun <= (number &rest numbers)
  (dolist (n numbers t)
    (when (< n number)
      (return-from <=))
    (setq number n)))
(defun >= (number &rest numbers)
  (dolist (n numbers t)
    (when (< number n)
      (return-from >=))
    (setq number n)))
(defun max (real &rest reals)
  (dolist (r reals real)
    (when (< real r)
      (setq real r))))
(defun min (real &rest reals)
  (dolist (r reals real)
    (when (< r real)
      (setq real r))))
(defun oddp (integer)
  (= (mod integer 2) 1))
(defun evenp (integer)
  (= (mod integer 2) 0))
(defun minusp (real)
  (< real 0))
(defun plusp (real)
  (< 0 real))
(defun zerop (real)
  (= real 0))
(defun abs (number)
  (if (< number 0)
      (- number)
      number))
(defmacro incf (place &optional (delta-form 1))
  `(setf ,place (+ ,place ,delta-form)))
(defmacro decf (place &optional (delta-form 1))
  `(setf ,place (- ,place ,delta-form)))
(defun byte (size position)
  (cons size position))
(defun byte-size (bytespec)
  (car bytespec))
(defun byte-position (bytespec)
  (cdr bytespec))
(defun char= (&rest characters)
  (apply #'= (mapcar #'char-code characters)))
(defun char/= (&rest characters)
  (apply #'/= (mapcar #'char-code characters)))
(defun char< (&rest characters)
  (apply #'< (mapcar #'char-code characters)))
(defun char> (&rest characters)
  (apply #'> (mapcar #'char-code characters)))
(defun char<= (&rest characters)
  (apply #'<= (mapcar #'char-code characters)))
(defun char>= (&rest characters)
  (apply #'>= (mapcar #'char-code characters)))
(defun char-equal (&rest characters)
  (apply #'char= (mapcar #'char-upcase characters)))
(defun char-not-equal (&rest characters)
  (apply #'char/= (mapcar #'char-upcase characters)))
(defun char-lessp (&rest characters)
  (apply #'char< (mapcar #'char-upcase characters)))
(defun char-greaterp (&rest characters)
  (apply #'char> (mapcar #'char-upcase characters)))
(defun char-not-greaterp (&rest characters)
  (apply #'char<= (mapcar #'char-upcase characters)))
(defun char-not-lessp (&rest characters)
  (apply #'char>= (mapcar #'char-upcase characters)))
(defun character (character)
  (if (characterp character)
      character
      (let ((string (designator-string character)))
	(if (= (length string) 1)
	    (aref string 0)
	    (error 'type-error :datum string :expected-type '(string 1))))))
(defun characterp (object) (= (ldb '(5 . 0) (ival object)) 24))
(defun alpha-char-p (character)
  (let ((code (char-code character)))
    (or (< 64 code 91)
	(< 96 code 123)
	(< 159 code))))
(defun alphanumericp (character)
  (let ((code (char-code character)))
    (or (< 47 code 58)
	(< 64 code 91)
	(< 96 code 123)
	(< 159 code))))
(defun digit-char (weight &optional (radix 10))
  (when (< weight radix)
    (if (< weight 10)
	(code-char (+ 48 weight))
	(code-char (+ 55 weight)))))
(defun digit-char-p (char &optional (radix 10))
  (let* ((code (char-code char))
	 (weight (if (< 47 code 58)
		     (- code 48)
		     (if (< 64 code 91)
			 (- code 55)
			 (when (< 96 code 123)
			   (- code 87))))))
    (and weight (< weight radix) weight)))
(defun standard-char-p (character)
  (let ((code (char-code character)))
    (or (= code 10)
	(< 31 code 127))))
(defun char-upcase (character)
  (let ((code (char-code character)))
    (if (< 96 code 123)
	(code-char (- code 32))
	character)))
(defun char-downcase (character)
  (let ((code (char-code character)))
    (if (< 64 code 91)
	(code-char (+ code 32))
	character)))
(defun upper-case-p (character)
  (< 64 (char-code character) 91))
(defun lower-case-p (character)
  (< 96 (char-code character) 123))
(defun both-case-p (character)
  (or (upper-case-p character) (lower-case-p character)))
(defun char-int (character)
  (char-code character))
(defconstant char-code-limit 256)
(let ((char-names '((0 . "Null")
		    (8 . "Backspace")
		    (9 . "Tab")
		    (10 . "Newline")
		    (12 . "Page")
		    (13 . "Return")
		    (32 . "Space")
		    (127 . "Rubout"))))
  (defun char-name (character)
    (let* ((code (char-code character))
	   (name (cdr (assoc code char-names))))
      (or name (when (< code 32)
		 (conc-string "U+" (integer-string code))))))
  (defun name-char (name)
    (setq name (designator-string name))
    (if (< (length name) 2)
	(aref name 0)
	(if (= (char-code (aref name 0)) 85)
	    (code-char (parse-integer name :start 2))
	    (let ((code (car (rassoc name char-names :test #'string-equal))))
	      (when code (code-char code)))))))
(defun atom (object) (not (consp object)))
(defun rplaca (cons object) (setf (car cons) object) cons)
(defun rplacd (cons object) (setf (cdr cons) object) cons)
(defun caar (x) (car (car x)))
(defun (setf caar) (new-object x) (setf (car (car x)) new-object))
(defun cadr (x) (car (cdr x)))
(defun (setf cadr) (new-object x) (setf (car (cdr x)) new-object))
(defun cdar (x) (cdr (car x)))
(defun (setf cdar) (new-object x) (setf (cdr (car x)) new-object))
(defun cddr (x) (cdr (cdr x)))
(defun (setf cddr) (new-object x) (setf (cdr (cdr x)) new-object))
(defun caaar (x) (car (car (car x))))
(defun (setf caaar) (new-object x) (setf (car (caar x)) new-object))
(defun caadr (x) (car (car (cdr x))))
(defun (setf caadr) (new-object x) (setf (car (cadr x)) new-object))
(defun cadar (x) (car (cdr (car x))))
(defun (setf cadar) (new-object x) (setf (car (cdar x)) new-object))
(defun caddr (x) (car (cdr (cdr x))))
(defun (setf caddr) (new-object x) (setf (car (cddr x)) new-object))
(defun cdaar (x) (cdr (car (car x))))
(defun (setf cdaar) (new-object x) (setf (cdr (caar x)) new-object))
(defun cdadr (x) (cdr (car (cdr x))))
(defun (setf cdadr) (new-object x) (setf (cdr (cadr x)) new-object))
(defun cddar (x) (cdr (cdr (car x))))
(defun (setf cddar) (new-object x) (setf (cdr (cdar x)) new-object))
(defun cdddr (x) (cdr (cdr (cdr x))))
(defun (setf cdddr) (new-object x) (setf (cdr (cddr x)) new-object))
(defun caaaar (x) (car (car (car (car x)))))
(defun (setf caaaar) (new-object x) (setf (car (caaar x)) new-object))
(defun caaadr (x) (car (car (car (cdr x)))))
(defun (setf caaadr) (new-object x) (setf (car (caadr x)) new-object))
(defun caadar (x) (car (car (cdr (car x)))))
(defun (setf caadar) (new-object x) (setf (car (cadar x)) new-object))
(defun caaddr (x) (car (car (cdr (cdr x)))))
(defun (setf caaddr) (new-object x) (setf (car (caddr x)) new-object))
(defun cadaar (x) (car (cdr (car (car x)))))
(defun (setf cadaar) (new-object x) (setf (car (cdaar x)) new-object))
(defun cadadr (x) (car (cdr (car (cdr x)))))
(defun (setf cadadr) (new-object x) (setf (car (cdadr x)) new-object))
(defun caddar (x) (car (cdr (cdr (car x)))))
(defun (setf caddar) (new-object x) (setf (car (cddar x)) new-object))
(defun cadddr (x) (car (cdr (cdr (cdr x)))))
(defun (setf cadddr) (new-object x) (setf (car (cdddr x)) new-object))
(defun cdaaar (x) (cdr (car (car (car x)))))
(defun (setf cdaaar) (new-object x) (setf (cdr (caaar x)) new-object))
(defun cdaadr (x) (cdr (car (car (cdr x)))))
(defun (setf cdaadr) (new-object x) (setf (cdr (caadr x)) new-object))
(defun cdadar (x) (cdr (car (cdr (car x)))))
(defun (setf cdadar) (new-object x) (setf (cdr (cadar x)) new-object))
(defun cdaddr (x) (cdr (car (cdr (cdr x)))))
(defun (setf cdaddr) (new-object x) (setf (cdr (caddr x)) new-object))
(defun cddaar (x) (cdr (cdr (car (car x)))))
(defun (setf cddaar) (new-object x) (setf (cdr (cdaar x)) new-object))
(defun cddadr (x) (cdr (cdr (car (cdr x)))))
(defun (setf cddadr) (new-object x) (setf (cdr (cdadr x)) new-object))
(defun cdddar (x) (cdr (cdr (cdr (car x)))))
(defun (setf cdddar) (new-object x) (setf (cdr (cddar x)) new-object))
(defun cddddr (x) (cdr (cdr (cdr (cdr x)))))
(defun (setf cddddr) (new-object x) (setf (cdr (cdddr x)) new-object))
(defun copy-tree (tree)
  (if (consp tree) (cons (copy-tree (car tree)) (copy-tree (cdr tree))) tree))
(defun sublis (alist tree &rest rest)
  (if (consp tree)
      (let ((a (apply #'sublis alist (car tree) rest))
	    (d (apply #'sublis alist (cdr tree) rest)))
	(if (and (eq a (car tree)) (eq d (cdr tree)))
	    tree
	    (cons a d)))
      (let ((a (apply #'assoc tree alist rest)))
	(if a (cdr a) tree))))
(defun nsublis (alist tree &rest rest)
  (if (consp tree)
      (progn
	(setf (car tree) (apply #'nsublis alist (car tree) rest))
	(setf (cdr tree) (apply #'nsublis alist (cdr tree) rest))
	tree)
      (let ((a (apply #'assoc tree alist rest)))
	(if a (cdr a) tree))))
(defun copy-list (list)
  (if (consp list) (cons (car list) (copy-list (cdr list))) list))
(defun make-list (size &key initial-element)
  (if (= size 0) nil
      (cons initial-element
	    (make-list (- size 1) :initial-element initial-element))))
(defun list* (&rest objects)
  (if (cdr objects)
      (cons (car objects) (apply #'list* (cdr objects)))
      (car objects)))
(defun list-length (list)
  (let ((slow list)
	(fast list)
	(odd nil)
	(len 0))
    (tagbody
     start
       (when (atom fast) (return-from list-length len))
       (setf fast (cdr fast))
       (setf len (+ 1 len))
       (when odd (setf slow (cdr slow)))
       (setf odd (not odd))
       (unless (eq slow fast) (go start)))))
(defun listp (object) (or (consp object) (eq object nil)))
(defmacro push (item place)
  `(setf ,place (cons ,item ,place)))
(defmacro pop (place)
  `(prog1 (car ,place) (setf ,place (cdr ,place))))
(defun first (list) (car list))
(defun (setf first) (new-object list) (setf (car list) new-object))
(defun second (list) (nth 1 list))
(defun (setf second) (new-object list) (setf (nth 1 list) new-object))
(defun third (list) (nth 2 list))
(defun (setf third) (new-object list) (setf (nth 2 list) new-object))
(defun fourth (list) (nth 3 list))
(defun (setf fourth) (new-object list) (setf (nth 3 list) new-object))
(defun fifth (list) (nth 4 list))
(defun (setf fifth) (new-object list) (setf (nth 4 list) new-object))
(defun sixth (list) (nth 5 list))
(defun (setf sixth) (new-object list) (setf (nth 5 list) new-object))
(defun seventh (list) (nth 6 list))
(defun (setf seventh) (new-object list) (setf (nth 6 list) new-object))
(defun eighth (list) (nth 7 list))
(defun (setf eighth) (new-object list) (setf (nth 7 list) new-object))
(defun ninth (list) (nth 8 list))
(defun (setf ninth) (new-object list) (setf (nth 8 list) new-object))
(defun tenth (list) (nth 9 list))
(defun (setf tenth) (new-object list) (setf (nth 9 list) new-object))
(defun nth (n list) (if (< n 1) (car list) (nth (- n 1) (cdr list))))
(defun (setf nth) (new-object n list)
  (if (< n 1)
      (setf (car list) new-object)
      (setf (nth (- n 1) (cdr list)) new-object)))
(defun endp (list) (not list))
(defun nconc (&rest lists)
  (if (cdr lists)
      (if (car lists)
	  (progn (setf (cdr (last (car lists))) (apply #'nconc (cdr lists)))
		 (car lists))
	  (apply #'nconc (cdr lists)))
      (car lists)))
(defun revappend (list tail)
  (if list
      (revappend (cdr list) (cons (car list) tail))
      tail))
(defun nreconc (list tail)
  (if list
      (let ((new-list (cdr list)))
	(setf (cdr list) tail)
	(nreconc new-list list))
      tail))
(defun butlast (list &optional (n 1))
  (let* ((r (cons nil nil))
	 (e list)
	 (m 0))
    (tagbody
     start
       (when (consp e)
	 (setf m (+ m 1))
	 (setf e (cdr e))
	 (go start)))
    (setf n (- m n))
    (setf e r)
    (tagbody
     start
       (unless (consp list) (return-from butlast nil))
       (unless (< n 1)
	 (setf e (setf (cdr e) (cons (car list) nil)))
	 (setf list (cdr list))
	 (setf n (- n 1))
	 (go start)))
    (cdr r)))
(defun nbutlast (list &optional (n 1))
  (let* ((e list)
	 (m 0))
    (tagbody
     start
       (when (consp e)
	 (setf m (+ m 1))
	 (setf e (cdr e))
	 (go start)))
    (setf n (- m n))
    (setf e list)
    (tagbody
     start
       (unless (consp list) (return-from nbutlast nil))
       (unless (< n 2)
	 (setf e (cdr e))
	 (setf n (- n 1))
	 (go start)))
    (setf (cdr e) nil)
    list))
(defun last (list &optional (n 1))
  (let* ((e list)
	 (m 0))
    (tagbody
     start
       (when (consp e)
	 (setf m (+ m 1))
	 (setf e (cdr e))
	 (go start)))
    (setf n (- m n))
    (setf e list)
    (tagbody
     start
       (when (< n 1) (return-from last e))
       (setf e (cdr e))
       (setf n (- n 1))
       (go start))))
(defun ldiff (list object)
  (let* ((r (cons nil nil))
	 (e r))
    (tagbody
     start
       (unless (or (eq object list) (atom list))
	 (setf e (setf (cdr e) (cons (car list) nil)))
	 (setf list (cdr list))
	 (go start)))
    (cdr r)))
(defun tailp (object list)
  (tagbody
   start
     (when (eq object list) (return-from tailp t))
     (unless (consp list) (return-from tailp nil))
     (setf list (cdr list))
     (go start)))
(defun nthcdr (n list) (if (< n 1) list (nthcdr (- n 1) (cdr list))))
(defun rest (list) (cdr list))
(defun (setf rest) (new-tail list) (setf (cdr list) new-tail))
(labels ((all-end (lists)
	   (dolist (elem lists nil)
	     (unless elem (return-from all-end t))))
	 (all-car (lists)
	   (when lists (cons (caar lists) (all-car (cdr lists)))))
	 (all-cdr (lists)
	   (when lists (cons (cdar lists) (all-cdr (cdr lists))))))
  (defun mapc (function &rest lists)
    (let ((list-1 (car lists)))
      (tagbody
       start
	 (when (all-end lists) (return-from mapc list-1))
	 (apply function (all-car lists))
	 (setf lists (all-cdr lists))
	 (go start))))
  (defun mapcar (function &rest lists)
    (let ((result nil)
	  (end nil))
      (tagbody
       start
	 (when (all-end lists) (return-from mapcar result))
	 (let ((cons (cons (apply function (all-car lists)) nil)))
	   (setf end (if end (setf (cdr end) cons) (setf result cons))))
	 (setf lists (all-cdr lists))
	 (go start))))
  (defun mapl (function &rest lists)
    (let ((list-1 (car lists)))
      (tagbody
       start
	 (when (all-end lists) (return-from mapl list-1))
	 (apply function lists)
	 (setf lists (all-cdr lists))
	 (go start))))
  (defun maplist (function &rest lists)
    (let ((result nil)
	  (end nil))
      (tagbody
       start
	 (when (all-end lists) (return-from maplist result))
	 (let ((cons (cons (apply function lists) nil)))
	   (setf end (if end (setf (cdr end) cons) (setf result cons))))
	 (setf lists (all-cdr lists))
	 (go start)))))
(defun mapcan (function &rest lists)
  (apply #'nconc (apply #'mapcar function lists)))
(defun mapcon (function &rest lists)
  (apply #'nconc (apply #'maplist function lists)))
(defun acons (key datum alist) (cons (cons key datum) alist))
(defun copy-alist (alist)
  (when alist (cons (if (consp (car alist))
			(cons (caar alist) (cdar alist))
			(car alist))
		    (copy-alist (cdr alist)))))
(defun pairlis (keys data &optional alist)
  (tagbody
   start
     (when (and keys data)
       (setf alist (acons (car keys) (car data) alist))
       (setf keys (cdr keys))
       (setf data (cdr data))
       (go start)))
  alist)
(defun some-list-2 (predicate list1 list2)
  (tagbody
   start
     (when (and list1 list2)
       (when (funcall predicate (car list1) (car list2))
	 (return-from some-list-2 t))
       (pop list1)
       (pop list2)
       (go start))))
(flet ((satisfies (object elem &key key test test-not)
	 (let* ((zi (if key (funcall key elem) elem))
		(r (funcall (or test test-not #'eql) object zi)))
	   (if test-not (not r) r)))
       (satisfies-if (predicate elem &key key)
	 (funcall predicate (if key (funcall key elem) elem)))
       (satisfies-if-not (predicate elem &key key)
	 (not (funcall predicate (if key (funcall key elem) elem))))
       (seq-start (sequence &key (start 0) end from-end)
	 (if (listp sequence)
	     (if from-end
		 (let ((acc nil)
		       (sequence (nthcdr start sequence)))
		   (tagbody
		    start
		      (when (and sequence (or (not end) (< start end)))
			(push sequence acc)
			(setf sequence (cdr sequence))
			(setf start (+ 1 start))
			(go start)))
		   (list 3 acc start))
		 (list 2 (nthcdr start sequence) start))
	     (if from-end (cons 1 (- end 1)) (cons 0 start))))
       (seq-position (iter)
	 (case (car iter)
	   ((0 1) (cdr iter))
	   (t (caddr iter))))
       (seq-next (iter)
	 (case (car iter)
	   (0 (setf (cdr iter) (+ 1 (cdr iter))))
	   (1 (setf (cdr iter) (- (cdr iter) 1)))
	   (2 (setf (cadr iter) (cdadr iter))
	      (setf (caddr iter) (+ 1 (caddr iter))))
	   (t (setf (cadr iter) (cdadr iter))
	      (setf (caddr iter) (- (caddr iter) 1)))))
       (seq-ref (sequence iter)
	 (case (car iter)
	   ((0 1) (aref sequence (cdr iter)))
	   (2 (caadr iter))
	   (t (caaadr iter))))
       (seq-set (sequence iter value)
	 (case (car iter)
	   ((0 1) (setf (aref sequence (cdr iter)) value))
	   (2 (setf (caadr iter) value))
	   (t (setf (caaadr iter) value))))
       (seq-end-p (sequence iter &key start end from-end)
	 (case (car iter)
	   (0 (or (= (cdr iter) (length sequence))
		  (and end (= end (cdr iter)))))
	   (1 (< (cdr iter) start))
	   (2 (or (null (cadr iter)) (and end (= end (caddr iter)))))
	   (t (or (null (cadr iter)) (< (caddr iter) start)))))
       (seq-result (sequence iter result)
	 (case (car iter)
	   (0 (make-array (length result)
			  :element-type (array-element-type sequence)
			  :initial-contents (reverse result)))
	   (1 (make-array (length result)
			  :element-type (array-element-type sequence)
			  :initial-contents result))
	   (2 (reverse result))
	   (3 result))))
  (defun member (item list &rest rest)
    (tagbody
       start
       (when list
	 (when (apply #'satisfies item (car list) rest)
	   (return-from member list))
	 (setf list (cdr list))
	 (go start))))
  (defun member-if (predicate list &rest rest)
    (tagbody
       start
       (when list
	 (when (apply #'satisfies-if predicate (car list) rest)
	   (return-from member-if list))
	 (setf list (cdr list))
	 (go start))))
  (defun member-if-not (predicate list &rest rest)
    (tagbody
       start
       (when list
	 (when (apply #'satisfies-if-not predicate (car list) rest)
	   (return-from member-if list))
	 (setf list (cdr list))
	 (go start))))
  (defun subst (new old tree &rest rest)
    (if (consp tree)
	(let ((a (apply #'subst new old (car tree) rest))
	      (d (apply #'subst new old (cdr tree) rest)))
	  (if (and (eq a (car tree)) (eq d (cdr tree)))
	      tree
	      (cons a d)))
	(if (apply #'satisfies old tree rest) new tree)))
  (defun subst-if (new predicate tree &rest rest)
    (if (consp tree)
	(let ((a (apply #'subst new predicate (car tree) rest))
	      (d (apply #'subst new predicate (cdr tree) rest)))
	  (if (and (eq a (car tree)) (eq d (cdr tree)))
	      tree
	      (cons a d)))
	(if (apply #'satisfies-if predicate tree rest) new tree)))
  (defun subst-if-not (new predicate tree &rest rest)
    (if (consp tree)
	(let ((a (apply #'subst new predicate (car tree) rest))
	      (d (apply #'subst new predicate (cdr tree) rest)))
	  (if (and (eq a (car tree)) (eq d (cdr tree)))
	      tree
	      (cons a d)))
	(if (apply #'satisfies-if-not predicate tree rest) new tree)))
  (defun nsubst (new old tree &rest rest)
    (if (consp tree)
	(progn
	  (setf (car tree) (apply #'subst new old (car tree) rest))
	  (setf (cdr tree) (apply #'subst new old (cdr tree) rest))
	  tree)
	(if (apply #'satisfies old tree rest) new tree)))
  (defun nsubst-if (new predicate tree &rest rest)
    (if (consp tree)
	(progn
	  (setf (car tree) (apply #'subst new predicate (car tree) rest))
	  (setf (cdr tree) (apply #'subst new predicate (cdr tree) rest))
	  tree)
	(if (apply #'satisfies-if predicate tree rest) new tree)))
  (defun nsubst-if-not (new predicate tree &rest rest)
    (if (consp tree)
	(progn
	  (setf (car tree) (apply #'subst new predicate (car tree) rest))
	  (setf (cdr tree) (apply #'subst new predicate (cdr tree) rest))
	  tree)
	(if (apply #'satisfies-if-not predicate tree rest) new tree)))
  (defun assoc (item alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies item (car elem) rest)
	(return-from assoc elem))))
  (defun assoc-if (predicate alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies-if predicate (car elem) rest)
	(return-from assoc-if elem))))
  (defun assoc-if-not (predicate alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies-if-not predicate (car elem) rest)
	(return-from assoc-if-not elem))))
  (defun rassoc (item alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies item (cdr elem) rest)
	(return-from rassoc elem))))
  (defun rassoc-if (predicate alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies-if predicate (cdr elem) rest)
	(return-from rassoc-if elem))))
  (defun rassoc-if-not (predicate alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies-if-not predicate (cdr elem) rest)
	(return-from rassoc-if-not elem))))
  (defun adjoin (item list &rest rest)
    (dolist (elem list (cons item list))
      (when (apply #'satisfies item elem rest)
	(return-from adjoin list))))
  (defun set-exclusive-or (list-1 list-2 &rest rest &key key)
    (let ((result nil))
      (dolist (item list-1)
	(unless (apply #'member (if key (funcall key item) item) list-2 rest)
	  (push item result)))
      (dolist (item list-2)
	(block matches
	  (dolist (elem list-1)
	    (when (apply #'satisfies
			 (if key (funcall key elem) elem) item rest)
	      (return-from matches)))
	  (push item result)))
      result))
  (defun nset-exclusive-or (list-1 list-2 &rest rest &key key)
    (let ((result nil)
	  (list nil)
	  (item nil))
      (tagbody
       start-1
	 (unless list-1 (go start-2))
	 (setf item (car list-1))
	 (setf list list-2)
	 (setf prev nil)
       start-1-in
	 (unless list (go end-1-in))
	 (let ((elem (if key (funcall key (car list)) (car list))))
	   (when (apply #'satisfies item (if key (funcall key elem) elem) rest)
	     (if prev
		 (setf (cdr prev) (cdr list))
		 (setf list-2 (cdr list)))
	     (setf list-1 (cdr list-1))
	     (go start-1)))
	 (setf prev list)
	 (setf list (cdr list))
	 (go start-1-in)
       end-1-in
	 (setf item (cdr list-1))
	 (setf (cdr list-1) result)
	 (unless result (setf end list-1))
	 (setf result list-1)
	 (setf list-1 item)
	 (go start-1)
       start-2
	 (return-from nset-exclusive-or
	   (if end (progn (setf (cdr end) list-2) result) list-2)))))
  (defun fill (sequence item &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (seq-set sequence iter item)
	   (seq-next iter)
	   (go start))))
    sequence)
  (defun every (predicate &rest sequences)
    (let ((iters (mapcar #'seq-start sequences)))
      (tagbody
       start
	 (unless (some-list-2 #'seq-end-p sequences iters)
	   (unless (apply predicate (mapcar #'seq-ref sequences iters))
	     (return-from every nil))
	   (mapc #'seq-next iters)
	   (go start))))
    t)
  (defun some (predicate &rest sequences)
    (let ((iters (mapcar #'seq-start sequences)))
      (tagbody
       start
	 (unless (some-list-2 #'seq-end-p sequences iters)
	   (let ((result (apply predicate (mapcar #'seq-ref sequences iters))))
	     (when result (return-from some result)))
	   (mapc #'seq-next iters)
	   (go start)))))
  (defun notevery (predicate &rest sequences)
    (let ((iters (mapcar #'seq-start sequences)))
      (tagbody
       start
	 (unless (some-list-2 #'seq-end-p sequences iters)
	   (unless (apply predicate (mapcar #'seq-ref sequences iters))
	     (return-from every t))
	   (mapc #'seq-next iters)
	   (go start)))))
  (defun notany (predicate &rest sequences)
    (let ((iters (mapcar #'seq-start sequences)))
      (tagbody
       start
	 (unless (some-list-2 #'seq-end-p sequences iters)
	   (when (apply predicate (mapcar #'seq-ref sequences iters))
	     (return-from every nil))
	   (mapc #'seq-next iters)
	   (go start))))
    t)
  (defun map-into (result-sequence function &rest sequences)
    (let ((result-iter (seq-start result-sequence))
	  (iters (mapcar #'seq-start sequences)))
      (tagbody
       start
	 (unless (some-list-2 #'seq-end-p sequences iters)
	   (seq-set result-sequence result-iter
		    (apply function (mapcar #'seq-ref sequences iters)))
	   (seq-next result-iter)
	   (mapc #'seq-next iters)
	   (go start))))
    result-sequence)
  (defun reduce (function sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (if (apply #'seq-end-p sequence iter rest)
	  (funcall function)
	  (let ((elem (seq-ref sequence iter)))
	    (seq-next iter)
	    (unless (apply #'seq-end-p sequence iter rest)
	      (tagbody
	       start
		 (setq elem (funcall function elem (seq-ref sequence iter)))
		 (seq-next iter)
		 (unless (apply #'seq-end-p sequence iter rest)
		   (go start))))
	    elem))))
  (defun count (item sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest))
	  (count 0))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies item (seq-ref sequence iter) rest)
	     (setf count (+ 1 count)))
	   (seq-next iter)
	   (go start)))
      count))
  (defun count-if (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest))
	  (count 0))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies-if predicate (seq-ref sequence iter) rest)
	     (setf count (+ 1 count)))
	   (seq-next iter)
	   (go start)))
      count))
  (defun count-if-not (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest))
	  (count 0))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies-if-not predicate (seq-ref sequence iter)
			rest)
	     (setf count (+ 1 count)))
	   (seq-next iter)
	   (go start)))
      count))
  (defun find (item sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (when (apply #'satisfies item elem rest)
	       (return-from find elem)))
	   (seq-next iter)
	   (go start)))))
  (defun find-if (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (when (apply #'satisfies-if predicate elem rest)
	       (return-from find-if elem)))
	   (seq-next iter)
	   (go start)))))
  (defun find-if-not (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (when (apply #'satisfies-if-not predicate elem rest)
	       (return-from find-if-not elem)))
	   (seq-next iter)
	   (go start)))))
  (defun position (item sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies item (seq-ref sequence iter) rest)
	     (return-from position (seq-position iter)))
	   (seq-next iter)
	   (go start)))))
  (defun position-if (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies-if predicate (seq-ref sequence iter) rest)
	     (return-from position-if (seq-position iter)))
	   (seq-next iter)
	   (go start)))))
  (defun position-if-not (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies-if-not predicate (seq-ref sequence iter)
			rest)
	     (return-from position-if-not (seq-position iter)))
	   (seq-next iter)
	   (go start)))))
  (defun remove (item sequence &rest rest &key count)
    (let ((iter (apply #'seq-start sequence rest))
	  (result nil))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (unless (and (apply #'satisfies item elem rest)
			  (or (not count) (not (minusp (decf count)))))
	       (push elem result)))
	   (seq-next iter)
	   (go start)))
      (seq-result sequence iter result)))
  (defun remove-if (predicate sequence &rest rest &key count)
    (let ((iter (apply #'seq-start sequence rest))
	  (result nil))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (unless (and (apply #'satisfies-if predicate elem rest)
			  (or (not count) (not (minusp (decf count)))))
	       (push elem result)))
	   (seq-next iter)
	   (go start)))
      (seq-result sequence iter result)))
  (defun remove-if-not (predicate sequence &rest rest &key count)
    (let ((iter (apply #'seq-start sequence rest))
	  (result nil))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (unless (and (apply #'satisfies-if-not predicate elem rest)
			  (or (not count) (not (minusp (decf count)))))
	       (push elem result)))
	   (seq-next iter)
	   (go start)))
      (seq-result sequence iter result))))
(defun array-type (array)
  (case (ldb '(2 . 0) (ival array))
    (2 (case (iref array 1)
	 (3 2)
	 (4 3)
	 (7 4)
	 (t (error "not an array"))))
    (3 (case (jref array 1)
	 (20 0)
	 (116 1)
	 (t (error "not an array"))))
    (t (error "not an array"))))
(defun initial-contents (array subscripts initial-contents)
  (if (= (length subscripts) (array-rank array))
      (apply #'(setf aref) initial-contents array subscripts)
      (let ((i 0))
	(dolist (elem initial-contents)
	  (initial-contents array (append subscripts (list i)) elem)
	  (setf i (+ 1 i))))))
(defun make-array (dimensions &key (element-type t) initial-element
		   initial-contents adjustable fill-pointer displaced-to
		   (displaced-index-offset 0))
  (setf dimensions (designator-list dimensions))
  (setf element-type (upgraded-array-element-type element-type))
  (let* ((simple-vector-p (and (= (length dimensions) 1)
			       (not adjustable)
			       (not fill-pointer)
			       (not displaced-to)))
	 (total-size (apply #'* dimensions))
	 (content (or displaced-to
		      (case element-type
			(bit (makej total-size 116))
			(character (makej (+ 1 (* 8 total-size)) 20))
			(t (makei total-size 3)))))
	 (array (if simple-vector-p
		    content
		    (makei 4 4 total-size
			   (if (= (length dimensions) 1)
			       fill-pointer
			       dimensions)
			   content
			   (when displaced-to displaced-index-offset)))))
    (unless displaced-to
      (if initial-contents
	  (initial-contents array nil initial-contents)
	  (let ((i 0))
	    (tagbody
	     start
	       (when (< i total-size)
		 (setf (aref content i) initial-element)
		 (incf i)
		 (go start))))))
    array))
(defun adjust-array (array dimensions &key element-type initial-element
		     initial-contents fill-pointer displaced-to
		     (displaced-index-offset 0))
  (setq dimensions (designator-list dimensions))
  (case (array-type array)
    ((0 1 2 4) nil)
    (3 (let ((offset (iref array 5)))
	 (if offset
	     nil
	     (if displaced-to
		 nil
		 (let* ((total-size (apply #'* dimensions))
			(content (makei total-size 3)))
		   (dotimes (i (min (iref array 2) total-size))
		     (setf (iref content (+ 2 i))
			   (iref (iref array 4) (+ 2 i))))
		   (when (> total-size (iref array 2))
		     (dotimes (i (- total-size (iref array 2)))
		       (setf (iref content (+ 2 i (iref array 2)))
			     initial-element)))
		   (setf (iref array 2) total-size)
		   (setf (iref array 3)
			 (if (= (length dimensions) 1)
			     (case fill-pointer
			       ((nil) (iref array 3))
			       ((t) total-size)
			       (t fill-pointer))
			     dimensions))
		   (setf (iref array 4) content)))))
       array)))
(defun adjustable-array-p (array)
  (case (array-type array)
    ((0 1 2) nil)
    ((3 4) t)
    (t (error "not an array"))))
(defun aref (array &rest subscripts)
  (row-major-aref array (apply #'array-row-major-index array subscripts)))
(defun (setf aref) (new-element array &rest subscripts)
  (setf (row-major-aref array (apply #'array-row-major-index array subscripts))
	new-element))
(defun array-dimension (array axis-number)
  (nth axis-number (array-dimensions array)))
(defun array-dimensions (array)
  (case (array-type array)
    (0 (list (- (/ (jref array 0) 64) 4)))
    (1 (list (- (/ (jref array 0) 8) 31)))
    (2 (list (/ (iref array 0) 8)))
    ((3 4) (let ((dims/fill (iref array 3)))
	     (if (consp dims/fill) dims/fill (list (iref array 2)))))))
(defun array-has-fill-pointer-p (array)
  (case (array-type array)
    ((3 4) (atom (iref array 3)))
    ((0 1 2) nil)
    (t (error "not an array"))))
(defun array-displacement (array)
  (case (array-type array)
    ((3 4) (let ((offset (iref array 5)))
	     (if offset
		 (values (iref array 4) offset)
		 (values nil 0))))
    ((0 1 2) (values nil 0))
    (t (error "not an array"))))
(defun array-in-bounds-p (array &rest subscripts)
  (dolist (dim (array-dimensions array) t)
    (let ((subscript (pop subscripts)))
      (unless (< subscript dim)
	(return)))))
(defun array-rank (array)
  (length (array-dimensions array)))
(defun array-row-major-index (array &rest subscripts)
  (let ((index 0)
	(last-dim 1))
    (dolist (dim (array-dimensions array))
      (let ((subscript (pop subscripts)))
	(unless (< subscript dim)
	  (error "index out of bounds"))
	(setf index (+ (* last-dim index) subscript))
	(setf last-dim dim)))
    index))
(defun array-total-size (array)
  (case (array-type array)
    ((0 1 2) (length array))
    ((3 4) (iref array 2))
    (t (error "not an array"))))
(defun arrayp (object)
  (case (ldb '(2 . 0) (ival object))
    (2 (case (iref object 1)
	 ((3 4 7) t)))
    (3 (case (jref object 1)
	 ((20 116) t)))))
(defun fill-pointer (vector)
  (case (array-type vector)
    ((3 4) (let ((dims/fill (iref vector 3)))
	     (when (consp dims/fill)
	       (error "not a vector"))
	     (unless dims/fill
	       (error "no fill pointer"))
	     dims/fill))
    (t (error "not a vector with fill pointer"))))
(defun (setf fill-pointer) (new-fill-pointer vector)
  (case (array-type vector)
    ((3 4) (let ((dims/fill (iref vector 3)))
	     (when (consp dims/fill)
	       (error "not a vector"))
	     (unless dims/fill
	       (error "no fill pointer"))
	     (setf (iref vector 3) new-fill-pointer)))
    (t (error "not a vector with fill pointer"))))
(defparameter *big-endian* (= (ldb '(8 . 0) (jref "ABCD" 2)) 68))
(if *big-endian*
    (defun row-major-aref (array index)
      (case (array-type array)
	(0 (code-char (ldb (cons 8 (* 8 (- 3 (ldb '(2 . 0) index))))
			   (jref array (+ 2 (/ index 4))))))
	(1 (ldb (cons 1 (ldb '(5 . 0) index)) (jref array (+ 2 (/ index 32)))))
	(2 (iref array (+ 2 index)))
	(3 (row-major-aref (iref array 4) index))
	(4 (error "accessing nil array"))
	(t (error "not an array"))))
    (defun row-major-aref (array index)
      (case (array-type array)
	(0 (code-char (ldb (cons 8 (* 8 (ldb '(2 . 0) index)))
			   (jref array (+ 2 (/ index 4))))))
	(1 (ldb (cons 1 (ldb '(5 . 0) index)) (jref array (+ 2 (/ index 32)))))
	(2 (iref array (+ 2 index)))
	(3 (row-major-aref (iref array 4) index))
	(4 (error "accessing nil array"))
	(t (error "not an array")))))
(if *big-endian*
    (defun (setf row-major-aref) (new-element array index)
      (case (array-type array)
	(0 (multiple-value-bind (index-major index-minor)
	       (floor index 4)
	     (setf (jref array (+ 2 index-major))
		   (dpb (char-code new-element)
			(cons 8 (* 8 (- 3 index-minor)))
			(jref array (+ 2 index-major))))))
	(1 (multiple-value-bind (index-major index-minor)
	       (floor index 32)
	     (setf (jref array (+ 2 index-major))
		   (dpb new-element
			(cons 1 index-minor)
			(jref array (+ 2 index-major))))))
	(2 (setf (iref array (+ 2 index)) new-element))
	(3 (setf (row-major-aref (iref array 4) index) new-element))
	(4 (error "accessing nil array"))
	(t (error "not an array")))
      new-element)
    (defun (setf row-major-aref) (new-element array index)
      (case (array-type array)
	(0 (multiple-value-bind (index-major index-minor)
	       (floor index 4)
	     (setf (jref array (+ 2 index-major))
		   (dpb (char-code new-element)
			(cons 8 (* 8 index-minor))
			(jref array (+ 2 index-major))))))
	(1 (multiple-value-bind (index-major index-minor)
	       (floor index 32)
	     (setf (jref array (+ 2 index-major))
		   (dpb new-element
			(cons 1 index-minor)
			(jref array (+ 2 index-major))))))
	(2 (setf (iref array (+ 2 index)) new-element))
	(3 (setf (row-major-aref (iref array 4) index) new-element))
	(4 (error "accessing nil array"))
	(t (error "not an array")))
      new-element))
(defun upgraded-array-element-type (typespec &optional environment)
  (setf typespec (designator-list typespec))
  (case (car typespec)
    ((base-char character) 'character)
    ((bit) 'bit)
    ((unsigned-byte) (if (and (= (length typespec) 2)
			      (= (second typespec) 1))
			 'bit
			 't))
    ((integer) (if (and (= (length typespec) 3)
			(= (second typespec) 0)
			(= (third typespec) 1))
		   'bit
		   't))
    (t 't)))
(defun simple-vector-p (object)
  (case (ldb '(2 . 0) (ival object))
    (2 (= (iref object 1) 3))
    (3 (member (jref object 1) '(20 116)))))
(defun svref (simple-vector index)
  (aref simple-vector index))
(defun (setf svref) (new-element simple-vector index)
  (setf (aref simple-vector index) new-element))
(defun vector (&rest objects)
  (let ((vector (makei (length objects) 3))
	(i 2))
    (dolist (object objects)
      (setf (iref vector i) object)
      (setf i (+ 1 i)))
    vector))
(defun vector-pop (vector)
  (aref vector (setf (fill-pointer vector) (- (fill-pointer vector) 1))))
(defun vector-push (new-element vector)
  (let ((fill-pointer (fill-pointer vector)))
    (when (< fill-pointer (array-dimension vector 0))
      (setf (aref vector fill-pointer) new-element)
      (setf (fill-pointer vector) (+ 1 fill-pointer))
      fill-pointer)))
(defun vector-push-extend (new-element vector
			   &optional (extension (array-dimension vector 0)))
  (let ((fill-pointer (fill-pointer vector)))
    (unless (< fill-pointer (array-dimension vector 0))
      (adjust-array vector (+ fill-pointer extension)))
    (setf (aref vector fill-pointer) new-element)
    (setf (fill-pointer vector) (+ 1 fill-pointer))
    fill-pointer))
(defun vectorp (object)
  (case (ldb '(2 . 0) (ival object))
    (2 (case (iref object 1)
	 (3 t)
	 ((4 7) (atom (iref object 3)))))
    (3 (member (jref object 1) '(20 116)))))
(defun simple-bit-vector-p (object)
  (and (= (ldb '(2 . 0) (ival object)) 3) (= (jref object 1) 116)))
(defun bit-vector-p (object)
  (let ((tag (ldb '(2 . 0) (ival object))))
    (or (and (= tag 3) (= (jref object 1) 116))
	(and (= tag 2) (= (iref object 1) 4) (bit-vector-p (iref object 4))))))
(defun simple-string-p (object)
  (and (= (ldb '(2 . 0) (ival object)) 3) (= (jref object 1) 20)))
(defun char (string index)
  (aref string index))
(defun (setf char) (new-character string index)
  (setf (aref string index) new-character))
(defun schar (string index)
  (aref string index))
(defun (setf schar) (new-character string index)
  (setf (aref string index) new-character))
(defun string-upcase (string &key (start 0) end)
  (nstring-upcase (copy-seq string) :start start :end end))
(defun string-downcase (string &key (start 0) end)
  (nstring-downcase (copy-seq string) :start start :end end))
(defun string-capitalize (string &key (start 0) end)
  (nstring-capitalize (copy-seq string) :start start :end end))
(defun nstring-upcase (string &key (start 0) end)
  (setq string (designator-string string))
  (unless end (setq end (length string)))
  (tagbody
   start
     (when (< start end)
       (setf (aref string start) (char-upcase (aref string start)))
       (incf start)
       (go start)))
  string)
(defun nstring-downcase (string &key (start 0) end)
  (setq string (designator-string string))
  (unless end (setq end (length string)))
  (tagbody
   start
     (when (< start end)
       (setf (aref string start) (char-downcase (aref string start)))
       (incf start)
       (go start)))
  string)
(defun nstring-capitalize (string &key (start 0) end)
  (setq string (designator-string string))
  (unless end (setq end (length string)))
  (let ((word-start t))
    (tagbody
     start
       (when (< start end)
	 (setf (aref string start)
	       (let ((c (aref string start)))
		 (prog1
		     (if word-start
			 (char-upcase c)
			 (char-downcase c))
		   (setq word-start (not (alphanumericp c))))))
	 (incf start)
	 (go start))))
  string)
(defun string-trim (character-bag string)
  (let ((i 0)
	(j (length string)))
    (tagbody
     start
       (when (and (< i j) (position (aref string i) character-bag))
	 (incf i)
	 (go start)))
    (tagbody
     start
       (when (and (plusp j) (position (aref string (- j 1)) character-bag))
	 (decf j)
	 (go start)))
    (if (< i j)
	(subseq string i j)
	"")))
(defun string-left-trim (character-bag string)
  (let ((i 0))
    (tagbody
     start
       (when (and (< i (length string))
		  (position (aref string i) character-bag))
	 (incf i)
	 (go start)))
    (subseq string i)))
(defun string-right-trim (character-bag string)
  (let ((i (length string)))
    (tagbody
     start
       (when (and (plusp i) (position (aref string (- i 1)) character-bag))
	 (decf j)
	 (go start)))
    (subseq string 0 i)))
(flet ((string-mismatch (comparator string1 string2
				    &key (start1 0) end1 (start2 0) end2)
	 (setq string1 (designator-string string1))
	 (setq string2 (designator-string string2))
	 (unless end1 (setq end1 (length string1)))
	 (unless end2 (setq end2 (length string2)))
	 (tagbody
	  start
	    (when (and (< start1 end1) (< start2 end2))
	      (unless (funcall comparator
			       (aref string1 start1) (aref string2 start2))
		(return-from string-mismatch start1))
	      (incf start1)
	      (incf start2)
	      (go start)))
	 (if (or (< start1 end1) (< start2 end2))
	     start1
	     nil)))
  (defun string/= (&rest rest)
    (apply #'string-mismatch #'char= rest))
  (defun string-not-equal (&rest rest)
    (apply #'string-mismatch #'char-equal rest)))
(defun *string= (&rest rest)
  (not (apply #'string/= rest)))
(defun string-equal (&rest rest)
  (not (apply #'string-not-equal rest)))
(flet ((string-mismatch (exit continue default1 default2 default3
			 string1 string2 &key (start1 0) end1 (start2 0) end2)
	 (setq string1 (designator-string string1))
	 (setq string2 (designator-string string2))
	 (unless end1 (setq end1 (length string1)))
	 (unless end2 (setq end2 (length string2)))
	 (tagbody
	  start
	    (when (and (< start1 end1) (< start2 end2))
	      (let ((c1 (aref string1 start1))
		    (c2 (aref string2 start2)))
		(when (funcall exit c1 c2)
		  (return-from string-mismatch start1))
		(unless (funcall continue c1 c2)
		  (return-from string-mismatch)))
	      (incf start1)
	      (incf start2)
	      (go start)))
	 (when (cond
		 ((< start1 end1) default1)
		 ((< start2 end2) default2)
		 (t default3))
	   start1)))
  (defun string< (&rest rest)
    (apply #'string-mismatch #'char< #'char= nil t nil rest))
  (defun string<= (&rest rest)
    (apply #'string-mismatch #'char< #'char= nil t t rest))
  (defun string> (&rest rest)
    (apply #'string-mismatch #'char> #'char= t nil nil rest))
  (defun string>= (&rest rest)
    (apply #'string-mismatch #'char> #'char= t nil t rest))
  (defun string-lessp (&rest rest)
    (apply #'string-mismatch #'char-lessp #'char-equal nil t nil rest))
  (defun string-not-greaterp (&rest rest)
    (apply #'string-mismatch #'char-lessp #'char-equal nil t t rest))
  (defun string-greaterp (&rest rest)
    (apply #'string-mismatch #'char-greaterp #'char-equal t nil nil rest))
  (defun string-not-lessp (&rest rest)
    (apply #'string-not-lessp #'char-greaterp #'char-equal t nil t rest)))
(defun stringp (object)
  (case (ldb '(2 . 0) (ival object))
    (2 (and (member (iref object 1) '(4 7))
	    (atom (iref object 3))))
    (3 (= (jref object 1) 20))))
(defun make-string (size &key (initial-element (code-char 0))
		    (element-type 'character))
  (let* ((string (makej (+ 1 (* size 8)) 20))
	 (i 0)
	 (init-code (char-code initial-element))
	 (init (* 16843009 init-code)))
    (tagbody
     start
       (when (< i (/ size 4))
	 (setf (jref string (+ 2 i)) init)
	 (setf i (+ 1 i))
	 (go start)))
    (setf (jref string (+ 2 (/ size 4)))
	  (dpb init (cons (* 8 (ldb '(2 . 0) size)) 0) 0))
    string))
(defun reverse (sequence)
  (if (listp sequence)
      (let ((acc nil))
	(dolist (elem sequence)
	  (push elem acc))
	acc)
      "FIXME"))
(defun nreverse (sequence)
  (if (listp sequence)
      (let ((prev nil))
	(tagbody
	 start
	   (when sequence
	     (let ((next (cdr sequence)))
	       (setf (cdr sequence) prev)
	       (setf prev sequence)
	       (setf sequence next))
	     (go start)))
	prev)
      "FIXME"))
(defun get-properties (plist indicator-list)
  (tagbody
   start
     (when plist
       (when (member (car plist) indicator-list :test #'eq)
	 (return-from get-properties
	   (values (car plist) (cadr plist) (cddr plist))))
       (setf plist (cddr plist))
       (go start))))
(defun getf (plist indicator &optional default)
  (tagbody
   start
     (when plist
       (when (eq (car plist) indicator)
	 (return-from plist (cadr plist)))
       (setf plist (cddr plist))
       (go start)))
  default)
(defmacro define-setf-expander (access-fn lambda-list &rest forms)
  `',access-fn)
(define-setf-expander getf (place indicator &optional default &environment env)
  (multiple-value-bind (dummies vals newval setter getter)
      (get-setf-expansion place env)
    (let ((t-indicator (gensym))
	  (t-default (gensym))
	  (t-place (gensym))
	  (t-plist (gensym))
	  (store (gensym)))
      (values (list* t-indicator t-default dummies)
	      (list* indicator default vals)
	      (list store)
	      `(let ((,t-place ,getter))
		(do ((,t-plist ,t-place (cddr ,t-plist)))
		    ((not ,t-plist)
		     (let ((,(car newval) (list* ,t-indicator ,store t-place)))
		       ,setter))
		  (when (eq (car ,t-plist) ,t-indicator)
		    (setf (cadr ,t-plist) ,store)
		    (return)))
		,store)
	      `(getf ,getter ,ind ,def)))))
(defmacro remf (place indicator)
  (let ((t-plist (gensym))
	(t-indicator (gensym)))
    `(let ((,t-plist ,place)
	   (,t-indicator ,indicator))
      (if (eq (car ,t-plist) ,t-indicator)
	  (progn (setf ,place (cddr ,t-plist)) t)
	  (tagbody
	     (setf ,t-plist (cdr ,t-plist))
	   start
	     (when (cdr ,t-plist)
	       (when (eq (cadr ,t-plist) ,t-indicator)
		 (setf (cdr ,t-plist) (cddr ,t-plist))
		 (return-from nil t))
	       (setf ,t-plist (cddr ,t-plist))
	       (go start)))))))
(defun intersection (list-1 list-2 &rest rest &key key)
  (let ((result nil))
    (dolist (item list-1)
      (when (apply #'member (if key (funcall key item) item) list-2 rest)
	(push item result)))
    result))
(defun nintersection (list-1 list-2 &rest rest &key key)
  (let ((result nil))
    (tagbody
     start
       (unless list-1 (return-from nintersection result))
       (let ((item (car list-1)))
	 (if (apply #'member (if key (funcall key item) item) list-2 rest)
	     (progn
	       (setf item (cdr list-1))
	       (setf (cdr list-1) result)
	       (setf result list-1)
	       (setf list-1 item))
	     (setf list-1 (cdr list-1))))
       (go start))))
(defun set-difference (list-1 list-2 &rest rest &key key)
  (let ((result nil))
    (dolist (item list-1)
      (unless (apply #'member (if key (funcall key item) item) list-2 rest)
	(push item result)))
    result))
(defun nset-difference (list-1 list-2 &rest rest &key key)
  (let ((result nil))
    (tagbody
     start
       (unless list-1 (return-from nset-difference result))
       (let ((item (car list-1)))
	 (if (apply #'member (if key (funcall key item) item) list-2 rest)
	     (setf list-1 (cdr list-1))
	     (progn
	       (setf item (cdr list-1))
	       (setf (cdr list-1) result)
	       (setf result list-1)
	       (setf list-1 item))))
       (go start))))
(defmacro pushnew (item place &rest rest)
  `(unless (member ,item ,place ,@rest)
    (push ,item ,place)))
(defun union (list-1 list-2 &rest rest &key key)
  (let ((result list-2))
    (dolist (item list-1)
      (unless (apply #'member (if key (funcall key item) item) list-2 rest)
	(push item result)))
    result))
(defun nunion (list-1 list-2 &rest rest &key key)
  (let ((result list-2))
    (tagbody
     start
       (unless list-1 (return-from nunion result))
       (let ((item (car list-1)))
	 (if (apply #'member (if key (funcall key item) item) list-2 rest)
	     (setf list-1 (cdr list-1))
	     (progn
	       (setf item (cdr list-1))
	       (setf (cdr list-1) result)
	       (setf result list-1)
	       (setf list-1 item))))
       (go start))))
(defun array-element-type (sequence)
  (if (stringp sequence) 'character 't))
(defun copy-seq (sequence)
  (if (listp sequence)
      (copy-list sequence)
      (let ((new-sequence (make-sequence (type-of sequence)
					 (length sequence)))
	    (index 0))
	(tagbody
	 start
	   (when (< index (length sequence))
	     (setf (aref new-sequence index) (aref sequence index))
	     (setf index (+ 1 index))
	     (go start)))
	new-sequence)))
(defun elt (sequence index)
  (if (listp sequence)
      (nth index sequence)
      (aref sequence index)))
(defun (setf elt) (new-object sequence index)
  (if (listp sequence)
      (setf (nth index sequence) new-object)
      (setf (aref sequence index) new-object)))
(defun make-sequence (result-type size &key initial-element)
  (let ((type-head (car (designator-list result-type))))
    (case type-head
      ((list cons null)	(make-list size :initial-element initial-element))
      (string (make-string size :initial-element initial-element))
      (vector (make-array size :initial-element initial-element))
      (t (error 'type-error :datum result-type :expected-type 'sequence)))))
(defun subseq (sequence start &optional end)
  (if (listp sequence)
      (let ((tail (nthcdr start sequence)))
	(if end
	    (let ((result nil))
	      (tagbody
	       start
		 (when (< start end)
		   (push (pop tail) result)
		   (incf start)
		   (go start)))
	      (reverse result))
	    (copy-list tail)))
      (let ((tag (ldb '(2 . 0) (ival sequence))))
	(unless end (setq end (length sequence)))
	(let ((new-sequence (if (= tag 2)
				(if (= (iref sequence 1) 3)
				    (makei (- end start) 3)
				    (return-from subseq
				      (let ((offset (iref sequence 5)))
					(if offset
					    (subseq (iref sequence 4)
						     (+ start offset)
						     (min (length sequence)
							  (+ end offset)))
					    (subseq (iref sequence 4)
						     start end)))))
				(if (= (jref sequence 1) 20)
				    (makej (+ 1 (* 8 (- end start))) 20)
				    (makej (- end start) 116))))
	      (index 0))
	  (tagbody
	   start
	     (when (< start end)
	       (setf (aref new-sequence index) (aref sequence start))
	       (incf index)
	       (incf start)
	       (go start)))
	  new-sequence))))
(defun (setf subseq) (new-subsequence sequence start &optional end)
  (let ((result new-subsequence))
    (if (listp sequence)
	(let ((tail (nthcdr start sequence)))
	  (tagbody
	   start
	     (when (and tail (or (not end) (< start end)))
	       (setf (car tail) (pop new-subsequence))
	       (incf start)
	       (go start))))
	(let ((index 0))
	  (unless end (setq end (length sequence)))
	  (tagbody
	   start
	     (when (< start end)
	       (setf (aref sequence start) (aref new-subsequence index))
	       (incf index)
	       (incf start)
	       (go start)))))
    result))
(defun conc-string (&rest seq)
  (setq seq (mapcar #'designator-string seq))
  (let ((length 0))
    (mapc #'(lambda (string) (setq length (+ length (length string)))) seq)
    (let ((result-string (make-string length)))
      (setq length 0)
      (mapc #'(lambda (string)
		(let ((new-length (+ length (length string))))
		  (setf (subseq result-string length new-length) string)
		  (setq length new-length)))
	    seq)
      result-string)))
(defun designator-list (designator)
  (if (listp designator) designator (list designator)))
(defparameter *standard-class* (makei 1 0))
(setf (iref *standard-class* 1) *standard-class*)
(defparameter *structure-class* (makei 1 *standard-class*))
(defparameter *hash-table* (makei 1 *structure-class*))
(defun hash-eql (object)
  (if (and (= (ldb '(2 . 0) (ival object)) 3) (= (jref object 1) 84))
      (floor (abs object))
      (ival object)))
(defun sxhash (object &optional (level 4))
  (if (zerop level)
      0
      (let ((lvl (- level 1)))
	(case (ldb '(2 . 0) (ival object))
	  (0 (ival object))
	  (1 (+ (sxhash (car object) lvl) (sxhash (cdr object) lvl)))
	  (2 (case (iref object 1)
	       (t (ival object))))
	  (3 (case (jref object 1)
	       (20 (hash object))
	       (84 (floor (abs object)))
	       (t (ival object))))))))
(defun make-hash-table (&key (test 'eql) (size 61) (rehash-size 1.999)
			(rehash-threshold 1))
  (when (functionp test)
    (setq test (iref test 6)))
  (makei 6 *hash-table* 0 rehash-size rehash-threshold test
	 (case test
	   (eq #'ival)
	   (eql #'hash-eql)
	   (equal #'sxhash)
	   (equalp #'hash-equalp)
	   (t (error "Unknown test function ~A." test)))
	 (makei size 3)))
(defun gethash (key hash-table &optional default)
  (let* ((table (hash-table-table hash-table))
	 (test (hash-table-test hash-table))
	 (index (mod (funcall (hash-table-hash hash-table) key)
		     (length table))))
    (dolist (cons (iref table (+ 2 index)) (values default nil))
      (when (funcall test (car cons) key)
	(return (values (cdr cons) t))))))
(defun (setf gethash) (new-value key hash-table &optional default)
  (let* ((table (hash-table-table hash-table))
	 (test (hash-table-test hash-table))
	 (index (mod (funcall (hash-table-hash hash-table) key)
		     (length table))))
    (dolist (cons (iref table (+ 2 index))
	     (progn
	       (push (cons key new-value) (iref table (+ 2 index)))
	       (unless (< (incf (hash-table-count hash-table))
			  (* (hash-table-rehash-threshold hash-table)
			     (length table)))
		 (setf (hash-table-table hash-table)
		       (makei (floor (* (hash-table-rehash-size hash-table)
					(length table)))
			      3))
		 (setf (hash-table-count hash-table) 0)
		 (dotimes (index (length table))
		   (dolist (cons (iref table (+ 2 index)))
		     (setf (gethash (car cons) hash-table) (cdr cons)))))))
      (when (funcall test (car cons) key)
	(setf (cdr cons) new-value)
	(return (values (cdr cons) t)))))
  new-value)
(defun remhash (key hash-table)
  (let* ((table (hash-table-table hash-table))
	 (test (hash-table-test hash-table))
	 (index (mod (funcall (hash-table-hash hash-table) key)
		     (length table)))
	 (cons (iref table (+ 2 index)))
	 (prev-cons nil))
    (tagbody
     start
       (unless cons (return-from remhash))
       (unless (funcall test (caar cons) key)
	 (setq prev-cons cons)
	 (setq cons (cdr cons))
	 (go start)))
    (if prev-cons
	(setf (cdr prev-cons) (cdr cons))
	(setf (iref table (+ 2 index)) (cdr cons)))
    (decf (hash-table-count hash-table))
    t))
(defun maphash (function hash-table)
  (let ((table (hash-table-table hash-table)))
    (dotimes (index (length table))
      (dolist (cons (iref table (+ 2 index)))
	(funcall function (car cons) (cdr cons))))))
(defun hash-table-iterator (hash-table)
  (let ((table (hash-table-table hash-table))
	(index 0)
	(cons nil))
    #'(lambda ()
	(block nil
	  (tagbody
	   start
	     (unless cons
	       (unless (< index (length table))
		 (return))
	       (setq cons (iref table (+ 2 index)))
	       (incf index)
	       (go start)))
	  (let ((pair (pop cons)))
	    (values t (car pair) (cdr pair)))))))
(defmacro with-hash-table-iterator ((name hash-table) &rest forms)
  (let ((iterator (gensym)))
    `(let ((,iterator (hash-table-iterator ,hash-table)))
      (macrolet ((,name ()
		   `(funcall ,,iterator)))
	,@forms))))
(defun clrhash (hash-table)
  (let ((table (hash-table-table hash-table)))
    (dotimes (index (length table))
      (setf (iref table (+ 2 index)) nil)))
  (setf (hash-table-count hash-table) 0)
  hash-table)
(defun hash-table-count (hash-table) (iref hash-table 2))
(defun (setf hash-table-count) (new-value hash-table)
  (setf (iref hash-table 2) new-value))
(defun hash-table-rehash-size (hash-table) (iref hash-table 3))
(defun hash-table-rehash-threshold (hash-table) (iref hash-table 4))
(defun hash-table-test (hash-table) (iref hash-table 5))
(defun hash-table-hash (hash-table) (iref hash-table 6))
(defun hash-table-table (hash-table) (iref hash-table 7))
(defun (setf hash-table-table) (new-value hash-table)
  (setf (iref hash-table 7) new-value))
(defparameter *class-hash* (make-hash-table))
(defun find-class (symbol &optional (errorp t) environment)
  (multiple-value-bind (class foundp)
      (gethash symbol *class-hash*)
    (when (and errorp (not foundp))
      (error "Class ~A not found." symbol))
    class))
