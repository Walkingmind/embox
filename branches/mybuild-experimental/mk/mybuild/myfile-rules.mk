# Generated by GOLD Parser Builder using Mybuild program template.

# Rule productions for 'MyFile' grammar.

include mk/mybuild/common-rules.mk

printf_escape = $(eval __TMP := $(subst $(\t),\t,$(subst $(\n),\n,$(subst \,\\,$1))))$(__TMP)

# Rule: <MyFile> ::= <Package> <Imports> <Entities>
# Args: 1..3 - Symbols in the RHS.
define $(gold_grammar)_produce-MyFile
	#$(error $1$3)
	$(shell printf $(call printf_escape,"$1$3") > $(gold_file).notready)
endef

# Rule: <Package> ::= package <QualifiedName>
# Args: 1..2 - Symbols in the RHS.
$(gold_grammar)_produce-Package_package  = $(\n)package('$2')$(\n)

# Rule: <Package> ::= 
# Args: 1..0 - Symbols in the RHS.
define $(gold_grammar)_produce-Package
	$(call gold_report_warning,
			Using default package)
endef

# Rule: <Import> ::= import <QualifiedNameWithWildcard>
# Args: 1..2 - Symbols in the RHS.
$(gold_grammar)_produce-Import_import = $2

# Rule: <AnnotatedType> ::= <Annotations> <Type>
# Args: 1..2 - Symbols in the RHS.
define $(gold_grammar)_produce-AnnotatedType
	$(if $1,raise Exception('AnnotatedType not supported, do it manually')$(\n))
	$2
endef

# Rule: <AnnotationType> ::= annotation Identifier '{' <AnnotationMembers> '}'
# Args: 1..5 - Symbols in the RHS.
define $(gold_grammar)_produce-AnnotationType_annotation_Identifier_LBrace_RBrace
	$(foreach type,$(new MyAnnotationType),
		$(set type->name,$2)
		$(set type->origin,$(call gold_location_of,2))

		$(set type->options,$4)

		$(type)
	)
endef

# Rule: <AnnotatedAnnotationMember> ::= <Annotations> <Option>
# Args: 1..2 - Symbols in the RHS.
define $(gold_grammar)_produce-AnnotatedAnnotationMember
	$(for target <- $2,
		$(set+ target->annotations,$1)
		$(target))
endef

# Rule: <Interface> ::= interface Identifier <SuperInterfaces> '{' <Features> '}'
# Args: 1..6 - Symbols in the RHS.
define $(gold_grammar)_produce-Interface_interface_Identifier_LBrace_RBrace
	$(for interface <- $(new MyInterface),
		$(set interface->name,$2)
		$(set interface->features,$5)
		$(interface))
endef

# Rule: <SuperInterfaces> ::= extends <ReferenceList>
# Args: 1..2 - Symbols in the RHS.
define $(gold_grammar)_produce-SuperInterfaces_extends
	$(gold_default_produce)# TODO Auto-generated stub!
endef

# Rule: <Features> ::= <AnnotatedFeature> <Features>
# Args: 1..2 - Symbols in the RHS.
define $(gold_grammar)_produce-Features
	$(gold_default_produce)# TODO Auto-generated stub!
endef

# Rule: <AnnotatedFeature> ::= <Annotations> <Feature>
# Args: 1..2 - Symbols in the RHS.
define $(gold_grammar)_produce-AnnotatedFeature
	$(gold_default_produce)# TODO Auto-generated stub!
endef

# Rule: <Feature> ::= feature Identifier <SuperFeatures>
# Args: 1..3 - Symbols in the RHS.
define $(gold_grammar)_produce-Feature_feature_Identifier
	$(for feature <- $(new MyFeature),
		$(set feature->name,$2)
		$(set feature->superFeatures_links,$3)
		$(feature))	
endef

# Rule: <SuperFeatures> ::= extends <ReferenceList>
# Args: 1..2 - Symbols in the RHS.
$(gold_grammar)_produce-SuperFeatures_extends = $2


filter_n_subst = $(addprefix $(\t)$(\t),$(addsuffix $(\comma)$(\n),$(patsubst $1/%,%,$(filter $1/%,$2))))

notempty_str = $(if $(strip $2),$1$2$3)

# Rule: <ModuleType> ::= <ModuleModifiers> module Identifier <SuperModule> '{' <ModuleMembers> '}'
# Args: 1..7 - Symbols in the RHS.
define $(gold_grammar)_produce-ModuleType_module_Identifier_LBrace_RBrace
	$(\n)
	$(if $(filter abstract,$1),
	interface$['$3'$(\comma)$]$(\n)$(\n),
	module$[$(\n)
		$(\t)'$3'$(\comma)$(\n)$(\n) \
		$(if $(strip $4),$(\t)implements = [$4]$(\comma)$(\n)$(\n))
		$(if $(filter static,$1),$(\t)static = True$(\comma)$(\n)$(\n)) \
		$(call notempty_str,$(\t)options = [$(\n),$(call filter_n_subst,optionsMembers,$6),$(\t)]$(\comma)$(\n)$(\n)) \
		$(call notempty_str,$(\t)sources = [$(\n),$(call filter_n_subst,sourcesMembers,$6),$(\t)]$(\comma)$(\n)$(\n)) \
		$(call notempty_str,$(\t)depends = [$(\n),$(call filter_n_subst,dependsMembers,$6),$(\t)]$(\comma)$(\n)$(\n))$]
	)
endef

# Rule: <ModuleModifiers> ::= <ModuleModifier> <ModuleModifiers>
# Args: 1..2 - Symbols in the RHS.
define $(gold_grammar)_produce-ModuleModifiers
	$(if $(filter $1,$2),
		$(call gold_report_error,
				Duplicate module modifier '$1'),
		$1 \
	)
	$2
endef

# Rule: <SuperModule> ::= extends <Reference>
# Args: 1..2 - Symbols in the RHS.
$(gold_grammar)_produce-SuperModule_extends = '$2'

define rec_a 
	$(if $(strip $1),
		$(firstword $1)$(call rec_a,$(nofirstword $1),$2)$],
		$2)
endef

# Rule: <AnnotatedModuleMember> ::= <Annotations> <ModuleMember>
# Args: 1..2 - Symbols in the RHS.
define $(gold_grammar)_produce-AnnotatedModuleMember
	$(addprefix $(sort $(dir $2)),$(call rec_a,$1,$(notdir $2)))
endef

# Rule: <ModuleMember> ::= depends <ReferenceList>
$(gold_grammar)_produce-ModuleMember_depends = \
	$(addprefix dependsMembers/',$(addsuffix ',$2))

# Rule: <ModuleMember> ::= provides <ReferenceList>
$(gold_grammar)_produce-ModuleMember_provides = \
	$(addprefix providesMembers/,$2)

# Rule: <ModuleMember> ::= requires <ReferenceList>
$(gold_grammar)_produce-ModuleMember_requires = \
	$(addprefix requiresMembers/,$2)

# Rule: <ModuleMember> ::= source <FilenameList>
$(gold_grammar)_produce-ModuleMember_source = \
	$(addprefix sourcesMembers/,$2)

# Rule: <ModuleMember> ::= object <FilenameList>
$(gold_grammar)_produce-ModuleMember_object = \
	$(addprefix objectsMembers/,$2)

# Rule: <ModuleMember> ::= option <Option>
# Args: 1..2 - Symbols in the RHS.
$(gold_grammar)_produce-ModuleMember_option = \
	$(addprefix optionsMembers/,$2)

# Rule: <Option> ::= <OptionType> Identifier <OptionDefaultValue>
define $(gold_grammar)_produce-Option_Identifier
	$1$['$2'$(if $(strip $3), $(\comma)$3)$]
endef

# Rule: <OptionType> ::= string
$(gold_grammar)_produce-OptionType_string  = String
# Rule: <OptionType> ::= number
$(gold_grammar)_produce-OptionType_number  = Integer
# Rule: <OptionType> ::= boolean
$(gold_grammar)_produce-OptionType_boolean = Boolean
# Rule: <OptionType> ::= <Reference>
$(gold_grammar)_produce-OptionType         = '$1'

# Rule: <OptionDefaultValue> ::= '=' <Value>
$(gold_grammar)_produce-OptionDefaultValue_Eq = default=$2

# Rule: <Filename> ::= StringLiteral
# Args: 1..1 - Symbols in the RHS.
define $(gold_grammar)_produce-Filename_StringLiteral
	'$1'
endef

# Rule: <ReferenceList> ::= <Reference> ',' <ReferenceList>
# Args: 1..3 - Symbols in the RHS.
$(gold_grammar)_produce-ReferenceList_Comma = $1, $3

# Rule: <FilenameList> ::= <Filename> ',' <FilenameList>
# Args: 1..3 - Symbols in the RHS.
$(gold_grammar)_produce-FilenameList_Comma = $1 $3


