Only in ../build/qt/source/: .extracted
Only in ../build/qt/source/mkspecs/features: embox_auto_import_plugins.prf
Only in ../build/qt/source/mkspecs/qws: embox-generic-g++
diff -aur qt-everywhere-opensource-src-4.8.5/src/3rdparty/libpng/pngrtran.c ../build/qt/source/src/3rdparty/libpng/pngrtran.c
--- qt-everywhere-opensource-src-4.8.5/src/3rdparty/libpng/pngrtran.c	2013-06-07 09:16:58.000000000 +0400
+++ ../build/qt/source/src/3rdparty/libpng/pngrtran.c	2013-11-13 19:08:39.036006954 +0400
@@ -1241,6 +1241,7 @@
 #endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */
 }
 
+#include <string.h>
 void /* PRIVATE */
 png_init_read_transformations(png_structp png_ptr)
 {
@@ -1498,7 +1499,8 @@
 #ifdef PNG_READ_GAMMA_SUPPORTED
 #  ifdef PNG_READ_BACKGROUND_SUPPORTED
       /* Includes ALPHA_MODE */
-      png_ptr->background_1 = png_ptr->background;
+   memcpy(&png_ptr->background_1, &png_ptr->background,
+          sizeof png_ptr->background_1);
 #  endif
 
    /* This needs to change - in the palette image case a whole set of tables are
Only in ../build/qt/source/src/3rdparty/libpng: .pngrtran.c.swp
diff -aur qt-everywhere-opensource-src-4.8.5/src/corelib/global/qglobal.cpp ../build/qt/source/src/corelib/global/qglobal.cpp
--- qt-everywhere-opensource-src-4.8.5/src/corelib/global/qglobal.cpp	2013-06-07 09:16:52.000000000 +0400
+++ ../build/qt/source/src/corelib/global/qglobal.cpp	2013-11-13 18:48:31.982256530 +0400
@@ -59,7 +59,7 @@
 #include <string.h>
 
 #ifndef QT_NO_EXCEPTIONS
-#  include <string>
+//#  include <string>
 #  include <exception>
 #endif
 
diff -aur qt-everywhere-opensource-src-4.8.5/src/corelib/global/qglobal.h ../build/qt/source/src/corelib/global/qglobal.h
--- qt-everywhere-opensource-src-4.8.5/src/corelib/global/qglobal.h	2013-06-07 09:16:52.000000000 +0400
+++ ../build/qt/source/src/corelib/global/qglobal.h	2013-11-13 18:48:32.102259596 +0400
@@ -261,6 +261,8 @@
 #  define Q_OS_INTEGRITY
 #elif defined(VXWORKS) /* there is no "real" VxWorks define - this has to be set in the mkspec! */
 #  define Q_OS_VXWORKS
+#elif defined(__EMBOX__)
+#  define Q_OS_EMBOX
 #elif defined(__MAKEDEPEND__)
 #else
 #  error "Qt has not been ported to this OS - talk to qt-bugs@trolltech.com"
diff -aur qt-everywhere-opensource-src-4.8.5/src/corelib/io/qresource.cpp ../build/qt/source/src/corelib/io/qresource.cpp
--- qt-everywhere-opensource-src-4.8.5/src/corelib/io/qresource.cpp	2013-06-07 09:16:52.000000000 +0400
+++ ../build/qt/source/src/corelib/io/qresource.cpp	2013-11-13 18:48:32.738275841 +0400
@@ -929,8 +929,10 @@
 };
 
 #if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN) && !defined (Q_OS_NACL) && !defined(Q_OS_INTEGRITY)
+#if !defined(Q_OS_EMBOX)
 #define QT_USE_MMAP
 #endif
+#endif
 
 // most of the headers below are already included in qplatformdefs.h
 // also this lacks Large File support but that's probably irrelevant
diff -aur qt-everywhere-opensource-src-4.8.5/src/corelib/kernel/qtranslator.cpp ../build/qt/source/src/corelib/kernel/qtranslator.cpp
--- qt-everywhere-opensource-src-4.8.5/src/corelib/kernel/qtranslator.cpp	2013-06-07 09:16:52.000000000 +0400
+++ ../build/qt/source/src/corelib/kernel/qtranslator.cpp	2013-11-13 18:48:35.970358386 +0400
@@ -61,9 +61,11 @@
 #include "qresource.h"
 
 #if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN) && !defined(Q_OS_INTEGRITY)
+#if !defined(Q_OS_EMBOX)
 #define QT_USE_MMAP
 #include "private/qcore_unix_p.h"
 #endif
+#endif
 
 #ifdef Q_OS_SYMBIAN
 #include "private/qcore_symbian_p.h"
diff -aur qt-everywhere-opensource-src-4.8.5/src/corelib/tools/qiterator.h ../build/qt/source/src/corelib/tools/qiterator.h
--- qt-everywhere-opensource-src-4.8.5/src/corelib/tools/qiterator.h	2013-06-07 09:16:52.000000000 +0400
+++ ../build/qt/source/src/corelib/tools/qiterator.h	2013-11-13 18:48:37.790404864 +0400
@@ -47,7 +47,7 @@
 QT_BEGIN_HEADER
 
 #ifdef QT_NO_STL
-# include <ciso646> // No-op, indirectly include additional configuration headers.
+//# include <ciso646> // No-op, indirectly include additional configuration headers.
 # if defined(_LIBCPP_VERSION)
 // libc++ may declare these structs in an inline namespace. Forward-declare
 // these iterators in the same namespace so that we do not shadow the original
diff -aur qt-everywhere-opensource-src-4.8.5/src/gui/image/qmnghandler.cpp ../build/qt/source/src/gui/image/qmnghandler.cpp
--- qt-everywhere-opensource-src-4.8.5/src/gui/image/qmnghandler.cpp	2013-06-07 09:16:59.000000000 +0400
+++ ../build/qt/source/src/gui/image/qmnghandler.cpp	2013-11-13 18:48:37.790404864 +0400
@@ -98,7 +98,7 @@
         (iChunkname>>8)&0xff,
         (iChunkname>>0)&0xff,
         iExtra1,iExtra2);
-    return TRUE;
+    return MNG_TRUE;
 }
 
 static mng_ptr myalloc(mng_size_t iSize)
diff -aur qt-everywhere-opensource-src-4.8.5/src/gui/painting/qcolor.cpp ../build/qt/source/src/gui/painting/qcolor.cpp
--- qt-everywhere-opensource-src-4.8.5/src/gui/painting/qcolor.cpp	2013-06-07 09:16:59.000000000 +0400
+++ ../build/qt/source/src/gui/painting/qcolor.cpp	2013-11-13 18:48:40.974486143 +0400
@@ -2359,10 +2359,11 @@
 /*!
     Assigns a copy of \a color to this color, and returns a reference to it.
 */
+#include <cstring>
 QColor &QColor::operator=(const QColor &color)
 {
     cspec = color.cspec;
-    ct.argb = color.ct.argb;
+    std::memcpy(&ct.argb, &color.ct.argb, sizeof ct.argb);
     return *this;
 }
 
Only in ../build/qt/source/src/gui/painting: .qcolor.cpp.swp
diff -aur qt-everywhere-opensource-src-4.8.5/src/gui/painting/qcolor.h ../build/qt/source/src/gui/painting/qcolor.h
--- qt-everywhere-opensource-src-4.8.5/src/gui/painting/qcolor.h	2013-06-07 09:16:59.000000000 +0400
+++ ../build/qt/source/src/gui/painting/qcolor.h	2013-11-13 18:48:41.142490457 +0400
@@ -288,9 +288,10 @@
 inline QColor::QColor(const QString& aname)
 { setNamedColor(aname); }
 
+#include <cstring>
 inline QColor::QColor(const QColor &acolor)
     : cspec(acolor.cspec)
-{ ct.argb = acolor.ct.argb; }
+{ std::memcpy(&ct.argb, &acolor.ct.argb, sizeof ct.argb); }
 
 inline bool QColor::isValid() const
 { return cspec != Invalid; }
diff -aur qt-everywhere-opensource-src-4.8.5/src/gui/styles/qplastiquestyle.cpp ../build/qt/source/src/gui/styles/qplastiquestyle.cpp
--- qt-everywhere-opensource-src-4.8.5/src/gui/styles/qplastiquestyle.cpp	2013-06-07 09:16:59.000000000 +0400
+++ ../build/qt/source/src/gui/styles/qplastiquestyle.cpp	2013-11-13 18:48:41.142490457 +0400
@@ -1513,17 +1513,21 @@
             handle.setColor(3, option->palette.light().color().rgba());
 
             if (option->state & State_Horizontal) {
-                int nchunks = cacheRect.height() / handle.height();
-                int indent = (cacheRect.height() - (nchunks * handle.height())) / 2;
-                for (int i = 0; i < nchunks; ++i)
-                    cachePainter.drawImage(QPoint(cacheRect.left() + 3, cacheRect.top() + indent + i * handle.height()),
-                                           handle);
+                if (0 < handle.height()) {
+            	    int nchunks = cacheRect.height() / handle.height();
+                    int indent = (cacheRect.height() - (nchunks * handle.height())) / 2;
+                    for (int i = 0; i < nchunks; ++i)
+                        cachePainter.drawImage(QPoint(cacheRect.left() + 3, cacheRect.top() + indent + i * handle.height()),
+                                               handle);
+                }
             } else {
-                int nchunks = cacheRect.width() / handle.width();
-                int indent = (cacheRect.width() - (nchunks * handle.width())) / 2;
-                for (int i = 0; i < nchunks; ++i)
-                    cachePainter.drawImage(QPoint(cacheRect.left() + indent + i * handle.width(), cacheRect.top() + 3),
-                                           handle);
+                if (0 < handle.width()) {
+            	    int nchunks = cacheRect.width() / handle.width();
+                    int indent = (cacheRect.width() - (nchunks * handle.width())) / 2;
+                    for (int i = 0; i < nchunks; ++i)
+                        cachePainter.drawImage(QPoint(cacheRect.left() + indent + i * handle.width(), cacheRect.top() + 3),
+                                               handle);
+                }
             }
             cachePainter.end();
             QPixmapCache::insert(pixmapName, cache);
diff -aur qt-everywhere-opensource-src-4.8.5/src/plugins/imageformats/ico/qicohandler.cpp ../build/qt/source/src/plugins/imageformats/ico/qicohandler.cpp
--- qt-everywhere-opensource-src-4.8.5/src/plugins/imageformats/ico/qicohandler.cpp	2013-06-07 09:17:00.000000000 +0400
+++ ../build/qt/source/src/plugins/imageformats/ico/qicohandler.cpp	2013-11-13 18:48:41.142490457 +0400
@@ -364,11 +364,11 @@
     if (iod) {
         if (iod->seek(startpos + imageOffset)) {
             if (readBMPInfoHeader(iod, header)) {
-                return TRUE;
+                return true;
             }
         }
     }
-    return FALSE;
+    return false;
 }
 
 void ICOReader::findColorInfo(QImage & image)
Only in ../build/qt/source/src/plugins/platforms: emboxvc
diff -aur qt-everywhere-opensource-src-4.8.5/src/plugins/platforms/platforms.pro ../build/qt/source/src/plugins/platforms/platforms.pro
--- qt-everywhere-opensource-src-4.8.5/src/plugins/platforms/platforms.pro	2013-06-07 09:17:00.000000000 +0400
+++ ../build/qt/source/src/plugins/platforms/platforms.pro	2013-11-13 18:48:41.142490457 +0400
@@ -3,7 +3,9 @@
 SUBDIRS += minimal
 
 contains(QT_CONFIG, wayland) {
-    SUBDIRS += wayland
+	!contains(DEFINES, QT_OVERRIDE_NO_WAYLAND) {
+	    SUBDIRS += wayland
+	}
 }
 
 qnx {
