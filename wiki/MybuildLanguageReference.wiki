#summary Reference guide for language used in my- and config-files

= Синтаксис языка Myfile =

*Myfile* служит для описания модулей, их содержимого, требуемых зависимостей и т.д. Любой файл в дереве исходников с именем `Mybuild` или расширением `*.my` трактуется системой как Myfile.

==Именование==

Имена используются для обращения к различным сущностям, объявленным в my-файлах: пакетам, типам (модулям и аннотациям) и их опциям.
Имена бывают простые, состоящие из одиночного идентификатора, и полные, которые складываются из нескольких идентификаторов, разделенных точкой.

{{{
QualifiedName:
	Identifier ('.' Identifier)*

QualifiedNameWithWildcard:
	QualifiedName '.*'?
}}}

==Единица трасляции Myfile==

Стартовым символом грамматики Myfile является символ `TranslationUnit`, определяемый следующим образом:
{{{
TranslationUnit:
	Package? Import* AnnotatedType*
}}}

===Пакеты===

Пакеты используются для организации проекта и служат пространствами имен для описываемых типов. Пакеты всегда имеют полное (составное) имя, тем самым, образуя иерархию.
{{{
Package:
	'package' QualifiedName
}}}

Типы, описанные в каком-либо пакете, доступны из того же пакета по своему простому имени, а также из любого другого пакета по полному имени. Для упрощения обращения к типам, определенным в другом пакете, также может использоваться механизм импорта.

===Импорты===

Использование импорта позволяет обращаться к типам, определенным в другом пакете, по простому имени. Таким образом, импорт добавляет простые имена перечисленных типов к области видимости файла.
{{{
Import:
	'import' QualifiedNameWithWildcard
}}}

Существует два типа импортов:
 * Импорт одиночного типа (явное импортирование)
 * Импорт всех типов определенного пакета (импорт по запросу)

При обращении к типу по простому имени, импортируемому как явно, так и по запросу, приоритет имеет явный импорт. В случае явного импортирования двух типов с одинаковым простым именем, а также при обращении к типу, импортируемому по запросу из разных пакетов, возникает ошибка компиляции.

===Типы===
{{{
AnnotatedType:
	Annotation* Type
Type:
	ModuleType
	AnnotationType
}}}

==Модули==
{{{
module FooImpl extends IFoo {
	option string myString = "This is a string"
	source "source1.c", "source2.c", "header.h"
	depends neighbourModule, full.name.to.another.module
}
}}}
Описание модуля должно содержать имя модуля и тело описания модуля. Модуль может расширять некоторый другой модуль, при этом все поля описания модуля наследуются. Модуль может иметь различные модификаторы:
 * abstract. Помечает модуль как требующий реализации, в сборке должен присутствовать ровно 1 модуль, расширяющий абстрактный.

В теле описания содержится информация о содержимом модуля.
 * Опции. Являются именованными значениями, которые можно переопределять во время конфигурирования системы. Опционально может быть указано значение по умолчанию, которое используется, если другое значение не было присвоено. После компиляции, к значениям опций можно обратиться в run-time. По умолчанию, исходным кодам доступны только опции собственного модуля, но так же существует механизм доступа к опциям других модулей. 
 * Файлы. При включении данного модуля в сборку, файлы с расширением `.с` будут скомпилированы и включены в финальный образ, файлы с расширением `.h` -- экспортированы и смогут использоваться другими модулями во время сборки.
 * Предоставляемые свойства. После включении модуля в сборку, в ней становятся выполнены свойства перечисленные в этом поле.
 * Требуемые свойства. При невыполнении свойств из этого поля всех модулей сборки должна генерироваться ошибка.
 * Зависимости. Модули, без которых работа данного не возможна, во время компиляции модуля его зависимости будут автоматически включены в сборку.

==Аннотации==

Для модификации семантики некоторых элементов описания могут использоваться аннотации.
{{{
AnnotationType:
	'annotation' Identifier '{' AnnotationMember* '}'

AnnotationMember:
	Option
}}}
Пример:
{{{
annotation MyAnnotation {
	string param1
	boolean param2 = true
}
annotation MyAnnotation2 {
	string value 
}
}}}
Аннотация может иметь несколько аргументов различных типов.

=Синтаксис языка Сonfigfile=

Файл mods.config используется как определение, из чего, по крайней мере, должен состоять образ системы. 

{{{
configuration myConfig { … }
}}}

Стартовым символом грамматики Configfile является символ `ConfigFile`, определяемый следующим образом:
{{{
ConfigFile:
	Package? Import* Type?
}}}

Файл должен состоять из не более чем одного раздела configuration. В разделе могут присутствовать несколько разделов `include` - объявлений модулей, подлежащих включению.

==Раздел включения==

Раздел включения описывает модуль, подлежащий включению.
{{{
Include:
	'include' ReferenceWithInitializerList

ReferenceWithInitializerList:
	QualifiedName ('(' (Initializer (',' Initializer)*)? ')')?

Initializer:
	SimpleName = Value

configuration myConfig {
	include mod1
	include mod2(option1=value1, option1=value2)
	include mod3(option1=value3)
}
}}}

Каждое такое объявление может заканчиваться списком переопределяемых опций и их значений.

=Аннотации в Myfile и Configfile=

Аннотация может применяться к модулю, элементу тела модуля, объявлению аннотации, элементу тела аннотации, конфигурации и элементу включения модуля в конфигурацию. 
{{{
Annotation:
	'@' Reference AnnotationInitializer

AnnotationInitializer:
	'(' ParameterList ')'
	'(' Value ')'
}}}

Пример использования:
{{{
@MyAnnotation2(someValue)
@MyAnnotation2(value = someValue1)
@MyAnnotation(param2=someValue2,param3=someValue3)
module MyModule { … }
}}}

К указанным целям может применяться несколько аннотаций сразу. Если аннотация имеет ровно один параметр с именем value, то имя параметра можно опустить из списка инициализируемых переменных.

=Библиотека типов=

==`mybuild.lang.DefaultImpl`==
{{{
annotation DefaultImpl {
	Module value
}
}}}
Аннотация `DefaultImpl` может ставиться над абстрактным модулем и указывать реализацию по умолчанию, которая будет использоваться, если никакая другая реализация не включена в сборку.

@DefaultImpl(someImpl)
abstract module abstractModule { … }

==`mybuild.lang.IncludePath`==
{{{
annotation IncludePath {
	string value 
}
}}}
Аннотация `IncludePath` может указываться над секцией с исходными кодом в теле описания модуля. При компиляции файлов `*.с` из такой секции компилятору будет указан дополнительный путь для поиска заголовочных файлов.
{{{
module moduleName {
	@IncludePath("src/some/path/include")
	source "source.c"
}
}}}

==`mybuild.lang.TestFor `==
{{{
annotation TestFor { 
	Module value
}
}}}

Аннотация применяется к описанию модуля и обозначает аннотируемый модуль как тест к модулю, указанному в `value`. Применение модифицирует порядок загрузки, заставляя загружаться тест сразу после тестируемого модуля.

==`mybuild.lang.WithTest `==
{{{
annotation WithTest { 
	Module value
}
}}}

Аннотация указывается над секцией включения модуля в сборку. При применении, вместе с модулем из аннотируемой секции включается тест, указанный в `value` (этот модуль должен быть помечен `TestFor` с параметром - модулем из аннотируемой секции).

==`mybuild.lang.WithAllTests`==
{{{
annotation WithAllTests { }
}}}

Аннотация указывается над секцией включения модуля в сборку. При применении, вместе с модулем из аннотируемой секции включаются все тесты, объявление которых помечено `TestFor` с параметром - модулем из аннотируемой секции.