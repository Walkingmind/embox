#summary Обзор структур данных.

*[http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 Структура данных]* - способ организации набора данных, наиболее оптимальный для конкретной задачи.

Поскольку ни в стандартной библиотеке Си, ни в самом языке нет коллекции абстрактных типов данных, Embox содержит реализации нескольких базовых структур данных. К ним относятся [DataStructureList двусвязные] и [DataStructureSlist односвязные] списки и *TODO* пока все.

= Общие принципы =
Некоторые концепции одинаково применимы ко всем структурам данных.

== Управление памятью ==
Как правило для организации связи между элементами структуры данных используются вспомогательные _объекты-связки_. По способу управления памятью для этих объектов можно различить _внешние_ и _внутренние_ связки.

=== Внешние связки ===
Этот подход наиболее распространен в библиотеках пользовательского уровня и подразумевает создание нового вспомогательного объекта каждый раз при добавлении нового элемента в структуру. Такой объект содержит указатель на соответствующий ему элемент и на другие объекты-связки:

<table width="100%"><tr><td>

<img src="http://embox.googlecode.com/svn/wiki/images/DataStructureOverview/external-link.png" align="left"/>
{{{
struct my_element;

struct link {
	struct link       *next;
	struct my_element *element;
};

struct my_element {
	int data;
};
}}}
</td></tr></table>

Поскольку структуры данных применяются в коде ядра, их реализации не могут использовать динамическую память для выделения вспомогательных объектов. Более того, использование динамического выделения сопряжено с определенными сложностями при изменением структуры данных из разных контекстов, например, с необходимостью блокировки пула объектов для возможности добавления нового объекта из обработчика прерывания. И наконец, выделение множества объектов неминуемо приводит к фрагментации памяти и усложняет обработку ошибок при нехватке памяти.

=== Внутренние связки ===
Для избежания этих проблем объекты-связки _встраиваются_ внутрь самого элемента.

<table width="100%"><tr><td>

<img src="http://embox.googlecode.com/svn/wiki/images/DataStructureOverview/internal-link.png" align="left" />
{{{
struct link {
	struct link *next;
};

struct my_element {
	int          data;
	struct link  my_link;
};
}}}
</td></tr></table>

Таким образом, при операциях над структурой данных используется связка, являющаяся частью элемента, и управление памятью целиком возлагается на код, отвечающий за выделение и освобождение самого элемента.

<img src="http://embox.googlecode.com/svn/wiki/images/DataStructureOverview/offset.png" align="right" />
Поскольку теперь связка располагается внутри элемента, отпадает и необходимость в хранении указателя на этот элемент. Для получения адреса элемента достаточно вычесть из адреса связки ее смещение относительно начала структуры. Для этого используется следующий макрос, определяемый в `<util/member.h>`:
{{{
#define member_cast_out(member_ptr, type, member) \
	((type *) ((char *) (member_ptr) - offsetof(type, member)))
}}}

В ядре Embox все структуры данных используют именно этот подход, поэтому далее речь пойдет только о нем.

== Типизация ==

== Именование ==
== Средства отладки ==