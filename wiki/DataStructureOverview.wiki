#summary Обзор структур данных.

*[http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 Структура данных]* - способ организации набора данных, наиболее оптимальный для конкретной задачи.

Поскольку ни в стандартной библиотеке Си, ни в самом языке нет коллекции абстрактных типов данных, Embox содержит реализации нескольких базовых структур данных. К ним относятся [DataStructureList двусвязные] и [DataStructureSlist односвязные] списки и *TODO* пока все.

Однако некоторые концепции одинаково применимы ко всем структурам данных.

= Организация в памяти =
Как правило для организации связи между элементами структуры данных используются вспомогательные _объекты-связки_. По способу управления памятью для этих объектов можно различить _внешние_ и _внутренние_ связки.

== Внешние связки ==
Этот подход наиболее распространен в библиотеках пользовательского уровня и подразумевает создание нового вспомогательного объекта каждый раз при добавлении нового элемента в структуру. Такой объект содержит указатель на соответствующий ему элемент и на другие объекты-связки:

<table width="100%"><tr><td>

<img src="http://embox.googlecode.com/svn/wiki/images/DataStructureOverview/external-link.png" align="left"/>
{{{
struct my_element;

struct link {
	struct link       *next;
	struct my_element *element;
};

struct my_element {
	int data;
};
}}}
</td></tr></table>

Поскольку структуры данных применяются в коде ядра, их реализации не могут использовать динамическую память для выделения вспомогательных объектов. Более того, использование динамического выделения сопряжено с определенными сложностями при изменением структуры данных из разных контекстов, например, с необходимостью блокировки пула объектов для возможности добавления нового объекта из обработчика прерывания. И наконец, выделение множества объектов неминуемо приводит к фрагментации памяти и усложняет обработку ошибок при нехватке памяти.

== Внутренние связки ==
Для избежания этих проблем объекты-связки _встраиваются_ внутрь самого элемента.

<table width="100%"><tr><td>

<img src="http://embox.googlecode.com/svn/wiki/images/DataStructureOverview/internal-link.png" align="left" />
{{{
struct link {
	struct link *next;
};

struct my_element {
	int          data;
	struct link  my_link;
};
}}}
</td></tr></table>

Таким образом, при операциях над структурой данных используется связка, являющаяся частью элемента, и управление памятью целиком возлагается на код, отвечающий за выделение и освобождение самого элемента.

<img src="http://embox.googlecode.com/svn/wiki/images/DataStructureOverview/offset.png" align="right" />
Поскольку теперь связка располагается внутри элемента, отпадает и необходимость в хранении указателя на этот элемент. Для получения адреса элемента (приведения связки к содержащему ее объекту) достаточно вычесть из адреса связки ее смещение относительно начала структуры. Хотя большинство структур данных определяют собственные методы для приведения типов, все они основываются на использовании следующего макроса, определенного в `<util/member.h>`:
{{{
#define member_cast_out(member_ptr, type, member) \
	((type *) ((char *) (member_ptr) - offsetof(type, member)))
}}}

В ядре Embox все структуры данных используют именно подход внутренних связок, поэтому далее речь пойдет только о нем.

= Типизация и именование =
Реализации структур не зависят от типа хранимых данных - все они оперируют абстрактными объектами-связками, и приведение типов возлагается на код, использующий эти структуры данных. Тем не менее, для удобства использования большинство методов имеют несколько версий, отличающихся типом аргументов или возвращаемого значения. 

== Используя вспомогательный тип ==
Эта версия методов предполагает определение специального типа, объединяющего тип элемента структуры данных и используемую связку. Опять же, разные структуры данных определяют разные имена для таких типов, однако все они базируются на использовании макроса `member_t(object_t, member_nm)`.

К примеру, если предполагается хранить элементы типа `struct foo` в неком списке `bar`, используя связку `bar_link`, то соответствующий вспомогательный тип можно объявить через макрос `list_element_t` примерно так:
{{{
typedef list_element_t(struct foo, bar_link) foo_in_bar_t;
}}}

После определения такого типа можно вызывать методы списка, пользуясь указателями на объекты типа `struct foo` (а не на связки внутри них). Например, удалить первый элемент списка (если таковой имеется) и добавить его последним, вернув его как результат функции, можно следующим образом:
{{{
struct foo *move_first_to_last(struct list *bar) {
	struct foo *foo;

	foo = list_remove_first(foo_in_bar_t, bar);
	if (foo != NULL) {
		list_add_last(foo_in_bar_t, foo, bar);
	}

	return foo;
}
}}}

== Без определения нового типа ==
В случае, когда определение вспомогательного типа нецелесообразно (например, со структурой данных производится лишь несколько операций), можно использовать методы с суффиксом *`_element`*, принимающие тип элемента и имя поля-связки. Тот же пример можно переписать так:
{{{
struct foo *move_first_to_last(struct list *bar) {
	struct foo *foo;

	foo = list_remove_first_element(bar, struct foo, bar_link);
	if (foo != NULL) {
		list_add_last_element(foo, bar, bar_link);
	}

	return foo;
}
}}}

== Используя "сырые" связки ==
Наконец, можно отказаться от использования типизации вообще и приводить типы вручную. Для работы напрямую с объектами-связками предназначены методы *`_link`*:
{{{
struct foo *move_first_to_last(struct list *bar) {
	struct list_link *link;

	link = list_remove_first_link(bar);
	if (link != NULL) {
		list_add_last_link(link, bar);

		return list_element(link, struct foo, bar_link);
	}

	return NULL;
}
}}}

= Средства отладки =