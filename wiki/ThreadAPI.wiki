#summary API управления потоками.

=Прикладной интерфейс для работы с потоками=
Прикладной интерфейс - набор функций, позволяющих задавать параметры для конкретного потока. Эти параметры позволяют управлять поведением исполнения потока и определяют отведенное ему время исполнения, порядок предоставления времени, размер памяти для автоматических переменных (стека) и так далее. Все функции можно разделить по времени использования на несколько этапов:
  * Создание
  * Запуск
  * Управление исполнением
  * Завершение

==Создание потока==
Создание потока осуществляется с помощью функции  thread_create().
В задачи данной функции входит:
  * выделение памяти под все необходимые структуры;
  * проверка на допустимость всех параметров вновь создаваемого потока;
  * инициализация структуры описателя потока.
В случае успеха данная функция возвращает указатель на выделенный и инициализированный дескриптор потока. Данный указатель на вновь созданный поток может быть использован для управления потоком, например для запуска потока, управления ресурсами и так далее (См. соответствующие разделы). Если поток по каким-то причинам не может быть создан, то функция возвращает ошибочный указатель, который содержит код ошибки в специальном формате.

В зависимости от переданных флагов, созданный поток может обладать различными свойствами. Возможны следующие флаги:
  * THREAD_FLAG_SUSPEND - флаг используется для управлением временем старта потока (см. раздел “Запуск потока”)
  * THREAD_FLAG_NO_TASK - флаг используется для регистрации потока в системе (см. раздел “Регистрация потока в системе”)
  * THREAD_FLAG_PRIORITY_INHERIT - флаг используется для управления приоритетам (см.раздел “Управление приоритетами потока”)
  * THREAD_FLAG_DETACH - флаг используется для управления ресурсами (см. раздел “Управление ресурсами потока”)

==Запуск потока==
Планировщик предоставляет процессорное время для работы потоку только тогда, когда описатель потока находиться в очереди исполнения планировщика.

Поток при создании функцией thread_create() автоматически попадает в очередь, если не указан флаг THREAD_FLAG_SUSPEND. Если же этот флаг указан, то для запуска потока на выполнение необходимо вызвать функцию thread_launch(). Данная функция вносит поток в очередь готовых и меняет статус потока на Ready (см. раздел “Машина состояний потока”).

Поток выполняет функцию, которую ему указали при создании, но выполнение он начинает не с нее, а с функции-обертки thread_trampoline, то есть адрес этой функции-обертки заносится в контекст процессора вновь созданного потока в качестве адреса текущей исполняемой команды. Она служит для подготовки начального контекста и корректного завершения потока. Поскольку смена контекста происходит с запретом на прерывания, в начале этой функции стоит проверка на то, что она вызвана из правильного контекста, затем разрешаются прерывания, и после этого происходит, собственно, вызов пользовательской функции.

==Регистрация потока в системе==
Поток должен быть зарегистрированным в системе. Для этого недостаточно иметь только очередь планировщика, поскольку в этой очереди находятся только готовые получить время процессора потоки, ведь системе необходимо знать информацию о всех существующих потоках.

Поток как объект ОС относится к какому-либо процессу. Данный объект объединяет ресурсы для выполнения прикладной задачи, в том числе содержит список потоков как сущностей, под которые выделяется время процессора. Более подробно см. раздел “Организация процессов”.

В системе существует список процессов, и добавление потока в список потоков для процесса по сути дела является регистрацией потока в системе.
По умолчанию, при создании поток добавляется к текущей задаче, из которой вызвана функция thread_create(). Но если в качестве параметра указан флаг THREAD_FLAG_NO_TASK, то данный поток не добавляется ни в какую задачу. Код который вызвал функцию thread_create() сам ответственен за последующую регистрацию потока в системе.

Поскольку в системе не может быть запущенных, но не зарегистрированных потоков, флаг THREAD_FLAG_NO_TASK может быть использован только совместно с флагом THREAD_FLAG_SUSPEND. А также прежде, чем стартовать поток функцией thread_launch(), необходимо зарегистрировать поток в системе с помощью thread_register().

Для того, чтобы удалить поток из системы, нужно убрать его из списка потоков процесса  с помощью функции thread_unregister(). Эту функцию можно вызвать лишь тогда, когда освобождаются все ресурсы, занятые потоком, поэтому она вызывается в функции thread_delete().

==Управление приоритетом потока==
Планировщик выбирает следующий поток для выполнения исходя их правил, определенных стратегией планирования, и атрибутов планирования для каждого потока. Одним из самых значимых атрибутов является приоритет выполнения. Это сложный атрибут, он состоит из приоритета потока и приоритета процесса, к которому он относится. Кроме того, если система поддерживает наследование приоритетов, то планировщик может использовать так называемый текущий приоритет исполнения (более подробно см. в разделе “Инверсия приоритетов”).

Программисту доступен интерфейс для управления приоритетом потока, но не приоритетом исполнения. Он состоит из функций thread_set_priority() и thread_get_priority().

С помощью thread_set_priority() программист может установить желаемый приоритет потоку, исходя из правила - чем больше приоритет, тем больше вероятность того, что данному потоку предоставят время для исполнения среди потоков, принадлежащих данному процессу. Для того, чтобы увеличить вероятность предоставления времени для всех потоков в системе, необходимо увеличить приоритет процесса (см. Раздел Управление приоритетами процессов).

При создании потоку предоставляется “средний” приоритет потока. Если поток создается с флагом THREAD_FLAG_PRIORITY_INHERIT, то приоритет потока наследуется от потока, в котором он был создан.

Приоритет исполнения назначается потоку, когда происходит запуск потока, то есть включение его в очередь готовых потоков планировщика (см. раздел Приоритет выполнения). Изменяется поток исполнения тогда, когда меняется либо приоритет потока, либо приоритет задачи (см. раздел Управление приоритетом процесса)

==Управление ресурсами==
При создании потока выделяется память под стек и все необходимые структуры. Процесс освобождения этих ресурсов зависит от состояния потока во внутренней машине состояний управления ресурсами. Ее можно представить следующим образом:

http://embox.googlecode.com/svn/wiki/images/Scheduler/ResourceMachine.png

Поток создается в состоянии joinable, то есть он может быть присоединен к какому-то внешнему потоку (перейти в состояние joined) либо отсоединен от всех потоков (перейти в состояние detached). Если при вызове функции thread_create() указать флаг THREAD_FLAG_DETACH, то поток переходит в состояние detached еще до возврата из функции thread_create().

Состояние joined означает, что какой-то внешний поток ожидает завершения данного потока. И после завершения joined потока ресурсы не освобождаются, а ожидающему потоку сообщается о завершении, и он в свою очередь должен освободить занятые завершившимся потоком ресурсы.

Состояние detached означает, что при завершении поток никого не информирует, а самостоятельно освобождает все выделенные ему ресурсы.

Если поток при завершении находиться в состоянии joinable, то ресурсы не освобождаются, поток завершает свою работу, но указатель все еще является корректным. Ресурсы освободятся когда внешний поток переведет его в состояние joined или detached.

Из состояния joinable поток может выйти только один раз перейдя соответственно либо в joined, либо в detached. При этом, из этих состояний поток не может выйти. То есть попытка перевода потока в любое состояние не из состояния joinable приведет к неопределенной ситуации и будет выработано исключение.

В состоянии detached поток может оказаться, если при создании был указан флаг THREAD_FLAG_DETACH или была вызвана функция thread_detach().
В состоянии joined поток может оказаться, если была вызвана функция thread_join().

Для освобождения ресурсов используется внутренняя функция thread_delete(). Данная функция освобождает память, занятую под стек и структуры, используемые описателем потока. После этого описатель потока является недействительным и не может быть использован. Поскольку данная  функция может быть вызвана потоком который исполняется на процессоре, но который еще не завершился(см. раздел “Завершение потока”), то в данной функции предусмотрен режим отложенного удаления. То есть указатель на дескриптор, который не может быть удален в данный момент, запоминается, а когда будет вызвана функция thread_delete() уже для другого потока, сохраненный дескриптор освобождается, поскольку он не может оказаться исполняющимся на процессоре. Функция thread_delete(), помимо прочего, вызывает thread_unregister() (см. раздел Регистрация потоков в системе).

==Завершение==

Поток завершается в нескольких случаях:
  * При завершении/уничтожении всего процесса, к которому относиться поток;
  * Если функция потока полностью отработала и вернула управление;
  * Если поток вызвал функцию thread_exit()

Первый случай отличается от двух других тем, что в этом случае какой-то внешний фактор прерывает естественное исполнение функции потока и принудительно уничтожает поток. Поскольку естественное выполнение было нарушено, а поток мог заблокировать какой то объект синхронизации, то нужно позаботиться о разблокировке этого объекта. Но поскольку уничтожается весь поток, то все объекты синхронизации уже не имеют смысла. И может быть вызвана функция thread_destroy(), которая просто уберет поток из очереди планировщика, если он там присутствует и удалит из списка потоков к задаче. Удаление памяти происходит так же форсированно, то есть поток перед переводится в состояние detached, и, следовательно, самостоятельно освобождает память (см. Раздел управление ресурсами потока).

Если поток завершается самостоятельно, то он попадает в функцию обертку thread_trampoline() (см. раздел “Запуск потока”), там вызывается завершающая функция thread_exit().

Если поток самостоятельно вызвал функцию thread_exit(), то потоку выставляется состояние W (см. Машина состояний планировщика), затем проверяется состояние его машины управления ресурсами (см. раздел “Управление ресурсами потока”), и в зависимости от состояния предпринимаются действия описанные в этом разделе. После этого поток передает управление планировщику, и на этом поток прекращает работу.
