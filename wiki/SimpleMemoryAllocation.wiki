= Описание =
http://embox.googlecode.com/svn/wiki/images/MemoryAllocation/memory_block.png

Отведём непрерывный буфер и будем использовать его как для выделения памяти, так и для хранения служебной информации.
Весь буфер можно разбить на блоки произвольного размера со следующей структурой: в начале каждого блока поместить дескриптор - две ячейки (8 байт). В первой хранится информация о том, свободен блок или нет. Во второй хранится размер блока. Изначально имеется один свободный блок, его размер равен размеру всей памяти.

= Алгоритм =
http://embox.googlecode.com/svn/wiki/images/MemoryAllocation/simple_allocation_algorithm.png

== Инициализация ==
Прежде всего проходит инициализация. Вся имеющаяся память представляет собой один свободный блок. Указатель current_space установлен на начало этого блока, т.е. на начало памяти. 

== Выделение памяти ==
http://embox.googlecode.com/svn/wiki/images/MemoryAllocation/simple_allocation_algorithm_alloc.png

Выделение памяти происходит в два этапа:
 # Поиск подходящего блока
 # Резервирование блока

=== Поиск подходящего блока =
Сначала необходимо найти подходящий по размеру свободный блок. Поиск начинается с адреса, на который указывает current_space. До этого указателя вся память гарантированно занята.  
Рассмотрим позицию указателя current_space. Функция  find_suit_block заводит новую переменную структуры, и прежде всего нужно удостовериться, что адрес указывает на доступное пространство. Далее проверяет:
   # является ли блок свободным;
   # вмещает ли он в себя блок, который необходимо выделить.
Если оба условия верны, то блок является подходящим и функция возвращает адрес этого блока. Если одно из условий ложно, то рассматривается следующий блок, адрес которого формируется по средствам прибавлением к началу блока его размера. Новый блок рассматривается аналогичным образом. На каждом шаге производится проверка: если переменная дошла до конца доступной памяти, то функция возвращает NULL. 

=== Резервирование блока ===
Непосредственное выделение памяти функцией memory_allocate. Прежде всего проверяем, удалось ли найти подходящий блок. Если нет, то выдаётся соответствующее сообщение, иначе от подходящего кусочка нужно разбить на два блока. Первый помечается как занятый, его размер - размер запрашиваемой памяти + размер дескриптора. Второй блок - это то, что осталось. Необходимо определить размер этой памяти и пометить её как свободную. 

http://embox.googlecode.com/svn/wiki/images/MemoryAllocation/simple_allocation_algorithm_steps.png

=== Перемещение указателя ===
Следующим шагом следует переместить указатель current_space. Это делается с целью оптимизации последующего поиска свободного блока. 
Проверяем: совпал ли указатель на текущее положение в памяти с началом выделенного блока. Возможно два варианта: 
 # Да. Значит до конца только что выделенного блока вся память занята, и указатель можно передвинуть. Тогда новый поиск начнётся с нового места.
 # Нет. Значит до этого блока в памяти есть свободный блок, который не подошёл по размеру (он мог образоваться в результате удаления). Следовательно, в данный момент current_space указывает на него. Следующий поиск следует начинать с того же блока, поэтому указатель current_space не меняет своего положения.
Замечание: current_space не всегда указывает на свободное место. Рассмотрим ситуацию, когда есть "дырка" и нам нужно выделить блок, совпадающий с размером свободной области, и есть место для дескриптора. В этом случае после выделения памяти current_space начнёт указывать на следующий блок, который занят. Именно поэтому поиск следующего свободного блока начинается с проверки "Занят ли этот блок?" Эта ситуация не самая оптимальная, т. к. в ходе последующего поиска сразу же встречается занятый блок. Но данное продвижение всё равно сужает область поиска для следующего блока. Если будет освобождаться область, предшествующая указателю current_space, то он переместится и снова будет указывать на свободный блок.

http://embox.googlecode.com/svn/wiki/images/MemoryAllocation/simple_allocation_move_pointer.png

Следует помнить, что оставшаяся память должна быть больше размера дескриптора блока. Если оставшийся блок меньше, то его следует просто добавить к выделяемой памяти, т.к. если попытаться организовать эту память в отдельный блок и следующий за ним блок окажется не пустым, то произойдёт затирание этого блока.

http://embox.googlecode.com/svn/wiki/images/MemoryAllocation/simple_allocation_move_pointer_variants.png

=== Возвращение выделенного блока ===
Результатом, возвращаемым после выделения памяти, является адрес внутри выделяемого блока, куда пользователь или программа, запрашивающая память, сможет записать данные. 
http://embox.googlecode.com/svn/wiki/images/MemoryAllocation/simple_allocation_return_block.png
 
== Освобождение памяти ==
На вход функции memory_free подаётся адрес, по которому располагаются данные внутри блока (не адрес блока) который следует удалить. Соответственно перед этим адресом находиться дескриптор блока, т.е. если отнять размер дескриптора, получится указатель на информацию о блоке. Данный блок нужно освободить, т.е. в его дескрипторе указать "свободен".
После нескольких удалений может возникнуть проблема фрагментации: два или более свободных блока могут оказаться рядом и их следует склеить, чтобы можно было вместить блок большего размера, чем каждый из них, (но не больше, чем их сумма без размера дескриптора). Поэтому после каждого удаления следует провести дефрагментацию - процесс устранения фрагментации. 

== Дефрагментация ==
Освобождение может быть проведено в четырех случаях: 
 # Внутри занятой памяти. Слева и справа занятые блоки. Дефрагментация не требуется;
 # До свободного блока. Справа свободный, слева занят. Нужно склеить два кусочка;
 # После свободного блока. Слева свободный, справа занят. Нужно склеить два кусочка;
 # Между свободными блоками. Слева и справа свободные блоки. Нужно склеить три кусочка.

http://embox.googlecode.com/svn/wiki/images/MemoryAllocation/simple_allocation_defragmentation.png
Идея дефрагментации в данной реализации состоит в том, что обрабатывается вся свободная память в порядке встречи. Таким образом,  второй и третий пункт будут обрабатываться одинаково. А четвёртый аналогичен второму и третьему: дефрагментация применяется дважды (три свободных блока -> два свободных блока -> один свободный блок).
Есть указатель  current_space. С него можно начать, т.к. до него гарантированно нет свободных кусков памяти. Рассматриваем текущий блок и следующий за ним. Если текущий свободен и следующий тоже, то склеиваем их и снова проверяем с того же адреса (но блок уже другой - объединённый). Если следующий блок занят - проходим и ищем следующий свободный и повторяем проверку для него.  
Также в данном алгоритме присутствует внешняя дефрагментация - накладные расходы памяти на дескрипторы блоков (на схемах помечены красным цветом).