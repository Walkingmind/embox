#summary This page describes virtual memory concepts and organization.

<wiki:toc max_depth="2" />

= Описание =

Механизм виртуальной памяти был разработан для увеличения основной памяти
системы. Но оказался очень удобным и сейчас применяется в большинстве
современных систем для поддержки многозадачности. В системах общего назначения
используется страничный механизм памяти, весьма удобный и достаточно
незатратный, который и будет рассмотрен в дальнейшем.

Виртуальная память позволяет работать каждой программе в собственном непрерывном
адресном пространстве, снимая с программы требование управления памяти, изолируя
различные программы, защищая разные программы от нежелательных пересечений.

Работу виртуальной памяти поддерживает специальное устройство, менеджер памяти
(memory managment unit, mmu).

= Страница =

Страница -- непрерывный блок памяти небольшого размера (распространён размер
страницы равный 4 KB), как правило, выровненный в физической памяти по размеру
страницы.

Страница является базовым элементом. Каждая страница в виртуальной памяти
соответствует некоторой странице в физической памяти.

У страницы в виртуальной памяти есть ряд аттрибутов
 # Наличие
   Существует ли отображение данной страницы в физическую память
 # Обращение
   Был ли когда-либо осуществлен доступ к данной странице
 # Запись
   Была ли осуществлена запись в данную страницу
 # Права доступа
   Определяют разрешения доступа во время обычного/привелегированного режима
   работы процессора

= Работа менеджера памяти =

Менеджер памяти является абстрактной, виртуальной оперативной памятью. Во время
работы виртуальной памяти, все операции с памятью ведутся через менеджер.

Менеджер осуществляет отображение страницы виртуальной памяти в страницу
физической. Когда происходит обращение по произвольному адресу виртуальной
памяти, менеджер памяти находит соответствующую данному адресу страницу
виртуальной памяти, отображает её на страницу физической памяти, далее
используя относительное смещение внутри страницы.

Узким местом в данной схеме является механизм отображения.

Большинство менеджеров в настоящее время работает по многоуровневой системе
отображений. Всё адресное пространство делится на небольшое количество блоков
памяти, каждому блоку сопоставляется запись в некоторой таблице. Каждая запись
явлется указателем на другую таблицу, соотвествующую блоку, и описывающую
дробление данного блока на ещё меньшие блоки. Схема имеет определенное
количество уровней таблиц и, соответственно, величину дробления всей памяти.
Наименьшее разбиение блока указывает на страницу в физической памяти.

Для оптимизации отображения применяется несколько улучшений. Во-превых, если
необходимо отобразить области, соответсвтующие бОльшим дроблениям, чем страницы,
то нет необходимости делать отображения на более глубоких уровнях, а можно
установить отображение при данном дроблении.

Во-вторых, нет необходимости при каждом обращении проходить полностью иерархию
таблиц, а "запомнить" ту структуру прохода, которая была обработана во время
последнего обращения к памяти в самом менеджере и при следующем обращении
использовать такие данные. На самом деле, то, что такая оптимизация даёт
примемлимое время работы данного механизма, является нетривиальным фактом.
Основной же предпослыкой является пространственная локальность обращений к
памяти.

= Со стороны операционной системы =

Виртуальная память работает всё время для обычного приложения. Таким образом,
программа не может обратиться к таблицам отображения, которые либо не
отображаются в адресное пространство, либо защищаются, и, соответственно,
получить доступ к пространству памяти другой программы.

Все операции по управлению страницами отводятся ОС. Когда приложение обращается
по виртуальному адресу, для которого не существует отображение в физическую
память, управление передается ОС, которая осуществляет размещение физической
страницы в памяти и настраивает отображение виртуальной страницы в физическую,
затем управление передается обратно в приложение.

Здесь возникает два вопроса: как размесить страницу в памяти, и, если памяти не
было достаточно для размещения, как выбрать страницу из памяти для перемещения
во внешнюю память?

Размещение в простом случае может быть простым удалением единственной страницы
из памяти и подгрузкой необходимой страницы. Более сложной схемой является
подгрузка сразу нескольких страниц, если известна их логическая "связанность",
но реализация такой схемы потребует либо информированность приложения о
страничной фрагментации и расположении данных по страницам, либо специальных
интерфейсов со стороны ОС. Хотя, следует отметить, что может потребоваться и
страничная огранизация памяти, и минимальное количество издержек для работы с
памятью, тогда второй вариант имеет право на жизнь.

Удаление страницы может быть выполнено несколькими способами. Каждый из них
проигрывает неосуществимой стратегии удаления страницы, последнее обращение к
которой происходило раньше остальных (реализация такой схемы требует чрезвычайно
много процессорного времени).

 * Случайная страница.
  Удаляется случайная страница. Возможны плохие варианты выбора. Полностью
  недетерминированно.
 * Выбор страницы по приоритетам.
  Задать страницам приоритеты в зависимости от аттрибутов. Например, страницы,
  к которым обращались имеют меньший приоритет, чем те, к которым обращались и
  в которые велась запись. Удалять страницы с наименьшим приоритетом.
 * Первая загруженая страница.
  Весьма неоптимальная схема, существуют варианты работы, когда первые страницы
  используются наиболее интенсивно.
 * Второй шанс.
  Вести очередь страниц на удаление. Если к странице до удаления был осуществлен
  доступ, то аттрибут обращения сбрасывается, страница переводится в конец
  очереди.
 * Рабочее множество.
  Анализ работы, выделение множества страниц, работа с которыми ведётся наиболее
  интенсивно. Для остальных страниц применять один из алгоритмов.

= Интерфейс =

Абстрактная модель памяти использует 3х уровневую систему трансляции. Существует
указатель на первую таблицу GLOBAL трансляции (CONTEXT), и каталоги страниц
GLOBAL, MIDDLE, PAGE, где запись в каталоге либо ссылка на каталог более мелкого
дробления, либо указатель на физическую область памяти (PAGE_ENTRY). Таким
образом, GLOBAL, MIDDLE, PAGE таблицы должны быть приводимы к PAGE_ENTRY.

Для каждой платформы поддерживающей механизм виртуальной памяти следует

 * указать переменные препроцессора
{{{
__MMU_GTABLE_SIZE
__MMU_MTABLE_SIZE
__MMU_PTABLE_SIZE
//количество записей в каждой из таблиц трансялции.

__MMU_PAGE_SIZE // размер страницы

__MMU_PAGE_CACHEABLE
__MMU_PAGE_WRITEABLE
__MMU_PAGE_EXECUTEABLE
//Флаги разрешения для страниц

__MMU_TABLE_HEADER_SIZE // минимиальное допустимое выравнивание для всех таблиц (больше машинного слова)

}}}

 * объявить типы
{{{
__mmu_paddr_t // физический адрес
__mmu_vaddr_t // виртуальный адрес
__mmu_page_flags_t // флаги страницы
__mmu_pgd_t // GLOBAL таблица
__mmu_pmd_t // MIDDLE таблица
__mmu_pte_t // PAGE_ENTRY
__mmu_env_t // полное описание окружения mmu
__mmu_ctx_t // CONTEXT
}}}
 * реализовать
{{{
void mmu_set_env(mmu_env_t *env) // установить окружение mmu

void mmu_save_env(mmu_env_t *env) // сохранить окружение mmu

void mmu_restore_env(mmu_env_t *env) //загрузить окружение mmu
//Последние две функции могут быть использованны только совместно

void mmu_on(void) //включить mmu

void mmu_off(void) // выключить mmu

void switch_mm(mmu_ctx_t prev, mmu_ctx_t next) // переключить CONTEXT

mmu_ctx_t mmu_create_context(void) // создать новый CONTEXT

void mmu_delete_context(mmu_ctx_t ctx) // удалить CONTEXT

void mmu_set_pte(mmu_pte_t *ptep, mmu_pte_t pteval) // записать PAGE_ENTRY по адресу

void mmu_ctxd_set(mmu_ctx_t *ctxp, mmu_pgd_t *pgdp) // установить в CONTEXT GLОBAL таблицу

void mmu_pgd_set(mmu_pgd_t * pgdp, mmu_pmd_t * pmdp) // установать в GLOBAL MIDDLE таблицу

void mmu_pmd_set(mmu_pmd_t * pmdp, mmu_pte_t * ptep) // установить в MIDDLE PAGE таблицу

mmu_pmd_t *mmu_pgd_get(mmu_pgd_t * pgdp) // получить из GLOBAL MIDDLE таблицу

mmu_pte_t *mmu_pmd_get(mmu_pmd_t * pmdp) // получить из MIDDLE PAGE таблицу

pte_t mmu_pte_format(__mmu_paddr_t addr, __mmu_page_flags_t flags) // построить PAGE_ENTRY по адресу с флагами

paddr_t mmu_pte_extract(mmu_pte_t pte) // получить из PAGE_ENTRY физический адрес

mmu_page_flags_t mmu_flags_extract(mmu_pte_t pte) // получить из PAGE_ENTRY флаги

bool mmu_is_pte(mmu_pte_t pte) // проверить, является ли запись PAGE_ENTRY

bool mmu_valid_entry(mmu_pte_t pte) // является ли запись или PAGE_ENTRY, или ссылкой на каталог

pgd_t * mmu_get_root(mmu_ctx_t ctx) // получить из CONTEXT указатель на GLOBAL таблицу
}}}
