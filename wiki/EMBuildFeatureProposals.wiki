#summary Предложения по развитию системы сборки.

<wiki:gadget url="http://embox.googlecode.com/svn/wiki/gadgets/userbox-feature-proposal.xml" width="640" height="100" border="0"/>
<wiki:toc max_depth="2"/>

= Введение =
На этой странице результаты мозгового штурма на тему развития системы сборки EMBuild, просто идеи и мысли, а также план работ в этом направлении.

= Проблемы и возможные пути решения =
Текущая версия системы сборки больше не удовлетворяет нуждам проекта:
 * Разбухание некоторых Makefile'ов, например в `src/kernel`
 * Теряется видение структуры проекта
 * Нет гибкости в задании зависимостей для модулей

Для лучшего понимания назревших проблем предлагаю рассмотреть часть файла [http://code.google.com/p/embox/source/browse/trunk/embox/src/kernel/Makefile?r=1142 src/kernel/Makefile]. Он иллюстрирует большинство существующих сейчас недостатков. Этот пример и попробуем постепенно довести до ума.
{{{
$_PACKAGE   := core.kernel

$_CPPFLAGS  += -D__KERNEL__

$_LDFLAGS   += $($_SELFDIR)/nosys.lds

$(IMAGE): $($_SELFDIR)/nosys.lds

$_MODS_CORE += main
$_MODS      += irq softirq

$_SRCS-main += main.c
$_SRCS-main += init.c
$_SRCS-main += nosys.c

$_DEPS-main += embox.hal.arch
$_DEPS-main += irq

ifdef CONFIG_IRQ
 $_SRCS-irq += irq.c
 $_DEPS-irq += embox.hal.interrupt
 $_DEPS-irq += softirq
endif
ifdef CONFIG_SOFTIRQ
 $_SRCS-softirq += softirq.c
endif
}}}

= Структура файлов EMBuild =
Файлы EMBuild располагаются в папках дерева исходников, по соседству с самими кодами. На данный момент это файлы с именем *Makefile*. Эти файлы пишутся разработчиками *embox* и обрабатываются системой сборки.

== Проблема ==
Итак, смотрим [http://code.google.com/p/embox/source/browse/trunk/embox/src/kernel/Makefile?r=1142 src/kernel/Makefile]. Видим кучу определений переменных, описывающих свойства различных модулей. В одном месте:
 * Текущий пакет
{{{
$_PACKAGE   := core.kernel
}}}
 * Флаги компиляции
  * Для текущего пакета
{{{
$_CPPFLAGS  += -D__KERNEL__
}}}
  * И для всего образа
{{{
$_LDFLAGS   += $($_SELFDIR)/nosys.lds
}}}
 * Определение модулей
{{{
$_MODS_CORE += main
$_MODS      += irq softirq
}}}
  * Их исходников
{{{
$_SRCS-main += main.c
$_SRCS-main += init.c
$_SRCS-main += nosys.c

ifdef CONFIG_IRQ
 $_SRCS-irq += irq.c
endif
ifdef CONFIG_SOFTIRQ
 $_SRCS-softirq += softirq.c
endif
}}}
  * И зависимостей
{{{
$_DEPS-main += embox.hal.arch
$_DEPS-main += irq

ifdef CONFIG_IRQ
 $_DEPS-irq += embox.hal.interrupt
 $_DEPS-irq += softirq
endif
}}}
 * И, наконец, описание классических правил make
{{{
$(IMAGE): $($_SELFDIR)/nosys.lds
}}}

Ясно, что с ростом проекта поддерживать эти файлы будет все сложнее и неприятнее.

== Одна сущность - один файл ==
Первое, что приходит в голову, разбить такой Makefile на несколько, по одному файлу на каждую сущность (сущность - это либо модуль *MOD*, либо библиотека *LIB*). Такие файлы разумно называть по имени описываемой сущности с каким-нибудь специальным расширением. Возможные варианты (для сущности _xxx_):
 * *xxx.embuild* - длинно, зато понятно. И не без пафоса ;-)
 * *xxx.em* - по аналогии с файлами *`*`.am* системы `automake`
Почему не *`*`.mk*? Потому что эти файлы предпочтительно описывать, используя минимальное подмножество языка make (о предлагаемом синтаксисе [EMBuildFeatureProposals#%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81_em-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2 чуть позже]):
 * Во-первых, это упрощает понимание таких файлов разработчикам, не знакомым с make. В идеале при описании модуля разработчик вообще не должен задумываться о том, что он использует для этого язык make
 * Во-вторых, это дает возможность в отдаленной перспективе и вовсе отказаться от использования make для разбора этих файлов, написав что-нибудь попроще
Остановимся пока на варианте с *`*`.em*.

Тогда в `src/kernel` появятся следующие файлы:
 * *main.em*
{{{
$_MODS_CORE += main

$_SRCS-main += main.c
$_SRCS-main += init.c
$_SRCS-main += nosys.c

$_DEPS-main += embox.hal.arch
$_DEPS-main += irq
}}}
 * *irq.em*
{{{
$_MODS      += irq

ifdef CONFIG_IRQ
 $_SRCS-irq += irq.c
endif

ifdef CONFIG_IRQ
 $_DEPS-irq += embox.hal.interrupt
 $_DEPS-irq += softirq
endif
}}}
 * *softirq.em*
{{{
$_MODS      += softirq

ifdef CONFIG_SOFTIRQ
 $_SRCS-softirq += softirq.c
endif
}}}

=== Обратная совместимость ===
В результате обсуждения на одной из встреч прозвучала мысль, что выделять по отдельному файлу на каждую сущность - это радикальная порнография. Возможно, отчасти это действительно избыточно, и стоит сохранить возможность описания нескольких сущностей в одном файле (хотя бы ради обратной совместимости).

Все же, как сторонник подхода "одна сущность - один файл", постараюсь привести несколько аргументов в пользу разделения:
 * Сколько стоит новый файл? Ноль. Ноль рублей
 * Принцип "разделяй и властвуй"
 * Разработчику модуля проще и спокойнее изменять свой собственный файл, а не делить его с остальными
 * Если *em-файлов* в одной папке становится слишком много (скажем, больше 5-7), это верный знак того, что со структурой что-то не так

Впрочем, скорее всего на время миграции на новую версию системы сборки будет сохранена возможность описать несколько сущностей в одном файле. Несмотря на это, реализация все-равно будет заточена под использование отдельного файла для каждой сущности.

== Классические правила make ==
Теперь как быть с правилами make? Тут видится два подхода:
 * Описывать их как раньше в каком-нибудь Makefile'е, который будет интерпретироваться при каждой сборке. Если пойти по этому пути, то надо решить, что это будет за файл: 
  * Можно оставить старое *Makefile*. Но это скорее пережиток прошлого, от которого хочется избавиться. К тому же наличие файла Makefile подразумевает возможность запустить make из папки, в которой он находится, чего делать нельзя
  * *rules.mk* - более наглядно и по теме
 Чем плохо такое решение:
  * Правила для разных модулей снова оказываются вместе в одном файле, от чего мы хотим избавиться в первую очередь
  * Правила оказываются отвязанными от модуля. Во-первых, они находятся в отдельном файле, что усложняет их поддержку. Во-вторых, объявлять конкретное правило, вообще говоря, имеет смысл, только если модуль, к которому оно относится, фактически участвует в сборке
  * Неясно, как быть с тем фактом, что текущая директория, в которой запущен make, отличается от той, что содержит описываемый нами файл *rules.mk*. Типичный пример связанных с этим проблем можно найти в одном из платформенных Makefile'ов:
{{{
$_platform_lds := $(OBJ_DIR)/$($_SELFDIR)/platform.lds
$_LDFLAGS += -T $($_platform_lds)

$(IMAGE): $($_platform_lds)

$($_platform_lds): $($_SELFDIR)/platform.lds.S $(AUTOCONF_DIR)/config.lds.h
	mkdir -p $(@D) && $(CPP) -Wp, -P -undef $(CPPFLAGS) \
		-imacros $(AUTOCONF_DIR)/config.lds.h -MMD -MT $@ -MF $@.d -o $@ $<

-include $($_platform_lds).d
}}}
  Здесь к имени целевого файла добавляется путь `$(OBJ_DIR)/$($_SELFDIR)/`, а к реквизиту `$($_SELFDIR)/`. Это сильно привязывает нас к использованию отдельного дерева для объектных файлов, не говоря уже о том, что можно попросту забыть указать `$($_SELFDIR)`
  * Основная техническая проблема в том, что этот код интерпретируется make'ом безусловно, в глобальном контексте. Повлиять на него достаточно затруднительно из-за немедленной экспансии, применяемой для целей и реквизитов ([http://www.gnu.org/software/make/manual/make.html#Reading-Makefiles подробнее]):
{{{
immediate : immediate ; deferred
	deferred
}}}
 * Второй подход заключается в том, чтобы добавить сущностям новое свойство, содержащее описание нужных правил. Тогда правила можно будет определять динамически по мере необходимости.
  Например, для (вымышленного) модуля _platform_ можно будет описать это свойство примерно так:
{{{
$_OBJS-platform += platform.lds
define $_RULES-platform
  $(MOD_OBJ_DIR)/platform.lds : $(MOD_SRC_DIR)/platform.lds.S $(AUTOCONF_DIR)/config.lds.h
	mkdir -p $(@D) && $(CPP) -Wp, -P -undef $(CPPFLAGS) \
		-imacros $(AUTOCONF_DIR)/config.lds.h -MMD -MT $@ -MF $@.d -o $@ $<
-include $(MOD_OBJ_DIR)/platform.lds.d
endef
}}}
  Тогда если модуль _platform_ участвует в сборке, то система определяет необходимые правила (с помощью *`$(eval ...)`*), причем используя для этого более подходящий контекст, в котором, например, нужным образом раскрываются `$(MOD_OBJ_DIR)` и `$(MOD_SRC_DIR)`.

Про текущий пакет поговорим чуть позже.

== Реализация ==
Тут могут быть подводные камни, так уж сложилось исторически:
 * Вначале была плоская структура исходников, состоящая их нескольких папок в корне проекта (конец 2008). Список папок жестко задавался в Makefile'е верхнего уровня
 * Далее был сделан шаг в сторону рекурсивно вызываемого make, с произвольной структурой папок. Такой подход развивался в течение всего 2009
 * И, наконец, в текущей реализации рекурсивный make заменен одиночным, обрабатывающим Makefile'ы дерева исходников без создания дочерних процессов make (с начала 2010). Это сильно упростило создание внутренней модели, а также немного ускорило процесс сборки

Так или иначе, центральным понятием, которым оперировали все эти реализации, был и есть  узел дерева исходников, точнее *Makefile*, представляющий этот узел. Более того, Makefile любого узла мог изменить дочернее поддерево, обрабатываемое системой сборки, переопределив переменную *SUBDIRS*. Подробнее об этой проблеме в разделе [EMBuildFeatureProposals#%D0%92%D0%B5%D1%80%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8_EMBuild Верификация модели EMBuild].

Теперь же предлагается переориентировать систему так, чтобы она "мыслила" сущностями, представляемыми *em-файлами*. Поскольку Makefile'ы дерева исходников уже давно используются не по прямому назначению, а теперь большинство их функций переносится в em-файлы, то разумно и вовсе отказаться от использования Makefile'ов. Что касается переопределения списка просматриваемых поддиректорий, то можно пойти двумя путями:
 * В тех узлах, для которых это необходимо (например, `arch` или `platform`), добавить специальный файл, скажем *subdirs.mk*, в котором задавать новое значение переменной `SUBDIRS`
 * Отказаться от этой возможности совсем и всегда просматривать полное дерево исходников (включая все платформы и архитектуры). Тогда список всех em-файлов - это `r-wildcard` от *`**/*.em`*, и логика их чтения очень проста (можно вообще обойтись без рекурсивного просмотра дерева)

*TODO -- Eldar*

Теперь после такого топорного разнесения по файлам самое время поговорить о синтаксисе *файлов `*.em`*.

= Синтаксис em-файлов =
Посмотрим на получившиеся после разбиения файлы, например, на *main.em*. Слово *main* используется в каждой строке плюс в названии файла. Разумно избежать излишнего дублирования. Кроме того, для лучшей читаемости можно изменить некоторые мелочи:
 * Переименовать основные свойства, убрав сокращения (хотя можно и оставить, как минимум для обратной совместимости):
  * *SRCS → SOURCES*
  * *DEPS → DEPENDS*
 * Наконец, найден способ избавиться от символа контекста (*$`_`*)

Итак, на данный момент представляется два варианта синтаксиса.

== Плоский ==
Немного похож на существующий сейчас.
 * *main.em*
{{{
ENTITY = CORE_MOD

SOURCES += main.c
SOURCES += init.c
SOURCES += nosys.c

DEPENDS += embox.hal.arch
DEPENDS += irq

}}}
 В переменной *ENTITY* задается тип сущности, о них поговорим чуть позже.

 Преимущества:
  * Плоская структура
  * Более привычный стиль
 Недостатки:
  * Слишком много степеней свободы:
   * В `ENTITY` можно записать несколько значений, например, с помощью *+=*
   * Можно изменить значение несколькими строками ниже
   * Само присвоение можно написать в любом месте файла. Мелочь, но впечатление портит

== Объектный ==
Раз уж речь зашла о сущностях, то почему бы не отразить это и в синтаксисе?
 * *main.em*
{{{
define CORE_MOD

  SOURCES += main.c
  SOURCES += init.c
  SOURCES += nosys.c

  DEPENDS += embox.hal.arch
  DEPENDS += irq

endef
}}}

 Преимущества:
  * Интуитивно-понятный и наглядный способ описания сущностей и их свойств
  * Нет недостатков, связанных с определением типа сущности:
   * Определение переменной всегда сверху
   * Записать несколько значений в имени (то, что после слова `define`) получится разве что только через пробел
 Недостатки:
  * Для читаемости необходимо использовать отступы (причем *не табуляцию*)

= Межмодульные зависимости =
== Проблема ==
В двух словах - система позволяет задавать межмодульные зависимости, но сейчас они жестко прописаны в Makefile'ах, и у пользователя нет возможности повлиять на итоговый граф зависимостей.

 Например, модуль *Х* может зависеть от *Y*, тогда при включении в сборку *Х* тот потянет за собой *Y*. Это отношение *depends on*.
  http://embox.googlecode.com/svn/wiki/images/mods-old-simple.png
   _Module *X* *depends on* module *Y*._
<wiki:comment>
digraph mods_old_simple {
	rankdir="LR";
	node[shape=rect,style=filled];
	X [fillcolor="#c3d9ff" color="blue"];
	Y [fillcolor="#c3d9ff" color="blue"];
	X -> Y [label="depends on" color="blue"];
}
</wiki:comment>
 Проблемы начинаются, когда появляется необходимость менять реализации модулей. Пусть появился модуль *Z*, который выполняет схожие с *Y* функции (например, оба они реализуют алгоритмы выделения памяти). Тогда отношение *depends on* становится узким местом. Еще один неочевидный, но существенный недостаток в том, что факт "схожести" *Y* и *Z* нигде не отражен.
  http://embox.googlecode.com/svn/wiki/images/mods-old.png
<wiki:comment>
digraph mods_old {
	rankdir="LR";
	node[shape=rect,style=filled];
	X [fillcolor="#c3d9ff" color="blue"];
	Z [fillcolor="#c3d9ff" color="blue"];
	Y [fillcolor="#c3d9ff" color="blue"];
	X -> Z [color="red" label="?"];
	X -> Y [color="blue" label="depends on"];
}
</wiki:comment>

== Текущее положение дел ==
Были попытки решить эту проблему используя опции `CONFIG_XXX`.
 Вместо указания явной зависимости для *X* в Makefile'e указывается значение `$(CONFIG_XXX)`, которое раскрывается в нужный модуль, заданный в файле конфигурации с помощью `option(XXX)`.
  http://embox.googlecode.com/svn/wiki/images/mods-try.png
<wiki:comment>
digraph mods_try {
	rankdir="LR";
	node[shape=rect style=filled];
	С [fillcolor="#fff7c6" label="CONFIG_XXX" shape=note];
	X [fillcolor="#c3d9ff" color="blue"];
	Z [fillcolor="#c3d9ff" color="blue"];
	Y [fillcolor="#c3d9ff" color="blue"];
	W [fillcolor="#ffc6c6" color="red" label="???"];
	X -> С [color="blue" label="depends on"];
	С -> Z [dir="none"];
	С -> Y [dir="none" label="is"];
	С -> W [dir="none"];
}
</wiki:comment>

Но, очевидно, это временное решение, вот почему:
  * Отсутствие контроля со стороны системы сборки, в `CONFIG_XXX` можно вписать что угодно
  * В каждом отдельном случае необходимо городить эти опции заново, например, отдельно для драйверов контроллера прерываний, отдельно для стратегий планировщика и т.д.
  * Это сильно замедляет сборку из-за необходимости перекомпиляции всех исходников при изменении опций
  * Нигде не описано, какие именно опции нужно задать, чтобы собрать проект, и система сборки никак не может помочь или подсказать
  * _Короче, это хак, и рано или поздно это придется исправить_

== Решение ==
Одно из наиболее вероятных решений проблемы:
предлагается ввести, помимо модулей, новую сущность, называемую интерфейсом *API*, а также два новых отношения: *requires* и *provides*.
 Тогда пример выше будет выглядеть примерно так:
  http://embox.googlecode.com/svn/wiki/images/mods-new.png
   _Module *X* *requires* interface *A* which is *provided by* modules *Y* and *Z*_.
<wiki:comment>
digraph mods_new {
	rankdir="LR";
	node[shape=rect style=filled];
	A [fillcolor="#ddf8cc" color="green" shape=ellipse];
	X [fillcolor="#c3d9ff" color="blue"];
	Z [fillcolor="#c3d9ff" color="blue"];
	Y [fillcolor="#c3d9ff" color="blue"];
	X -> A [color="blue" label="requires"];
	A -> Z [color="green"];
	A -> Y [color="green" label="provided by"];
}
</wiki:comment>

= Верификация модели EMBuild =
(Речь шла об истории развития системы сборки)

Все эти реализации, так или иначе, использовали чтение дерева в глубину, список дочерних папок задавался с помощью переменной *SUBDIRS*. В последней версии эта переменная по умолчанию содержала список всех существующих поддиректорий, и в большинстве случаев можно было вообще не изменять ее значения. Изменение этой переменной требовалось в основном только в двух случаях:
 * Для входа в поддерево архитектурно-зависимых исходников:
  * *[http://code.google.com/p/embox/source/browse/trunk/embox/src/arch/Makefile?r=523 src/arch/Makefile]*
{{{
$_SUBDIRS := $(ARCH)
}}}
 * Для игнорирования некоторых папок, например *include*:
  * *[http://code.google.com/p/embox/source/browse/trunk/embox/src/Makefile?r=523 src/Makefile]*
{{{
$_SUBDIRS := $(filter-out include,$($_SUBDIRS))
}}}
Таким образом, система сборки обрабатывала, вообще говоря, далеко не все Makefile'ы. С одной стороны это хорошо, это чуть-чуть ускоряет сборку, немного помогает в изоляции пространств имен для каждой архитектуры. Но в целом это все-таки пережиток прошлого.



*TODO -- Eldar*

= TODO =
 * *MOD* - обычный модуль
 * *CORE_MOD* - модуль, включаемый в сборку всегда
 * *LIB* - библиотека