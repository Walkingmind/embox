#summary Предложения по развитию системы сборки.

<wiki:gadget url="http://embox.googlecode.com/svn/wiki/gadgets/userbox-feature-proposal.xml" width="640" height="100" border="0"/>
<wiki:toc max_depth="2"/>

= Введение =
На этой странице результаты мозгового штурма на тему развития системы сборки EMBuild, просто идеи и мысли, а также план работ в этом направлении.

= Проблемы и возможные пути решения =
Текущая версия системы сборки больше не удовлетворяет нуждам проекта:
 * Разбухание некоторых Makefile'ов, например в `src/kernel`
 * Теряется видение структуры проекта
 * Нет гибкости в задании зависимостей для модулей

Для лучшего понимания назревших проблем предлагаю рассмотреть часть файла [http://code.google.com/p/embox/source/browse/trunk/embox/src/kernel/Makefile?r=1142 src/kernel/Makefile]. Он иллюстрирует большинство существующих сейчас недостатков. Этот пример и попробуем постепенно довести до ума.
{{{
$_PACKAGE   := core.kernel

$_CPPFLAGS  += -D__KERNEL__

$_LDFLAGS   += $($_SELFDIR)/nosys.lds

$(IMAGE): $($_SELFDIR)/nosys.lds

$_MODS_CORE += main
$_MODS      += irq softirq

$_SRCS-main += main.c
$_SRCS-main += init.c
$_SRCS-main += nosys.c

$_DEPS-main += embox.hal.arch
$_DEPS-main += irq

ifdef CONFIG_IRQ
 $_SRCS-irq += irq.c
 $_DEPS-irq += embox.hal.interrupt
 $_DEPS-irq += softirq
endif
ifdef CONFIG_SOFTIRQ
 $_SRCS-softirq += softirq.c
endif
}}}

= Структура файлов EMBuild =
Файлы EMBuild располагаются в папках дерева исходников, по соседству с самими кодами. На данном этапе это файлы с именем *Makefile*. Эти файлы пишутся разработчиками *embox* и обрабатываются системой сборки.

== Проблема ==
Итак, смотрим [http://code.google.com/p/embox/source/browse/trunk/embox/src/kernel/Makefile?r=1142 src/kernel/Makefile]. Видим кучу определений переменных, описывающих свойства различных модулей. В одном месте:
 * Текущий пакет
{{{
$_PACKAGE   := core.kernel
}}}
 * Флаги компиляции
  * Для текущего пакета
{{{
$_CPPFLAGS  += -D__KERNEL__
}}}
  * И для всего образа
{{{
$_LDFLAGS   += $($_SELFDIR)/nosys.lds
}}}
 * Определение модулей
{{{
$_MODS_CORE += main
$_MODS      += irq softirq
}}}
  * Их исходников
{{{
$_SRCS-main += main.c
$_SRCS-main += init.c
$_SRCS-main += nosys.c

ifdef CONFIG_IRQ
 $_SRCS-irq += irq.c
endif
ifdef CONFIG_SOFTIRQ
 $_SRCS-softirq += softirq.c
endif
}}}
  * И зависимостей
{{{
$_DEPS-main += embox.hal.arch
$_DEPS-main += irq

ifdef CONFIG_IRQ
 $_DEPS-irq += embox.hal.interrupt
 $_DEPS-irq += softirq
endif
}}}
 * И, наконец, описание классических правил make
{{{
$(IMAGE): $($_SELFDIR)/nosys.lds
}}}

Ясно, что с ростом проекта поддерживать эти файлы будет все сложнее и неприятнее.

== Грубое улучшение ==
Первое, что приходит в голову, разбить такой Makefile на несколько, по одному файлу на каждую сущность (сущность - это либо модуль *MOD*, либо библиотека *LIB*). Такие файлы разумно называть по имени описываемой сущности с каким-нибудь специальным расширением. Возможные варианты (для модуля *xxx*):
 * *xxx.embuild* - длинно, зато понятно. И не без пафоса ;-)
 * *xxx.em* - по аналогии с файлами *`*`.am* системы `automake`
Почему не *`*`.mk*? Потому что эти файлы предпочтительно описывать, используя минимально подмножество языка make (о предлагаемом синтаксисе чуть позже):
 * Во-первых, это упрощает понимание таких файлов разработчикам, не знакомым с make
 * Во-вторых, это дает возможность в отдаленной перспективе и вовсе отказаться от использования make для разбора этих файлов, написав что-нибудь попроще

Также потребуется как минимум файл для правил make.
 * Можно оставить старое *Makefile*. Но это скорее пережиток прошлого, от которого хочется избавиться. К тому же имя Makefile подразумевает возможность запустить make не из корневой папки, чего делать нельзя
 * *rules.mk* - лично мне нравится больше

Про текущий пакет поговорим чуть позже.

Тогда в `src/kernel` появятся следующие файлы:
 * *rules.mk*
{{{
$(IMAGE): $($_SELFDIR)/nosys.lds
}}}

 * *main.em*
{{{
$_MODS_CORE += main

$_SRCS-main += main.c
$_SRCS-main += init.c
$_SRCS-main += nosys.c

$_DEPS-main += embox.hal.arch
$_DEPS-main += irq
}}}

 * *irq.em*
{{{
$_MODS      += irq

ifdef CONFIG_IRQ
 $_SRCS-irq += irq.c
endif

ifdef CONFIG_IRQ
 $_DEPS-irq += embox.hal.interrupt
 $_DEPS-irq += softirq
endif
}}}

 * *softirq.em*
{{{
$_MODS      += softirq

ifdef CONFIG_SOFTIRQ
 $_SRCS-softirq += softirq.c
endif
}}}

== Реализация ==
Тут могут быть подводные камни, так уж сложилось исторически:
 * Вначале была плоская структура исходников, состоящая их нескольких папок в корне проекта (конец 2008). Список папок жестко задавался в Makefile'е верхнего уровня
 * Далее был сделан шаг в сторону рекурсивно вызываемого make, с произвольной структурой папок. Такой подход развивался в течение всего 2009
 * И, наконец, в текущей реализации рекурсивный make заменен одиночным, обрабатывающим Makefile'ы дерева исходников без создания дочерних процессов make (с начала 2010). Это сильно упростило создание внутренней модели, а также немного ускорило процесс сборки

Все эти реализации, так или иначе, использовали чтение дерева в глубину, список дочерних папок задавался с помощью переменной *SUBDIRS*. В последней версии эта переменная по умолчанию содержала список всех существующих поддиректорий, и в большинстве случаев можно было вообще не изменять ее значения. Изменение этой переменной требовалось в двух основных случаях:
 * Для входа в поддерево архитектурно-зависимых исходников:
  * *[http://code.google.com/p/embox/source/browse/trunk/embox/src/arch/Makefile?r=523 src/arch/Makefile]*
{{{
$_SUBDIRS := $(ARCH)
}}}
 * Для игнорирования некоторых папок, например *include*:
  * *[http://code.google.com/p/embox/source/browse/trunk/embox/src/Makefile?r=523 src/Makefile]*
{{{
$_SUBDIRS := $(filter-out include,$($_SUBDIRS))
}}}

Теперь после такого топорного разнесения по файлам самое время поговорить о синтаксисе *файлов `*.em`*.

= Синтаксис файлов EMBuild =
Посмотрим на получившиеся после разбиения файлы, например, на *main.mk*. Слово *main* используется в каждой строке плюс в названии файла. Разумно избежать излишнего дублирования. Кроме того, для лучшей читаемости можно изменить некоторые мелочи:
 * Переименовать основные свойства, убрав сокращения (хотя можно и оставить, как минимум для обратной совместимости):
  * *SRCS → SOURCES*
  * *DEPS → DEPENDS*
 * Наконец, найден способ избавиться от символа контекста (*$`_`*)

Итак, на данный момент представляется два варианта синтаксиса.

== Плоский ==
Немного похож на существующий сейчас.
 * *main.em*
{{{
ENTITY = CORE_MOD

SOURCES += main.c
SOURCES += init.c
SOURCES += nosys.c

DEPENDS += embox.hal.arch
DEPENDS += irq

}}}
 В переменной *ENTITY* задается тип сущности, о них поговорим чуть позже.

 Преимущества:
  * Плоская структура
  * Более привычный стиль
 Недостатки:
  * Слишком много степеней свободы:
   * В `ENTITY` можно записать несколько значений, например, с помощью *+=*
   * Можно изменить значение несколькими строками ниже
   * Само присвоение можно написать в любом месте файла. Мелочь, но впечатление портит

== Объектный ==
Раз уж речь зашла о сущностях, то почему бы не отразить это и в синтаксисе?
 * *main.em*
{{{
define CORE_MOD

  SOURCES += main.c
  SOURCES += init.c
  SOURCES += nosys.c

  DEPENDS += embox.hal.arch
  DEPENDS += irq

endef
}}}

 Преимущества:
  * Интуитивно-понятный и наглядный способ описания сущностей и их свойств
  * Нет недостатков, связанных с определением типа сущности:
   * Определение переменной всегда сверху
   * Записать несколько значений через пробел в имени (то, что после слова `define`) не получится
 Недостатки:
  * Для читаемости необходимо использовать отступы (причем *не табуляцию*)

= Межмодульные зависимости =
== Проблема ==
В двух словах - система позволяет задавать межмодульные зависимости, но сейчас они жестко прописаны в Makefile'ах, и у пользователя нет возможности повлиять на итоговый граф зависимостей.

 Например, модуль *Х* может зависеть от *Y*, тогда при включении в сборку *Х* тот потянет за собой *Y*. Это отношение *depends on*.
  http://embox.googlecode.com/svn/wiki/images/mods-old-simple.png
   _Module *X* *depends on* module *Y*._
<wiki:comment>
digraph mods_old_simple {
	rankdir="LR";
	node[shape=rect,style=filled];
	X [fillcolor="#c3d9ff" color="blue"];
	Y [fillcolor="#c3d9ff" color="blue"];
	X -> Y [label="depends on" color="blue"];
}
</wiki:comment>
 Проблемы начинаются, когда появляется необходимость менять реализации модулей. Пусть появился модуль *Z*, который выполняет схожие с *Y* функции (например, оба они реализуют алгоритмы выделения памяти). Тогда отношение *depends on* становится узким местом. Еще один неочевидный, но существенный недостаток в том, что факт "схожести" *Y* и *Z* нигде не отражен.
  http://embox.googlecode.com/svn/wiki/images/mods-old.png
<wiki:comment>
digraph mods_old {
	rankdir="LR";
	node[shape=rect,style=filled];
	X [fillcolor="#c3d9ff" color="blue"];
	Z [fillcolor="#c3d9ff" color="blue"];
	Y [fillcolor="#c3d9ff" color="blue"];
	X -> Z [color="red" label="?"];
	X -> Y [color="blue" label="depends on"];
}
</wiki:comment>

== Текущее положение дел ==
Были попытки решить эту проблему используя опции `CONFIG_XXX`.
 Вместо указания явной зависимости для *X* в Makefile'e указывается значение `$(CONFIG_XXX)`, которое раскрывается в нужный модуль, заданный в файле конфигурации с помощью `option(XXX)`.
  http://embox.googlecode.com/svn/wiki/images/mods-try.png
<wiki:comment>
digraph mods_try {
	rankdir="LR";
	node[shape=rect style=filled];
	С [fillcolor="#fff7c6" label="CONFIG_XXX" shape=note];
	X [fillcolor="#c3d9ff" color="blue"];
	Z [fillcolor="#c3d9ff" color="blue"];
	Y [fillcolor="#c3d9ff" color="blue"];
	W [fillcolor="#ffc6c6" color="red" label="???"];
	X -> С [color="blue" label="depends on"];
	С -> Z [dir="none"];
	С -> Y [dir="none" label="is"];
	С -> W [dir="none"];
}
</wiki:comment>

Но, очевидно, это временное решение, вот почему:
  * Отсутствие контроля со стороны системы сборки, в `CONFIG_XXX` можно вписать что угодно
  * В каждом отдельном случае необходимо городить эти опции заново, например, отдельно для драйверов контроллера прерываний, отдельно для стратегий планировщика и т.д.
  * Это сильно замедляет сборку из-за необходимости перекомпиляции всех исходников при изменении опций
  * Нигде не описано, какие именно опции нужно задать, чтобы собрать проект, и система сборки никак не может помочь или подсказать
  * _Короче, это хак, и рано или поздно это придется исправить_

== Решение ==
Одно из наиболее вероятных решений проблемы:
предлагается ввести, помимо модулей, новую сущность, называемую интерфейсом *API*, а также два новых отношения: *requires* и *provides*.
 Тогда пример выше будет выглядеть примерно так:
  http://embox.googlecode.com/svn/wiki/images/mods-new.png
   _Module *X* *requires* interface *A* which is *provided by* modules *Y* and *Z*_.
<wiki:comment>
digraph mods_new {
	rankdir="LR";
	node[shape=rect style=filled];
	A [fillcolor="#ddf8cc" color="green" shape=ellipse];
	X [fillcolor="#c3d9ff" color="blue"];
	Z [fillcolor="#c3d9ff" color="blue"];
	Y [fillcolor="#c3d9ff" color="blue"];
	X -> A [color="blue" label="requires"];
	A -> Z [color="green"];
	A -> Y [color="green" label="provided by"];
}
</wiki:comment>


= TODO =
 * *MOD* - обычный модуль
 * *CORE_MOD* - модуль, включаемый в сборку всегда
 * *LIB* - библиотека