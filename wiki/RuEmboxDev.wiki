#labels Phase-Design,Phase-Implementation,Featured
=Устройства в ОС "Embox"=

Предупреждаю, написано не совсем в официальном стиле, это скорее наброски, о чем я надумал, за последние пару дней, написанные для ознакомления других и обсуждения сего. =)
Приятного прочтения!

==Интерфейсы в общих чертах==
Предполагается ввести стандартизованный интерфейс для всех устройств системы 
и общий пул для них. Как вариант пул это просто массив {{{ device_t[MAX_DEVICE_COUNT] }}}. 

Дескриптор устройства в общем случае можно обозвать FILE 
{{{ typedef int FILE; }}} 
в нашем случае он будет просто индексом в массиве.

Для каждого процесса, файла, устройства, драйвера (всего что будет предоставлять символьный интерфейс) необходимо сделать привязку, т.е. куда собственно
поток будет перенаправляться, и здесь возможны варианты (как я вижу):
  # для каждого соединения сделать явный поток bind в котором будет крутиться вещь наподобие {{{ do { a.putc(b.getc()); } while(1); }}};
  # это же можно сделать посредством callback т.е. хранить указатель на функцию которую необходимо вызвать при поступлении данных {{{ this.fun(this.getc()); }}} минусы -- сложно отследить появление и пропадание устройств в системе. по сути за этим в данном случае должен следить каждый драйвер, а не система;
  # для всех символьных интерфейсов как свойство объявляем структуру 
{{{
     typedef struct io_charcontext {
         FILE stdin,stdout;
     } io_charcontext_t;
}}} 
таким образом к любому устройству привязан поток и понятно куда девать данные по мере поступления. Но в данном случае ядро должно обрабатывать прерывание от устройства, что бы инициировать обработку потока устройством, которому поток собственно предназначается.

Вполне возможно, что в системе окажутся не только символьные устройства. 
  {{{ typedef enum { DT_EMPTY , DT_CHAR , DT_BLOCK } dev_type; }}}
Кстати, {{{ dev_empty }}} можно вполне использовать, как список свободных дескрипторов (что бы в начале пула лежал всегда {{{ dev_empty_t }}} и указывал на список,
т.к. список в массиве, можно обойтись без указателей, а лишь индексами {{{ next }}} )
{{{ 
typedef struct dev_empty {
    int next; // may be better use FILE
} dev_empty_t; 
}}}

Собственно один из вариантов интерфейса символьного устройства:
{{{ 
typedef struct dev_char {
    // interface
    void (*putc)(void *context, int ch);
    int (*getc)(void *context); 
    // context
    void *context;
    // outside context
    io_charcontext_t io;
} dev_char_t; 
}}}
(Но здесь никак не фигурирует обработчик прерывания, вероятно он лежит внутри драйвера, (может быть массив из пар дескриптор устройства, обработчик))

Возможно имеет смысл завести какие то флаги для устройств обозначающие права на то, что мы с ними можем делать или т.п.
{{{
typedef int dev_flags;
 /** example 1 write 2 read ... e.t.c. */
}}}

Как вариант описания абстрактного устройства в системе:
{{{
typedef struct device {
    dev_type type;   
	dev_flags flags;
    // info
    char *info;
    
	union {
		dev_empty_t em;
		dev_char_t  ch;
		dev_block_t bl;
		. . .
	} dev;
} device_t;
}}}
   
Пул устройств:
{{{ device_t devices[MAX_DEVICES_COUNT]; }}}

==Что для этого нужно==

===Макро определения===

Было бы неплохо сделать для всех драйверов сделать регистрацию в системе при помощи макросов схожую с модулями. Т.е. что-то наподобие 
{{{ EMBOX_DRIVER( load , probe , unload ) }}} где load, probe, unload соответствующие функции.
  * load инициализирует драйвер (допустим выделяет зануляет память)
  * probe опрашивает систему, регистрирует устройства, которыми управляет этот драйвер
  * unload соответственно уничтожает устройства, освобождает память

(Поначалу можно обойтись модулями на runlevel==1 где probe будет находиться внутри start_mod)

===Probe и регистрация устройства===

Очевидно, что драйверу необходимо предоставить интерфейс для регистрации устройств (или как вариант, что бы probe возвращала список из устройств, но,
кажется, первое предпочтительнее).
Вариант интерфейса:
{{{
device.h
  device_t *get_device_mem(); /* get_device_empty() ? */
  FILE device_add( device_t *ptr );
  void device_del( device_t *ptr );
}}}

Реализация данной штуки посредством списков, как упомянуто ранее, вопросов не вызывает :)

Канонический probe() может выглядеть как-то так:
{{{
int probe() {
	int ret = 0;
	FILE f;
	for ( ; has_next_device() ; ++ret ) {
		device_t dev = get_device_mem();
		memset( device_t , sizeof(struct device) , 0 );
		dev.type = DT_EMPTY;
		. . .
		f = device_add( dev );

		pool_of_dev_in_driver[ podid_s++ ] = { f , kernel_handler_irq( f , ... ) } /* не совсем код, но идея понятна */
	}
}
}}}

===Init.d/main/или как-то так===
В конечном итоге получим массив символьных устройств связанных по умолчанию с /dev/null. Останется лишь их привязать к необходимым и в нужном порядке.
Для этого можно реализовать системный вызов или команду, допустим bind
{{{ void bind ( FILE from, FILE to ) }}} 
работа которой сведется просто к
{{{
	devices[to].ch.io.stdin = from;
	devices[from].ch.io.stdout = to;
}}}
запуск которой можно вложить в модуль инициализации или скрипт или куда еще.

=Возвращаясь к исходной задаче с терминалом=
все будет выглядеть так: в исходниках появляется драйвер символьного устройства терминал (probe вполне может создать более одного), регистрируется
символьное устройство gaisler/uart, запускается модуль инициализации, который связывает их друг с другом.

все это написано Just for fun, но мне показалось вполне разумным, предлагаю обсудить, и, если нет веских причин считать все это нерабочим, могу начать
реализовывать device.h/c 