#summary Description driver subsystem for users and driver's developers.
#labels Phase-Design,Phase-Implementation

=Driver subsystem in embox=

Находится в *core.kernel.drv_subsys*. Включается по `option(DRIVER_SUBSYSTEM)`. Интерфейсы: `driver.h`, реализация: `kernel/driver.c`. Пример-реализацию канонического устройства можно найти в `src/drivers/char/zero.c` (`/dev/zero`).

==Устройства==

Устройством в нашей системе может являться абсолютно все, для чего может быть написан драйвер, реализующий указанный ниже интерфейс. (Например файлы, терминалы, дисплеи, коврик мыши)

=Интерфейс утсройств=

Было принято соглашение, что драйвер каждого устройства должен реализовывать следующие методы взаимодействия с устройством:
{{{
typedef struct device_ops {
        int (*open)  ( device_t *dev , int mode );
        int (*close) ( device_t *dev );
        int (*read)  ( device_t *dev , char *buf    , size_t n  );
        int (*write) ( device_t *dev , char *buf    , size_t n  );
        int (*ioctl) ( device_t *dev , io_cmd c     , void *arg );
        int (*devctl)( device_t *dev , device_cmd c , void *arg );
} device_ops_t;
}}}

==Драйвера==

Каждый драйвер, по своей сути является реализацией трех функций:
{{{
int mydriver_load( driver_t *drv );
int mydriver_probe( driver_t *drv , void *arg );
int mydriver_unload( driver_t *drv );
}}}

====mydriver_load====
Вызывается с указателем на структуру (память уже выделило ядро), в которую драйвер должен записать информацию о себе, а так же инициализировать указатели на методы обращения к устройствам.

====mydriver_probe====
Данная функция вызывается если система предполагает наличие устройства, которое может обрабатываться данным драйвером. Т.е. при вызове драйвер должен попытаться зарегистрировать устройство. Параметр arg необходим, если мы, например, хотим запросить у драйвера файловой системы, зарегистрировать файл.

*TO-DO* Не придуманы коды возврата для этой и большинства других функций.

====mydriver_unload====
При вызове этой функции драйвер должен корректно выгрузить устройства и освободить приватные поля.

К сожалению, у нас пока нет отдельного фреймворка для драйверов и пока используется система модулей. Т.е. функции `_load` и `_probe` заворачиваем в `_start`, а `_unload` в `_stop`:
{{{
static int mydriver_start(void);
static int mydriver_stop(void);
}}}
Регистрируем так: {{{EMBOX_UNIT(mydriver_start,mydriver_stop)}}}

===Как драйвер регистрирует устройство===
Для регистрации у удаления устройств из системы драйвер должен использовать следующие функции:
{{{
device_t*   device_create( driver_t *this , const char *name , device_flags flags , size_t private_s );
int         device_destroy( device_t *dev );
}}}

==С точки зрения прикладного программиста==
Для использования на данный момент доступен следующий интерфейс:
{{{
device_desc device_select( const char *desc );  

int device_open  ( device_desc dev , int mode );
int device_close ( device_desc dev );
int device_read  ( device_desc dev , char *buf    , size_t n  );  
int device_write ( device_desc dev , char *buf    , size_t n  );  
int device_ioctl ( device_desc dev , io_cmd c     , void *arg );
int device_devctl( device_desc dev , device_cmd c , void *arg );
}}}
Где `device_select` предоставляет возможность получить по строке описания (которую устанавливает драйвер при регистрации устройства) получить дескриптор. Назначение следующих функций интуитивно понятно.

==IO CONTEXT (same magic features)==
Есть так же нереализованная идея взаимодействия устройств напрямую, посредством установления контекста ввода/вывода. `option(DEV_IO_CONTEXT)`

Для этого можно реализовать системный вызов или команду, допустим bind:

{{{ 
void bind ( FILE from, FILE to ) 
}}} 

работа которого сведется просто к
{{{
	devices[to].ch.io.stdin = from;
	devices[from].ch.io.stdout = to;
}}}

И тогда, без взаимодействия сторонних приложений, напрямую можно было бы перенаправлять потоки данных с одного устройства на другое.

==Оставшиеся структуры и интерфейсы==

{{{
/*
 * this interface for char device will not support fseek (call ioctl with some argument)
 * but it may be common interface for all devices
 */
typedef struct device_ops {
    int (*open)  ( device_t *dev , int mode );
    int (*close) ( device_t *dev );
    int (*read)  ( device_t *dev , char *buf    , size_t n  );
    int (*write) ( device_t *dev , char *buf    , size_t n  );
    int (*ioctl) ( device_t *dev , io_cmd c     , void *arg );
    int (*devctl)( device_t *dev , device_cmd c , void *arg );
} device_ops_t;
}}}

{{{
struct io_context {
    device_desc in, out; /* FILE in, out; */
};
}}}

{{{
/*
 * device information, that accessible for kernel
 */
struct device {
    const char          *desc;      /* char description of device */
    device_flags        flags;      /* some flag, allows read/write or some operations? */
#ifdef CONFIG_DEV_IO_CONTEXT
    io_context_t        ioc;        /* in/out context */
#endif
    driver_t            *driver;    /* driver, that controlled its device */
    size_t              private_s;  /* description of private data */
    void                *private;
};

}}}


{{{
/*
 * description of device's drivers
 * generate by kernel on stage of registry driver in system. Macross EMBOX_DRIVER?
 */
struct driver {
    const char      *name;      /* name of driver */
    device_ops_t    ops;        /* interface of device, that controlled by this driver */
    driver_flags    flags;      /* some flag of driver */
    size_t          private_s;  /* size of private data */
    void            *private;   /* private data */

    int (*load)  ( driver_t *this );            /* init of driver, allocate memory and other */
                                                /* return 0 or -ERR */

    int (*probe) ( driver_t *this , void *arg); /* find more devices in system and registry they */
                                                /* arg need for send driver some information, for
                                                    example about path to file for driver of file system
                                                    in order that create device of specific file */
                                                /* return count of new devices or -ERR */

    int (*unload)( driver_t *this );            /* free devices and memory */
                                                /* return 0 or -ERR */
};

}}}

Канонический probe() может выглядеть как-то так:
{{{
int probe() {
	int ret = 0;
	FILE f;
	for ( ; has_next_device() ; ++ret ) {
		device_t dev = get_device_mem();
		memset( device_t , sizeof(struct device) , 0 );
		dev.type = DT_EMPTY;
		. . .
		f = device_add( dev );

		pool_of_dev_in_driver[ podid_s++ ] = { f , kernel_handler_irq( f , ... ) } /* не совсем код, но идея понятна */
	}
}
}}}