#summary Описание работы машины состояний потока.

=Машина состояний потока=

Состояние потока может измениться в следствии совершения над потоком или самим потоком какого-либо действия. Все действия планировщика происходят атомарно. Атомарность обеспечивается различными блокировками в зависимости от конкретного действия. Каждое действие планировщика отражается на состоянии потока. На протяжении жизни потока его состояние может меняться достаточно много раз.

Если не вдаваться в детали реализации, у потока условно можно выделить пять состояний, а модель процесса перехода от состояния к состоянию можно представить следующей машиной состояний.

http://embox.googlecode.com/svn/wiki/images/Scheduler/StateMachine.png

Во время инициализации поток получает состояние init до тех пор, пока его не запустят функцией thread_launch() (см. раздел Запуск потока). Тогда поток переходит в состояние ready, то есть помещается в очередь runq и готов к исполнению. Затем, когда приходит его очередь в зависимости от стратегии планирования, поток переходит в состояние run и начинает исполняться. Если поток не успел закончить исполнение в отведенный ему квант времени, планировщик снова помещает его в runq и передает ресурсы процессора другому потоку, поток теперь в состоянии ready до тех пор, пока снова не придет его очередь. Может так получиться, что по истечению кванта времени планировщик не передает управление другому потоку, а оставляет текущему. Тогда он просто остается в состоянии run. Поток во время исполнения может уснуть до тех пор, пока не произойдет ожидаемое событие, и его не разбудят. В этом случае потоку присваивается состояние wait, в runq поток уже не помещается, ресурсы процессора передаются следующему в очереди потоку. Тут нужно отметить, что об уснувшем потоке планировщик ничего не знает. Как правило, поток находится в очереди waitq, например, мьютекса. Подробнее этот процесс описан в разделе Интерфейсы ожидания событий. Когда кто-то будит поток, он из состояния wait переходит в состояние ready, и дальше все происходит по уже известному сценарию. Последнее состояние - это состояние exit. В него поток попадает, когда заканчивает свое исполнение.

==Реализация состояний в Embox==

Отметим, что представленное выше описание машины состояний это лишь основная идея. В Embox состояния потоков представляются тремя полями:
  * active - запущен на процессоре
  * ready - находится под управлением планировщика, т.е. лежит в runq или запущен на процессоре
  * waiting - ожидает какого-то события

Состояние потока характеризуется комбинациями букв A, W и R. Например, если поток исполняется в данный момент, то его состояние - это AR. Если поток готовиться к ожиданию, то его состоянием становится ARW. Будем говорить, то мы “добавили W”. Если систояния из AR переходит в R, то будем говорить, что мы “сняли A”.

===Случай 1. Нет ожиданий, два потока выполняются параллельно===
Рассмотрим простой  вариант развития событий. Пусть поток A создает два потока B и C с одинаковым приоритетом, запускает их и заканчивает свою работу. Два потока выполняются параллельно с одинаковым приоритетом, то есть планировщик передает ресурсы процессора то одному, то другому потоку.

http://embox.googlecode.com/svn/wiki/images/Scheduler/StateMachineExample1.png

Вертикальными прерывистыми чертами показаны моменты перехода ресурсов процессора от одного потока к другому, то есть произошло перепланирование.

Видно, что при инициализации и завершении потоки имеют состояние W. При инициализации это происходит потому, что с точки зрения планировщика пробуждение и запуск - один и тот же процесс. Состояние W у завершившего свое исполнения потока связано с освобождением ресурсов, про это можно прочитать раздел Управление ресурсами.

Активное состояние - это AR, а когда пометка A снимается, поток помещается в runq и ждет, когда планировщик передаст ему управление.

===Случай 2. Есть ожидание, события приходит после того, как поток уснул===

Посмотрим, что происходит, когда поток ждет события. Причем событие приходит после того, как поток уснул и передал управление планировщику. На это нужно обратить особое внимание, так как существуют крайние случаи, о них речь пойдет ниже.

http://embox.googlecode.com/svn/wiki/images/Scheduler/StateMachineExample2.png

Красным обозначены моменты, когда выполняются функции планировщика.
Состояние ARW переходное, означает, что поток готов к ожиданию. После того, как потоку выставили это состояние, он передает управление планировщику (темно-зеленый цвет). Планировщик видит, что поток хочет ждать, снимает R. Можно воспринимать это так, что он снимает с себя “ответственность” по управлению этим потоком. Когда планировщик передает ресурсы процессора другому потоку, он также снимает A. Теперь поток ждет.
Приходит событие, поток будят функцией sched_wakeup(). Происходит то же самое, что и при запуске нового потока, то есть поток помещается в runq, состояние меняется на R.

===Случай 3. Есть ожидание, событие приходить до того, как поток уснул===

Этот случай, на самом деле, даже проще, чем предыдущий. Поток уже подготовился к ожиданию, проверил, что событие еще не пришло, и готов уже передать управление планировщику, но тут происходит прерывание. Тут возможны варианты, пусть, например, обработчик прерывания вызвал то самое событие, что “разбудило” поток. Потом управление передается обратно нашему потоку, и он вызывает перепланирование.

http://embox.googlecode.com/svn/wiki/images/Scheduler/StateMachineExample3.png

В этом случае функция sched_wakeup() видит, что поток все еще под управлением планировщика, то есть стоит R, и просто снимает выставляет в waiting значение false. Таким образом, когда поток вызывает перепланирование, происходит то же самое, как если бы ожидания вообще не было.
