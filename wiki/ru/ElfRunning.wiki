#summary Как исполнять elf файлы в Embox.

<wiki:toc max_depth="2"/>

= Описание =

Файл формата ELF состоит из следующих частей:

  * Заголовок ELF файла
  * Таблица программных секций (в объектных модулях может отсутствовать)
  * Секции ELF файла
  * Таблица секций (в выполняемом модуле может отсутствовать)

заголовок файла:

{{{
#define EI_NIDENT 16

struct elf32_hdr {
    unsigned char e_ident[EI_NIDENT];
    Elf32_Half e_type;
    Elf32_Half e_machine;
    Elf32_Word e_version;
    Elf32_Addr e_entry;  /* Entry point */
    Elf32_Off e_phoff;
    Elf32_Off e_shoff;
    Elf32_Word e_flags;
    Elf32_Half e_ehsize;
    Elf32_Half e_phentsize;
    Elf32_Half e_phnum;
    Elf32_Half e_shentsize;
    Elf32_Half e_shnum;
    Elf32_Half e_shstrndx;
};
}}}

== Что делать ==

В Embox можно выполнять elf файлы. На данный момент опция протестирована для microblaze (но там есть проблема, что у нас нет многопоточности, следовательно, запускаемый файл нельзя запускать в новом потоке и система исчезнет). На sparc единственная проблема пока что в том, что неизвестно, как помещать в память файл и узнавать его местоположение там. А в принципе работать должно.

Выполнение файла совершается командой
{{{
runelf -a addr
}}}
где addr - адрес выполняемого файла в памяти.

Естественно, файл должен быть скомпилирован под платформу, на которой будет запускаться.

== Пример ==

Собственно, как проходило тестирование.

Был создан template microblaze->piggy_embox (он и будет запускаться командой, назовем его подчиненным). Важно то, что  sdram у него устанавливается 0x45000000, в то время, как "главный" (вызывающий) Embox загружается по адресу 0x44000000.
Сначала на плату заливался подчиненный бинарник по адресу 0x46000000, причем подавался не как elf, а как data file. Потом загружался главный. В командной строке у него вводилась строка
{{{
runelf -a 0x46000000
}}}
После этого уже выполняется piggy_embox.