#summary Описание примера "Движение вокруг коробки"

== Общее описание ==
 Поставьте робота рядом с коробкой, таким образом, чтобы дальномер был направлен на коробку. Нажмите произвольную кнопку на роботе. Робот определит расстояние до коробки и начнет двигаться вокруг коробки, сохраняя это расстояние. Движение происходит до тех пор, пока не будет нажата произвольная кнопка на роботе.
 
== Подготовка к запуску ==
=== Робот ===
==== Необходимые части ====
 * NXT Brick
 * 3 сервомотора
 * дальномер
==== Сборка ====
 Соберите стандартного гусеничного робота по схеме, прилагаемой к Вашему конструктору Lego Mindstorms NXT. Закрепите сбоку датчик касания таким образом, чтобы он располагался параллельно земле и смотрел вбок.
=== ПО ===
==== Код примера ====
Исходный код примера находится в файле `/platform/lego_nxt/tests/box_around/box_around.c`.

В верхней части файла объявляем, к  каким портам робота подключены датчики:
{{{
	#define SONAR_PORT (&sensors[1])
	#define MOTOR0 (&motors[0])
	#define MOTOR1 (&motors[1])
}}}
В нашем случае два мотора подключены в порты A и B и дальномер подключен в порт 2.

Алгоритм движения робота реализован в функции {{{box_around_test}}}. Рассмотрим подробнее, что она делает.
Вначале инициализируем датчик-дальномер и моторы
{{{
	sonar_sensor_init (SONAR_PORT);
	
	motor_start(MOTOR0, 0, 360, NULL);
	motor_start(MOTOR1, 0, 360, NULL);
}}}

Ждем, пока пользователь нажмет на кнопку, что означает "старт"
{{{
	while (!nxt_buttons_was_pressed()) {
	}
}}}

Считываем показания датчика-дальномера, для того чтобы определить на каком расстоянии мы будем объезжать коробку. Показываем это расстояние на экране робота.
{{{	
	sonar_treshold = sonar_sensor_get_val(SONAR_PORT);
	printf ("distance is %d\n", sonar_treshold);
}}}

Высчитываем параметры, необходимые для движения робота
{{{
	int mp0 = MOTOR_POWER * sonar_treshold / (sonar_treshold + ROBOT_WIDTH);
	int mp1 = MOTOR_POWER;
}}}

Запускаем алгоритм движения. Пока пользователь не нажмет кнопку будет выполняться тело внешнего цикла.
Общая логика работы примера такая: едем по прямой, пока мы не достигли угла коробки. Как только достигли угла,
начинаем поворачивать. Продолжаем движение по прямой после поворота.
Этот алгоритм реализован следующим образом: мы непрерывно считываем расстояние до коробки функцией {{{sonar_sensor_get_val(SONAR_PORT)}}}.
Если оно мало отличается от нужного, едем по прямой {{{move_start}}}. Иначе начинаем поворот {{{rotate_start(mp0, mp1}}} и поворачиваем
до тех пор, пока расстояние не станет мало отличаться от нужного нам.

{{{
	while (!nxt_buttons_was_pressed()) {
		while (abs(sonar_sensor_get_val(SONAR_PORT) - sonar_treshold) < 3) {
			move_start();
		}
		move_stop();

		while (abs(sonar_sensor_get_val(SONAR_PORT) - sonar_treshold) >= 3) {
			rotate_start(mp0, mp1);
		}

		move_stop();
	}
}}}
Вспомогательные функции {{{move_start}}}, {{{move_stop}}}, {{{rotate_start}}} подают нужную мощность на двигатели робота.

В верхней части файла находится строчка {{{EMBOX_TEST(box_around_test)}}}, которая регистрирует функцию {{{box_around_test}}} в системе.
==== Сборка ====
 В консоли перейдите в корневую папку проекта. Выполните
 {{{
 	make PROJECT=arm PROFILE=nxt_box_around config
 	make
 }}}
 В ходе сборки в консоль выводятся информационные сообщения. В случае успешной сборки выведется
 {{{
 	Build complete
 }}}
==== Загрузка ====
 Результатом сборки является образ `/build/base/bin/embox.bin`. Загрузите его как описано [PlatformLegoNxtFlashing здесь].