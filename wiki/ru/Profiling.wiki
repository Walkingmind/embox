#summary Использование профилировщика

<wiki:toc max_depth="2">

= Профилирование =

В Embox имеется инструментирующий профилировщик, использующий возможности [https://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Code-Gen-Options.html возможности GCC]. 

Есть возможность профилировать время работы либо сразу всех функций системы, либо функций из определённого исходного файла.

== Профилирование всей системы сразу" ==

Обратите внимание, что при профилировании всей системы сразу возрастут накладные расход.
Для профилирования всей системы сразу потребуется собрать проект с нужными флагами. Для этого нужно добавить в файл `./conf/build.conf` следующую строчку:
{{{
CFLAGS += $(PROFILING_CFLAGS)
}}}

После этого нужно пересобрать систему.

== Профилирование функций из определённого файла ==

Для профилирования функций из определённого файла необходимо найти файл Mybuild, который ему соответствует. Это должен быть файл с расширением *.my. В этом файле перед строкой `source my_source.c` нужно добавить следующую строку `@InstrumentProfiling("true")`. Должно получиться что-то вроде:

{{{
package embox.cmd

@Cmd(name = "hw", help = ,man = """")
module hw {
    @InstrumentProfiling(true)
    source "hw.c"
}
}}}

После этого нужно пересобрать систему.

== Сбор профилировочной информации ==

Можно включить сбор профилировочной информации с помощью команды `tbprof -e`, и затем запускать программы, время работы которых нужно замерять. По окончании исполнения нужных программ нужно исполнить `tbprof -d` для прекращения сбора профилировочной информации.

Выполнение команды `tbprof -c CMD -a -b -c` эквивалентно последовательному выполнению команд
{{{
tbprof -e
CMD -a -b -c
tbprof -d
}}}

Выполнение команды `tbprof -n M -c CMD -a -b -c` - это сбор информации о M запусках команды CMD. Например, можно запустить тест, идущий под первым номером, 1000 раз:
{{{
tbprof -n 1000 -c test -n 1
}}}

Обратите внимание: при каждом включении сбора профилировочной информации старая информация удаляется.

Уже собранную информацию можно выводить с помощью следующей команды:
{{{
trace_blocks -f STR -n M
}}}
Где флагом -f указывается фильтр на функции, которые в своём полном имени (вида path/to/source/source.c:func_name) содержат STR в качестве подстроки, а флагом -n указывается количество функций, которые нужно вывести.

Например: 
{{{
trace_blocks -n 15
}}}
или
{{{
trace_blocks -f sched -n 15
}}}

