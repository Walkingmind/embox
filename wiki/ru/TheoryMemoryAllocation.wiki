#summary Описание алгоритмов динамического выделения памяти

<wiki:toc max_depth="4" />


= Описание =

Алгоритмы выделения памяти используется для управления участками памяти,
выделенными под объекты в ходе выполнения программы.

Данные алгоритмы применяются для выделения памяти под объекты различных типов.
Например, под динамические объекты с заранее неизвестным размером, под таблицы
виртуального режима, под множества объектов одинаковой природы и размера (скажем
дескрипторов сетевых пакетов) и т.д.

Память может выделяться не только под объекты данных, но и под инструкции
некоторого процесса. В этом случае целесообразно применять
[VirtualMemory режим виртуальной памяти], позволяющий изолировать адресные
пространства процессов друг от друга. Для работы с
[VirtualMemory виртуальной памятью] характерно выделение памяти по страницам.

Для различных типов объектов характерны различные требования к памяти, поэтому
используются различные стратегии выделения. Это позволяет повысить эффективность
работы программы в целом.

При реализации той или иной стратегии обычно определяют ее эффективность по
следующим параметрам:
 * Область применения алгоритма (в каких ситуациях наиболее выгодно применение, в каких - неприменим)
 * Время поиска подходящего блока памяти
 * Время освобождения (возврата системе) блока памяти
 * Фрагментарность памяти (внутренняя и внешняя) и ее влияние на скорость работы

Данные алгоритмы обычно реализуются на уровне операционной системы. Все они могут
быть отнесены к сервису "Динамическое распределение памяти". Здесь рассматриваются
несколько стратегий выделения памяти для различных задач.

= Реальный и виртуальный режимы работы памяти =

Как уже упоминалось, операционная система может работать с использованием
[VirtualMemory виртуального режима], а может запускать процессы в реальном режиме
(по реальным физическим адресам). Виртуальный режим применяется в большинстве
современных ОС и поддерживается на аппаратном уровне всеми современными
процессорами, поскольку существенно упрощает механизмы выделения и изоляции
памяти.

Но существует ряд вычислительных систем, в которых данный механизм может быть
избыточен. К таким системам можно отнести системы реального времени, у которых
на момент компиляции ПО уже известна адресная карта всех процессов (потоков),
которые будут работать в системе. В таких системах часто не нужно иметь механизм
выделения памяти под код ПО, и объекты зачастую можно выделять статическим
способом. Но даже в таких системах целесообразно иметь механизм динамического
выделения памяти.

В виртуальном режиме необходим механизм выделения страниц и групп страниц.
При этом такой механизм должен разделять память, выделяемую для системы, и память,
занятую диспетчером страниц. Поскольку в таком случае нужно было бы замэпировать
всю доступную память в таблицах виртуальной памяти, это вызвало бы постоянную
подкачку памяти с данными о страницах.
С другой стороны, многие диспетчеры виртуальной памяти реализуют malloc через
механизм выделения и добавления страниц. Это удобно даже в реальном режиме работы,
поскольку тогда данные страницы могут перераспределяться между разными процессами.

= Типы выделения памяти =

Все алгоритмы для управления областями памяти можно отнести к нескольким
категориям, по типам объектов, с которыми они оперируют:

 # Объекты одного типа, например *sk_buff*. Для выделения памяти под эти объекты нецелесообразно использовать *malloc*. Так как размер таких объектов постоянен, лучше использовать свой *менеджер объектов*, либо так называемый [http://www.ibm.com/developerworks/ru/library/l-linux-slab-allocator/ slab аллокатор].
 # Объекты определенного размера (например, страницы физической памяти). Для таких объектов наиболее подходят метод битовых масок или алгоритм "близнецов".
 # Объекты произвольного размера и типа (*malloc*). Для таких целей, как правило, применяется [AlgorithmAllocationMemory метод граничных маркеров].

В современных системах используется двухуровневый подход. На нижнем уровне идет
выделение страниц памяти, а на верхнем уровне происходит выделение кусков
произвольной длины. Верхний уровень запрашивает память у системы с помощью
диспетчера страниц. Существуют также системы, которые не нуждаются в нижнем
уровне (диспетчере страниц), это, например, встроенные системы с ограниченными
ресурсами, выполняющие статический набор процессов. В таких случаях диспетчер
памяти может захватить при инициализации отведенное для него пространство и
больше никогда не обращаться к диспетчеру страниц. Также это часто применяется
в системах реального времени, где жертвуют предсказуемостью за счет удобства.

== Менеджер объектов ==

Данный метод подходит для выделения и освобождения большого количества одинаковых
объектов, ограничение на количество заданно на момент компиляции системы.

Под объекты выделяется массив памяти из максимального количества объектов данного
типа, и содержащиеся в нем объекты связываются некоторой структурой данных,
например списком свободных объектов. Тогда выделение объекта - это всего лишь
возвращение ссылки на голову списка, а освобождение объекта - это помещение ссылки
на него в конец очереди свободных объектов.

Данный метод может применяться также в системах реального времени, поскольку
известно что поиск подходящего куска памяти произвольной длины более трудоемкая
задача и требует больших временных затрат.

В качестве доказательства достаточно привести временные результаты следующего
теста. В первом случае происходит выделение с помощью системных функций malloc
или new множества однотипных объектов. Во втором случае однократно выделяется
пул для всех объектов сразу, и с помощью например списка создается список этих
объектов. После этого в программе объекты выделяются из этого списка.
Во втором случае затраченное время будет существенно ниже.

== Slab менеджер ==

Менеджер объектов обладает хорошими временными характеристиками, но достаточно
накладно писать для каждого объекта свой менеджер.  Чтобы избежать дублирования
кода, но сохранить предсказуемость и скорость применяют
[http://www.ibm.com/developerworks/ru/library/l-linux-slab-allocator/ slab allocator].
Основная суть этого метода заключается в частом выделении однотипных объектов,
то есть ситуация описанная в разделе *Менеджер объектов*. Но в отличие него в
системе вводится единый интерфейс для выделения и освобождения  различных
однотипных объектов. Для каждого из этих объектов создается свой пул, а в
системе создается кеш подобных пулов для различных зарегистрированных объектов.

== Метод граничных маркеров ==

В основе метода - двусвязный список всех свободных и занятых блоков памяти.
Как правило, элементами списка являются сами блоки памяти, точнее их "шапки",
называемые маркерами. Модификация списка происходит в несколько простых операций.
Существует несколько алгоритмов поиска свободного блока памяти заданного размера.
Среди них - алгоритм первого соответствия, следующего соответствия, наилучшего
и наихудшего соответствия. Кроме того, можно поддерживать списки блоков для
часто используемых запросов (т.н. алгоритм быстрого соответствия). Предназначен
для выделения блоков памяти произвольной длины. Используется в аллокаторах
общего назначения.

Алгоритм граничных маркеров хорошо подходит под выделение объектов произвольной
длины, для  сегмента же кода обычно используют другие алгоритмы.
Алгоритм описан в книге Дэвида Кнута "Искусство программирование часть 1".

=== Структура ===

Для работы данного алгоритма в каждый свободный блок добавляется два дескриптора
(расположенные в начале и в конце каждого блока) и два указателя (расположенные
в начале блока). На предыдущий и последующий свободные блоки. Таким образом все
свободные блоки соединяются в двунаправленный список, по которому и происходит
поиск подходящего блока для выделения.

При выделении блока памяти помимо запрашиваемой памяти выделяется память под
дескрипторы блоков, точно так же, один дескриптор в начале блока, другой - в
конце. Таким образом выделяемый блок не может быть меньше, чем два указателя,
которые могут понадобиться при освобождении блока под ссылки на предыдущий и
последующий свободные блоки.

Дескриптор блока представляет из себя размер блока и флаг (свободен или занят) в
терминах Кнута (Тэга блока). При использовании структуры, описанной выше,
процессы выделения и освобождения блока приобретают следующий вид:

=== Выделение ===

Берем голову списка и, итерируясь по указателям, ищем подходящий блок. Могут
быть различные стратегии:
 * первый подходящий
 * наилучший подходящий
 * наихудший подходящий - в этом случае берется наибольший блок и от него вырезается требуемый размер.

Первый вариант быстрее, но второй и третий приводят к меньшей фрагментации памяти.

=== Освобождение ===

Основное преимущество данного алгоритма - в скорости освобождения памяти.
Поскольку при освобождении мы знаем адрес освобождаемого блока, на предыдущем
адресе лежит дескриптор блока. Кроме того, если освобождаемый блок не является
крайним, непосредственно слева и справа от него расположены дескрипторы соседних
блоков, содержащую информацию о занятости и размере. Это значительно ускоряет
процесс объединения соседних свободныхот блоков, образовавшихся при освобождении
данного. Таким образом, при освобождении блока проверяется соседний младший
блок (с младшими адресами), и, если он свободен, эти блоки соединяются, а затем
проверяется блок, следующий за освобождаемым, и, если он свободен, блоки тоже
объединяются.

Последней операцией является корректировка указателей в списке. Все склеенные
блоки (если есть) удаляются из списка свободных. Так как применяется
двунаправленный список, операция удаления тривиальна. После этого освобождаемый
блок добавлется в список свободных.

=== Свойства ===

 * Сложность поиска и накладные расходы линейны относительно количества свободных областей

==== Преимущества ====

 * Допускает использование free() без указания размера освобождаемого блока
 * Не требует отдельных структур вне самой кучи
 * Быстрое освобождение памяти
 * Склеивание пустых блоков при освобождении памяти
 * Отсутствие внутренней фрагментации

==== Недостатки ====

 * Маркеры должны присутствовать как в свободных блоках, так и в занятых, что осложняет использование метода при выделении выровненных блоков (например, страниц)

== Bitmap ==

Для представления памяти используется битовая карта, в которой каждому блоку
соответствует один бит. Предназначен для выделения блоков памяти, выровненных по
адресу и длине, например, страниц физической памяти.

=== Свойства ===

 * Сложность поиска и накладные расходы линейны относительно размера памяти

==== Преимущества ====

 * Достаточно прост в реализации
 * Малые накладные расходы по использованию памяти

==== Недостатки ====

 * Не поддерживает освобождение блока памяти без указания его размера, что ограничивает область применения решением достаточно низкоуровневых задач
 * Если использовать для выделения блоков размера, не кратного масштабу карты, возникает внутренняя фрагментация

== Buddy system ==

См. http://en.wikipedia.org/wiki/Buddy_memory_allocation

==== Преимущества ====

 * Чрезвычайно быстр, сложность зависит только от размера запрашиваемого блока
 * Малая внешняя фрагментация

==== Недостатки ====

 * Очень сильная внутренняя фрагментация

== Полезные ссылки ==

http://rtportal.upv.es/rtmalloc/ аллокатор для систем реального времени

http://web.archive.org/web/20070728155440/http://dixx.ru/reference/tlsf - краткий перевод на русский

http://wkaras.webs.com/heapmm/heapmm.html

http://www.iolanguage.com/Library/Papers/MemoryManagement/fragsolved.pdf
