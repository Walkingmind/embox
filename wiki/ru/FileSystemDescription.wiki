#summary Описание файловых систем

<wiki:toc max_depth="1" />

= Introduction =

Под файловой системой понимается сразу два термина, с одной стороны это возможность структурировать файлы по различным папкам и файловым системам (логическая организация), с другой стороны это расположение и формат данных на постоянном носителе (физическая организация).
К тому же иногда файловой сиетемой называют это [FileInterfaceDescription интерфейс работы с файлами] (open, close, read, write, ioctrl), у нас в проекте мы отделяем эти понятия.

Файловая система начинается с корневого каталога, в нем должна быть информация об остальных файловых системах присуствующих в системе. Данная информация может как задаваться статически, так и добавляться в на этапе выполнения программы.
Но если при конфигурации включенна поддержка файловой системы, всегда существует запись о содержимом корневой файловой системы. Это может быть информация о [PartitionsInterfaceDescription разделах на постоянном носителе], либо описание различных файловых систем примонтируемых во время инициализации (например [DevFsDescription devfs], или [InitFsDescription initfs]).

= Description =
В этой части описано устройство виртуальной файловой системы проекта embox.

Каждый файл в представляет собой узел (node) виртуальной файловой системы. Все узлы организованы в иерархию, общая структура которой - дерево.
В корне дерева лежит узел {{{/}}}. Узел описывается специальной структурой
{{{
typedef struct node {
	const char            name[CONFIG_MAX_LENGTH_FILE_NAME];
	//FILE_INFO          *info;
	file_system_driver_t *fs_type;
	struct list_head     *neighbors;
	struct list_head     *leaves;
} node_t;
}}}
Элементы структуры имеют следующее предназначение:
  * name - имя узла в системе
  * info - некая приватная информация о файле
  * fs_type - указатель на драйвер файловой системы, обслуживающей данный узел
  * neighbours - (?) указатель на список содержащихся на том же уровне иерархии в том же поддереве узлов
  * leaves - (?) указатель на список содержащихся на один уровень иерархии ниже узлов, содержащихся в поддереве данного узла

Пример организации файловой системы:
{{{
+--------+      +--------+      +-------+
|   /    | ---> |  dev/  | ---> |  tty  |
+--------+      +--------+      +-------+
                    |               |
                    v               v
                +--------+      +-------+
                |  ram/  |      |  null |
                +--------+      +-------+
}}}

Драйвер файловой системы описывается структурой
{{{
typedef struct file_system_driver {
	const char *name;
	file_op_t *file_op;
	fsop_desc_t *fsop;
} file_system_driver_t;
}}}
Элементы структуры:
  * name - имя драйвера файловой системы
  * file_op - указатель на структуру, описывающую операции, которые могут быть произведены с файлом
  * fsop - указатель на структуру, описывающую операции, которые могут быть произвелены с файловой системой

Для того, чтобы добавить в проект новый драйвер файловой системы, необходимо реализовать все необходимые функции, после чего
зарегистрировать новый драйвер в системе. Это можно сделать с помощью макроса
{{{DECLARE_FILE_SYSTEM_DRIVER}}}
который добавляет описание драйвера в специальную секцию.
Важное замечание: функции драйвера могут быть релоцируемы.

Поясняющий пример:
  Допустим, мы хотим открыть файл /ram/file на чтение. Для этого мы вызываем функцию fopen() в качестве параметров указываем
  необходимые значения.
  Что происходит при этом в системе:
    * fopen разруливает путь к файлу, смотрит драйвер какой файловой системы обслуживает данный файл и вызывает функцию open
	драйвера, передавая ей в качестве аргументов информацию о файле
	* драйвер файловой системы по информации о файле определяет, какую функцию вызвать и запускает её

= Features =

  * Информация о файловых системах может хранится на том же носителе что и программа
  * Можем добавлять файловые системы во время работы
  * Можно не включать файловую систему вообще
  * Можно разбить один носитель в системе на программу информацию о разделах и сами разделы

= Roadmap =