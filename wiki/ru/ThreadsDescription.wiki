#summary Как работать с потоками в Embox.

= Что наши потоки могут =

В системе могут работать несколько потоков (не более 256, включая idle_thread), которые могут поочередно получать доступ к процессорному времени. Они обладают приоритетами и могут находиться в разных состояниях. Для них реализованы следующие механизмы: очередь сообщений, ожидание события и мьютексы.

См. также: [http://code.google.com/p/embox/wiki/RuSchedulers]

= Что есть поток =

Интерфейс потоков описан в kernel/thread.h, реализован он в thread.c. В thread.h описана сама структура потока, содержащая следующие поля 
(исключены поля, имеющие непосредственное отношение к планировщику и совершенно ненужные пользователю):
{{{
struct context context; /* Контекст, соответствующий потоку. Собственно, определяет состояние и действия внутри потока */

void (*run)(void); /* Функция, с которой начинается выполнение потока. */

thread_id_t id; /* Идентификатор потока. Уникален для каждого существующего */
	
thread_priority_t priority; /* Приоритет потока. Чем он выше, тем больше/раньше/чаще поток будет работать. */

thread_state_t state; /* Состояние потока. Возможные значения: 
    THREAD_STATE_RUN    (поток выполняется или готов к выполнению), 
    THREAD_STATE_STOP   (поток либо не запускался, либо удален),  
    THREAD_STATE_WAIT   (поток ожидает какого-либо события), 
    THREAD_STATE_ZOMBIE (поток остановлен, но пока не удален). */

bool need_message; /* Если true, то поток ждет сообщение (state == THREAD_STATE_WAIT). */

queue_t messages; /* Очередь сообщений для данного потока. */

struct event msg_event; /* Это событие происходит, когда поток получает сообщение. Про события см. ниже. */
}}}

= Необходимые функции для работы с потоками =

На примере любого из тестов для потоков можно понять, что работа с потоками сводится к следующему:

== Создание и инициализация ==

Создается указатель на поток: 
{{{
struct thread * thread;
}}}
Выделяется место для стека потока (размер стека выбираете сами, на глаз, чтобы переполнения не было): 
{{{
#define THREAD_STACK_SIZE 0x10000
char stack[THREAD_STACK_SIZE];
}}}
Описывается функция, с которой поток начнет свою работу:
{{{
void run() {
    printf("Hello, World!");
}
}}}
Выделение нового потока и его инициализация делаются следующим образом:
{{{
thread = thread_create(run, stack + THREAD_STACK_SIZE);
}}}
Второй аргумент thread_create - указатель на вершину стека, выделенного под поток.

Добавить в планировщик поток можно, выполнив процедуру
{{{
thread_start(thread);
}}}
Только после этого планировщик начнет замечать этот поток и давать ему процессорное время.

(Подробнее про планировщик: [http://code.google.com/p/embox/wiki/RuSchedulers])

== Приоритеты ==

По велению сердца приоритет - неотрицательное целое число, не превосходящее 256 (вроде, более, чем достаточно). Можно поменять по заявкам.
Приоритет только что созданного потока будет равен единице. Приоритет особого потока idle_thread (бездействие системы, в данный момент совпадает с потоком системы) равен нулю, и менять это значение не рекомендуется. Задавать другому потоку нулевой приоритет не запрещается.

В любой момент перед добавлением в планировщик можно изменить приоритет потока, просто написав 
{{{thread->priority = value;}}}
НО ВАЖНО: нельзя менять приоритет потока, добавленного в планировщик (state == THREAD_STATE_RUN). Это может привести к краху системы или гибели некоторых потоков. Чтобы изменить приоритет такого потока, безопаснее всего сделать следующее:
{{{
thread_change_priority(thread, new_priority);
}}}
Скорее всего, эта функция будет работать, если поток не добавлен в планировщик (это должно обеспечиваться ограничением на _scheduler_remove);

== Удаление потоков ==

Потоки умирают сами, выполнив свою функцию. Также можно остановить (удалить) поток, применив к нему 
{{{
thread_stop(thread);
}}}
Собственно, в конце работы потока вызывается именно эта функция. Она удаляет поток из планировщика и (рано или поздно) освобождает из под него память.

= Дополнительная функциональность =

== События ==

Иногда _текущий_ поток нужно усыпить до наступления какого-то события. Например, в мьютексах и очередях сообщений используется эта возможность. Структура события описана в kernel/thread.h (была необходимость указывать в качестве поля потоку событие, происходящее при получении сообщения). Необходимые для этого функции описаны в kernel/scheduler.h (как непосредственно относящиеся к работе с планировщиком):
{{{
int scheduler_sleep(struct event *event); /* Усыпляет текущий поток и привязывает его к событию event. */

int scheduler_wakeup(struct event *event); /* Пробуждает все потоки, привязанные к событию event. */
// Возвращяют ноль в случае успешного выполнения операции.

void event_init(struct event *event); /* Необходимая инициализация события. */
}}}

== Сообщения ==

Иногда потоку нужно выполнить некоторые действия, но необходимую информацию он может получить лишь от другого потока. Эту информацию он может получить в виде сообщения, у которого есть:
{{{
int type; /* Тип сообщения */

void *data; /* Информация в сообщении. */
}}}
Для того, чтобы хранить приходящие сообщения, у него есть очередь, в которую они кладутся при получении. Если потоку нужно сообщение, то он берет первое сообщение из очереди и обрабатывает его. Если же очередь пуста, то он засыпает и ждет прихода сообщения. При приходе такового он проснется и обработает его.
Методы:
{{{
struct message *msg_new(void); /* Выделить память под сообщение. ВОзвращает указатель на выделенное сообщение. */

int msg_erase(struct message *message); /* Освобождение памяти из-под сообщения. */

void msg_send(struct message *message, struct thread *thread); /* Послать потоку thread сообщение message. */

struct message *msg_receive(void); /* Попытка текущим потоком прочитать сообщение. В случае фэйла засыпает. */
}}}

== Мьютексы ==

Иногда к некоторому ресурсу не могут получать одновременно доступ несколько потоков. В этом случае используются мьютексы. К каждому такому ресурсу привязывается один мьютекс. Когда поток пытается получить доступ, он узнает у мьютекса, заблокирован ли он. Если нет, то поток блокирует мьютекс и продолжает свою работу. В противном случае поток засыпает и встает в очередь внутри мьютекса. Когда мьютекс будет разблокирован занявшим его потоком, если очередь не пуста, мьютекс сразу же занимается неким потоком из этой очереди, который, в свою очередь, пробуждается.

Структура мьютекса и необходимые функции описаны в kernel/mutex.h:
{{{
void mutex_init(struct mutex *mutex); /* Инициализирует мьютекс. Делает очередь пустой. */

void mutex_lock(struct mutex *mutex); /* Блокирует мьютекс текущим потоком. Если мьютекс уже был занят, то усыпляет текущий поток. */

void mutex_unlock(struct mutex *mutex); /* Освобождает мьютекс от текущего потока.
    Возможно, мьютекс сразу же становится занятым некоторым потоком из своей очереди. */
}}}