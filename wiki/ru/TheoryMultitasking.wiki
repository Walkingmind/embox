#summary Обзор типов и принципов построения многозадачных систем 

= Многозадачность =
*Многозадачность* - свойство операционной системы выполнять несколько вычислительных задач одновременно. 

При этом основная задача операционной системы предоставить необходимые ресурсы для выполнения всех выполняемых задач. К таким ресурсам относятся, процессорное время, память, устройства файлы и так далее.

== Распределение процессорного времени ==
=== Однопроцессорные системы ===
Для достижения параллельного выполнения задач на одном процессоре используют принцип псевдопараллельности, время процессора распределяется между всеми задачами. Существуют разные типы псевдомногозадачности:

  * Невытесняющая многозадачность
  * Кооперативная многозадачность
  * Вытесняющая многозадачность

*Невытесняющая* многозадачность является одним из простейших видов многозадачности. В таком случае в системе может быть загружено одновременно несколько задач, но фактически процессорное время выделяется только одной активной задаче. Переключение задач происходит либо когда активная задача заканчивается либо когда она входит в цикл какого то внешнего события. Такой метод планирования использовался раньше, например  в MS-DOS. Сейчас фактически не используется, поскольку активизация той или иной задачи ложится на плечи прикладного программиста, и прикладная задача может захватить процессор на любое время.
Сейчас используются алгоритмы под общим названием *time-sharing* (разделения времени). В этих алгоритмах выделяют специальный модуль в ядре ОС планировщик. Этот модуль занимается распределением времени. К этим типам многозадачности относят кооперативную и вытесняющую (приоритетную) многозадачность.
При *кооперативной* многозадачности текущая активная задача сама отдает свое процессорное время планировщику, и тот уже выбирает следующую активную задачу. Такой метод не безопасен, поскольку прикладной поток может занять все процессорное время. Но он используется, например, в ядре линукса или в POSIX потоках при создании потоков с флагами SCHED_RR или SCHED_FIFO, а также в Windows. В Windows время получает задача которой прислали сообщение, и пока она его не обработает она не вернет время планировщику. Такой метод очень просто реализуется и является эффективным с точки зрения ресурсов, но он перекладывает ответственность за эффективное управление процессорным временем на плечи разработчика, поэтому применяется в хорошо проверенных местах.

При *вытесняющей* многозадачности планировщик выделяет квант времени каждой задаче. По истечению кванта планировщик приостанавливает выполнение задачи, осуществляет поиск следующей задачи, которой и передает следующий квант. Процесс поиска называется планированием, и он может быть произведен по различным алгоритмам. Эти алгоритмы принято называть стратегией планирования. Выделяют два типа планирования
 * Статическое
 * Динамическое
Большинство систем построено по принципу динамического планирования, то есть система во время работы в зависимости от ситуации решает какой задаче отдать процессорное время. При статическом же планировании процент задаче задается процент предоставляемого времени или приоритет задачи. В зависимости от этих установок планировщик и принимает решение какой задаче предоставить право выполнения. Этот подход используется например в виртуальных машинах, а также с системах жесткого реального времени, где необходима математическая верификация времени выполнения задачи.

=== Многопроцессорные/Многоядерные системы ===
При наличии нескольких ядер (процессоров) потенциально можно достигнуть реального параллельного выполнения задач, для этого каждой задаче необходимо присвоить собственное ядро выполнения. Но в современных системах количество выполняемых задач существенно выше чем количество процессорных ядер, к тому же поскольку фактически все задачи требуют синхронизации с внешними событиями, и следовательно они большое время находятся в спящем режиме (в ожидании события), то неэффективно было бы отводить для каждой задачи свое ядро, гораздо эффективнее было бы использовать все время существующих ядер, как было показано выше.
В зависимости от распределения задач по процессорным ядрам, поддержку планировщиком многопроцесорности делят на следующие типы.
  * *SMP* - симметричная многопроцессорность. Планировщик выделяет квант времени для задачи на любом из процессоров. Прерывания также выполняются на любом из процессорных ядер.
  * *AMP* - асимметричная многопроцессорность. Планировщик выполняет задачи на определенном процессорном ядре, например, обработку прерываний или какие-либо системные задачи. 
  * *BMP* - ограниченная (задаваемая) многопроцессорность. Планировщик может выполнять задачи на определенном ядре или на определенном множестве процессорных ядер. При этом задачи могут мигрировать между процессорными ядрами. В отличие от SMP, можно назначить для конкретной задачи свое процессорное ядро выполнения.



== Распределение ресурсов ==

Кроме процессорного времени, существуют другие ресурсы, за которые борются различные задачи, например устройства, или доступная память. Например, даже для реализации невытесняющей многозадачности, необходимо, где то хранить код активизируемых задач, а также необходимые для каждой задачи переменные.

Поток управления программы (код который выполняется на процессоре) принято называть нитью или потоком (thread), а контейнер, который описывает ресурсы предоставленные тому или иному экземпляру программы задачей (task).

Таким образом, задача является контейнером для ресурсов и содержит в себе список нитей, описание доступных областей памяти, список индексных дескрипторов (файлов, каналов, ..), mutex-ы и другие средства синхронизации.

Потоку также необходимы ресурсы, как минимум структура потока должна иметь собственный стек стек исполнения, а также слово состояния

== Синхронизация и средства взаимодействия ==
