#summary Описание алгоритма работы с памятью

<wiki:toc max_depth="2" />

= Что это =
Алгоритм *page alloc*, предназначен для выделения/освобождения из пула по одной странице. В силу специфики алгоритма, говорят, он не рекомедуется для работы в виртуальном режиме.

= Описание = 
Алгоритм реализован на том, что в каждом свободном блоке (множестве подряд идущих еще/уже не выделенных страниц) находится структура, которая указывает на следующий и предыдущий пустой блок. Список замыкается, и, таким образом, мы имеем кольцевидную структуру, которая описывает всю свободную память. В конечном итоге выделение/освобождении отдельной страницы сводится к модификации этого списка.

= File list =
./src/include/lib/page_alloc.h
./src/lib/page_alloc/page_alloc.c
./src/tests/page_alloc/test_page_alloc.c
./extend_test/page_alloc/config.h
./extend_test/page_alloc/test_page_alloc.c

= Интерфейс =
В режиме компиляции под Embox доступно:
  * void`*` page_alloc() 
  * void page_free(void`*` )

В режиме компиляции для тестирования под хост машиной:
  * void`*` page_alloc()
  * void page_free(void`*` )
  * PAGE_SIZE
  * PAGE_QUANTITY
  * get_cmark_p() возвращает указатель на кольцевую структуру описывающую свободную память.
  * page_alloc_init() нужна для принудительной инициализации аллокатора.

= #DEFINE's =
* EXTENDED_TEST собственно указывает на то, что компилим под хост
* PAGE_SIZE, PAGE_QUANTITY размер, кол-во страниц соответственно. При компиляции под Embox берутся значения описанные в page_alloc.c, если же компилируем под хост-машину, значения берутся из page_alloc.h.

config.h
  * DONOTUSE_PAGE_ALLOC для тестирования тестировщика (вроде никому кроме меня не должно понадобится)
  * INTERACTIVE_TEST интерактивное тестирование, вместо случайного генерирования тестов
  * VERBOSE_DEBUG_OUT вывод дополнительной информации, например такой как, списочной структуры описывающей свободную память после каждого теста.
  * STACK_POP_FROM_HEAD меняет порядок удаления при тестировании. (имеет смысл держать отключеной)
  * TEST_COUNT кол-во тестов.
  * MAX_PAGE_FOR_ALLOC максимальное кол-во страниц которое мы хотим, что бы могло запрашиваться каждым тестом.

= USE = 
Для нормальной работы, необходимо выставить правильные значения PAGE_SIZE, PAGE_QUANTITY, START_MEMORY_ADDR (начало пула) в page_alloc.c

=mpalloc=

===Описание===

mpallocator.h предоставляет интерфейс для выделения и освобождения участка памяти кратного нескольким страницам.
 * {{{ void *mpalloc( size_t cp ) }}} выделяет cp страниц из пула и возвращает указатель на начало блока;
 * {{{ void mpfree( void *ptr ) }}} возвращает непрерывный блок из страниц системе по указателю на его начало.
Для использования необходимо добавить в зависимости модуль embox.hal.mm.mpallocator. ({{{$_DEPS += embox.hal.mm.mpallocator}}})

===Реализация===
Алгоритм используемый в системе является вариацией на тему "алгоритма близнецов" (mpallocator_buddy.c). 

В начале пула выделяется несколько страниц под дерево, которое хранит информацию о разбиении пула на страницы размера 2`^`n. Каждой странице ставится в соответствие байт памяти, в котором могут выставляться некоторые биты. Они означают:
 * 1 -- левое поддерево не пусто;
 * 2 -- правое поддерево не пусто;
 * 4 -- все поддерево зарезервировано (не осталось невыделенных участков);
 * 8 -- блок соответствующий этой вершине изначально целиком не влазил в пул (бывает верно для некоторых правых блоков).
Дерево является полным бинарным и строется на простых соображениях: индекс корня -- 1, индекс левого ребенка -- 2`*`n, индекс правого -- 2`*`n`+`1. Вершина в корне означает участок памяти равный 2`^`n страниц памяти таких, что 2`^`(n`-`1) страниц от начала пула помещается целиком. Далее блок делиться пополам и получившимся участкам ставятся в соответствие дочерние вершины текущей, так продолжается до тех пор, пока не дойдем до блоков размера 1 страницы.

Поиск подходящего свободного осуществляется сверху-вниз по дереву, изходя из меток и размера необходимой памяти. Найдя подходящий блок очевидным образом обновляем метки (поднимаясь вверх, так что ниже в дереве останутся вершины без меток). 

При освобождении находим блок, соответствующий адресу блок размера одной страницы (он будет равен сумме кол-ва страниц от начала пула до указателя и размера корневого блока), далее идем вверх по дереву пока не встретим блок с меткой 4, этот блок и будет искомым, соответствующим той области памяти, что мы хотим освободить. Следующим шагом проходя по дереву вверх вновь обновляем метки (необходимости проверять близнецов нет, так как если, допустим, правое поддерево свободно, то и соответствующий бит -- 2 будет снят).

==Некоторое промежуточное состояние дерева==

{{{
                  |
[          11          ]
[     3    ][    10    ]
[  1 ][ 4  ][ 0  ][ 11 ]
[4][0][0][0][0][0][8][8]
                  |
11,3,10,1,4,0,11,4,0,0,0,0,0,8,8
}}}

картинка соответствует состоянию памяти состоящей из 6 страниц, выделенных двух участках размера 1 и 2 соответственно.