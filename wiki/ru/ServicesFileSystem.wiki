#summary описание виртуальной файловой системы

<wiki:toc max_depth="2" />

http://embox.googlecode.com/svn/wiki/images/Kernel/VFS.png

== Введение==
*Виртуальная файловая система*(VFS) представляет собой уровень абстракции(то есть абстракция работы с деревом каталогов)
поверх некоторой конкретной реализации файловой системы. В этой модели файл представлен узлом дерева(вообще говоря дерево не двоичное). А интерфейс 
VFS предоставляет возможность _добавлять_, _удалять_ _и_ _осуществлять_ _поиск_ необходимого узла.
Например, следующая функция монтирует узел к родителю.
{{{ 
int vfs_add_leaf(node_t *child, node_t *parent);
}}}
Причем тип файловой системы(то есть указатель на драйвер файловой системы) зашит в структуру типа *node_t*. По этой информации, например, функция *fopen*,
найдя нужный узел в дереве, однозначно определит тип файловой системы и передаст управление соответствующему
драйверу.
 
 Итак, виртуальная файловая система позволяет монтировать файловые системы различных типов(devfs, ramfs,romfs). Таким образом различные
сервисы и приложения могут получать доступ к файлам, не зная тип файловой системы к которой они получают доступ. 

== VFS ==
Как говорилось выше, каждый файл представляет собой узел (node) виртуальной файловой системы. Все узлы организованы в иерархию, общая структура которой - дерево.
В корне дерева лежит узел {{{/}}}. Структура узла VFS:
{{{
typedef struct node {
	const char         name[CONFIG_MAX_LENGTH_FILE_NAME];
	void               *fs_info;
	fs_drv             *fs_type;
	struct list_head   neighbors;
	struct list_head   children;
} node_t;
}}}
Элементы структуры:
  * name - имя узла в системе
  * info - некая приватная информация о файле(???)
  * fs_type - указатель на драйвер файловой системы, обслуживающей данный узел
  * neighbours - список узлов содержащихся на том же уровне иерархии в том же поддереве узлов
  * children - список узлов содержащихся на один уровень иерархии ниже узлов, содержащихся в поддереве данного узла

Структура драйвера FS:
{{{
typedef struct file_system_driver {
	const char *name;
	file_op_t *file_op;
	fsop_desc_t *fsop;
} file_system_driver_t;
}}}
Элементы структуры:
  * name - имя драйвера файловой системы
  * file_op - указатель на структуру, описывающую операции, которые могут быть произведены с файлом
  * fsop - указатель на структуру, описывающую операции, которые могут быть произвелены с файловой системой

Для того, чтобы добавить в проект новый драйвер файловой системы, необходимо реализовать все необходимые функции, после чего
зарегистрировать новый драйвер в системе. Это можно сделать с помощью макроса
{{{DECLARE_FILE_SYSTEM_DRIVER}}} ,
который добавляет описание драйвера в специальную секцию. 
Важное замечание: функции драйвера могут быть релоцируемы.

*Пример работы сервиса файловой системы*:
  Допустим, мы хотим открыть файл /ram/file на чтение. Для этого мы вызываем функцию fopen() в качестве параметров указываем
  необходимые значения.
  Что происходит при этом в системе:
    * fopen разруливает путь к файлу, смотрит драйвер какой файловой системы обслуживает данный файл и вызывает функцию open драйвера, передавая ей в качестве аргументов информацию о файле
    * драйвер файловой системы по информации о файле определяет, какую функцию вызвать и запускает её
    
*Пример организации файловой системы*:
{{{
+--------+      +--------+      +-------+
|   /    | ---> |  dev/  | ---> |  tty  |
+--------+      +--------+      +-------+
                    |               |
                    v               v
                +--------+      +-------+
                |  ram/  |      |  null |
                +--------+      +-------+
}}} 

== Замечания ==    
 * Информация о файловых системах может хранится на том же носителе что и программа
 * Можем добавлять файловые системы во время работы
 * Можно не включать файловую систему вообще
 * Можно разбить один носитель в системе на программу информацию о разделах и сами разделы
    
