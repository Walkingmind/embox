#summary предложения по развитию системы tracing API

= Управление временем. Обзор =

== jiffies ==

Системный таймер периодически с некоторой частотой генерирует прерывание таймера.
По-хорошему частоту прерывания таймера необходимо задавать при загрузке системы.
Что-то в духе
{{{
    #define HZ 100
}}}
Значение HZ может отличаться для различных аппаратных платформ.

Глобальная переменная jiffies содержит количество импульсов системного таймера, которые были получены со времени загрузки системы. При загрузке ее значение сбрасывается в 0, при каждом прерывании таймера увеличивается на 1.

Тип переменной jiffies - {{{extern unsigned long volatile jiffies}}}. С целью защиты от переполнения вместе с ней обычно определяют вторую переменную {{{extern u64 jiffies_64}}}.
Средствами компоновщика младшие 32 бита переменной jiffies_64 совмещают с переменной jiffies.

Стоит помнить, что чтение переменной jiffies - атомарная операция в отличие от чтения переменной jiffies_64. Делают специальный макрос get_jiffies_64(), на время выполнения которого необходимо блокировать счетчик импульсов системного таймера.

Для защиты от переполнения при сравнении двух значений системного таймера создают макросы
{{{
    #define time_after(unknown, known) ((long)(known) - (long)(unknown) < 0)
    #define time_before(unknown, known) ((long)(unknown) - (long)(known) < 0)
    #define time_after_eq(unknown, known) ((long)(unknown) - (long)(known) >= 0)
    #define time_before_eq(unknown, known) ((long)(known) - (long)(unknown) >= 0)
}}}
Параметр unknown - это обычно значение переменной jiffies, а known - значение, с которым его надо сравнить.

Пример использования:
{{{
    unsigned long start = jiffies;
    unsigned long total_time;
    /* some work here */
    total_time = jiffies - start;
}}}

*Насколько я понимаю, переменная jiffies - это не совсем то, что нам надо. В целом эта переменная выполняет те же функции, что и существующая у нас в коде cnt_sys_time (из timer.c) --sunnya*

== Короткие задержки ==
Системе могут быть необходимы задержки на короткий (менее периода системного таймера) период времени. В таких случаях не используют переменную jiffies. Делают так:

При загрузке системы оценивают калибровочный параметр BogoMIPS - количество итераций пустого цикла, которые процессор может выполнить за 1 тик системного таймера (за 1 "jiffy"). Далее при необходимости вставляют пустой цикл с кратным количеством операций.
Так вроде как реализована udelay() в linux.

*Способ вообще говоря не совсем корректный и нам не подходящий: он позволяет только задать кратковременную задержку, а не оценить промежуток времени --sunnya* 

== Time stamp counter ==

Для x86 архитектуры, начиная с процессоров семейства Pentium, существует команда, возвращающая количество прошедших с последней перезагрузки тактов. Код:
{{{
    unsigned long long int rdtsc() {
        unsigned long long x;
        __asm__ volatile ("rdtsc": "=A" (x));
        return x;
    }
}}}
*Я так подозреваю, что это то, что нужно. Но вряд ли в risc-архитектурах будет подобная инструкция =). Надо поискать что-то аналогичное по функционалу. --sunnya*