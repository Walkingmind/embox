#summary Embox project quick overview.

<wiki:toc max_depth="2"/>

= Introduction =

Modern computer systems are used for a variety of problems, starting from engine’s management to huge data centers serving the queries of many users in real time. Different tasks require different resources and the system requirements are different. Therefore the software that manages this hardware must be different. This is particularly evident in embedded systems.  OS soft and hard real-time often are used in these systems. Users expect predictability from such systems in their reaction to an event it means the system can’t refuse in any situation. Usually those failures occur due to errors in the code of system drivers. Because the drivers are developed by hardware manufacturers, and it is known their code is lower quality. In addition the driver’s code is hard to debug.

All these facts affect the process of coding for embedded systems. In these systems test system design first of all, then develop some drivers for system loader and finally port a main operating system. As seen above the code of platform part of systems tripled and it leads to the errors.

*Embox* is a configurable operating system. Instead of providing a monolithic kernel, all code is placed into libraries, each of which implements different interfaces, for example memory manager interface. Only required parts of the system are included into final image. The required parts are defined during configuration of system or in run time.

= Architecture description =

At this point, the project identified a number of interfaces for various subsystems (they may change in future). These include an interface package HAL, dynamic memory management, virtual memory management, networking subsystem, the file subsystem.

== HAL Architecture ==
HAL(Hardware abstraction layer) — There is platform specific code in this packet. It contains following parts:
  * Processor initializing code
  * Interrupt vector table
  * Primary interrupt and exception handlers
  * System device management interface (interrupt controller, system tymer and etc)
  * Platform specific part of memory management unit (virtual memory)

== Dynamic memory management ==
[http://en.wikipedia.org/wiki/Dynamic_memory_allocation Dynamically allocated memory] - is the memory allocated during the runtime of the program, instead of statically allocated memory, which allocate during application building.

The project has several allocation algorithms implementation such as: Buddy system, Boundary markers, SLAB allocators  

== Virtual memory management ==
[http://en.wikipedia.org/wiki/Virtual_memory Virtual memory] is a technique which allow to isolate address spaces different processes and get flat address space for each process, therefore it allow to extend address space of the whole system.

More information about our implementation you can receive on the [VirtualMemory wiki page].

== Multitasking ==
This packet contains resources that allow ensure pseudo parallel execution of application. Such as: schedulers, synchronization mechanism, interprocess communication and so on

== Network ==
There is an implementation (not completed now) of stack TCP/IP. It includes several protocols such as: IP, ICMP, ARP, UDP, TFTP and etc.

The main features of our implementation is a possibility include the only required protocols to the image. It can save a lot of resources of system. 

== File System ==
File system - is a technique which provides unify interface to data access. It is very comfortable either access data kept on a storage or work with different devices for example (IO devices)

There is an implementation of virtual file system in the project. It allows to insert different file system drivers.
