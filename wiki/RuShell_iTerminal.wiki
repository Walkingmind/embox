#summary Describe some ideas.

{{{
      +----devctl ( send i/o descriptors )
      V
+----------------------------------------------------+
|  iTerminal Driver                                  |   
|____________________________________________________|
|                                                    |  [        ]   
|  __iterminal_main__           __iterminall_call__  |  [  JOB   ]>--+
| [ | read           ]         [  cmd    |  task   ] |  [        ]<-+|
| [ |                ]         [---------+---------] |  [________]  ||  
| [ | + has token    ]         [ switch  | switch  ] |      |       ||  
| [ | | call token   ] ======{ [  token1 |  ^C ----]-|------+       ||  
| [ |                ]         [  token2 |         ] |              ||  
| [ | write          ]         [   ...   | write --]-->--+          ||  
| [__________________]         [   ...   | read ---]--<-+|          ||  
|      |       |               [_________+_________] |  |+-[pipe>>]-+|
|______|_______|_____________________________________|  +--[pipe<<]--+
       |       |   
     [ i/o device ]


}}}

==iTerminal main==
В этой функции крутится: ввод из in, разбитие буффера на токены, вызов call от каждого токена, конкатенация результатов call, и вывод этого на устройство out.

==iTerminal call==
Функция может работать в двух режимах: cmd и task.

В режиме cmd хранится текущая cmdline, каждый токен оказывает влияние на ее. Т.е. если приходит какой-то символ, то мы его просто добавляем в cmdline и заталкиваем в выходной буффер. Если же это, например, enter, то функция переходит в состояние task, запускает задачу в новом потоке, инициализирует stdio контекст пайпами.

В task режиме, call отлавливает меньший набор токенов, направленных лишь на управление задачей, это такие как: `^C`, `^S`, `^Q`. Остальные же данные передаются в дочернюю задачу через пайп. Аналогично собираем из другого пайпа данные, что пришли от дочернего задания.

==pipe==
Пайп реализован в виде отдельного драйвера, к которому мы можем обратится `probe( drv, "pipe_name")`, что бы создать пайп с именем `pipe_name`, дескриптор которого можем в последствии получить при помощи `device_select("pipe_name")`.