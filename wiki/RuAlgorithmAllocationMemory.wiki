#summary Describes algorithms of memory allocation


= Описание =

Алгоритмы выделения памяти используется когда нужно управлять участками памяти выделенными под объекты в ходе выполнения программы. Данные алгоритмы применяются не только в общеизвестном malloc, но и например при поиске свободной физической памяти для виртуального режима. Здесь рассматриваются несколько таких алгоритмов.

= Типы выделения памяти =
Все алгоритмы для управления областями памяти можно отнести к нескольким типам, по тпам объектов которыми они оперируют

 # Объекты одного типа например *sk_buff* выделения памяти под эти объекты не целесообразно использовать *malloc*, то есть память произвольной длины. Для выделения объектов таких типов может быть написан свой [RuAlgorithmAllocationMemory#Objectsmanager менеджер объектов]. Либо так называемый [http://www.ibm.com/developerworks/ru/library/l-linux-slab-allocator/ slab аллокатор]
 # Объекты определенного размера (например страницы физической памяти). Для таких объектов можно применять [#Boundarymarkers метод граничных маркеров] или [RuAlgorithmAllocationMemory#Bitmaskmethod битовые маски].
 # Объекты произвольного размера и типа (malloc). Применяется [#Boundarymarkers метод граничных маркеров] ну собственно вот ссылочный на различные реализации [http://dvoika.net/infor/teor/Glava%204/Index3.htm  динамической памяти].

== Objects manager  ==

== Boundary markers ==
В основе метода - двусвязный список всех свободных и занятых блоков памяти, отсортированный по адресам. Как правило, элементами списка являются сами блоки памяти, точнее их "шапки", называемые маркерами. Модификация списка происходит в несколько простых операций.
Существует несколько алгоритм поиска свободного блока памяти заданного размера. Среди них - алгоритм первого соответствия, следующего соответствия, наилучшего и наихудшего соответствия. Кроме того, можно поддерживать списки блоков для часто используемых запросов (т.н. алгоритм быстрого соответствия).
Предназначен для выделения блоков памяти произвольной длины. Используется в аллокаторах общего назначения.

*Свойства*:
 * Сложность поиска и накладные расходы линейны относительно количества свободных областей
*Преимущества*:
 * Допускает использование free() без указания размера освобождаемого блока
 * Не требует отдельных структур вне самой кучи
 * Быстрое освобождение памяти
 * Склеивание пустых блоков при освобождении памяти
 * Отсутствие внутренней фрагментации
*Недостатки*:
 * Маркеры должны присутствовать как в начале свободного блока, так и в начале каждого занятого, что осложняет использование метода при выделении выровненных блоков (например, страниц)

== Bitmap ==
Для представления памяти используется битовая карта, в которой каждому блоку соответствует один бит.
Предназначен для выделения блоков памяти, выровненных по адресу и длине, например, страниц физической памяти.

*Свойства*:
 * Сложность поиска и накладные расходы линейны относительно размера памяти
*Преимущества*:
 * Достаточно прост в реализации
 * Малые накладные расходы по использованию памяти
*Недостатки*:
 * Не поддерживает освобождение блока памяти без указания его размера, что ограничивает область применения решением достаточно низкоуровневых задач
 * Если использовать для выделения блоков размером, не кратным масштабу карты, возникает внутренняя фрагментация

== Buddy system ==
См. http://en.wikipedia.org/wiki/Buddy_memory_allocation
*Преимущества*:
 * Чрезвычайно быстр, сложность зависит только от размера запрашиваемого блока
 * Малая внешняя фрагментация
*Недостатки*:
 * Очень сильная внутренняя фрагментация (хотя, думаю, ее можно уменьшить, взяв вместо степеней двойки, скажем, последовательность Фибоначчи, хотя хз. -- Эльдар)