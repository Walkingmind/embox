#summary Describes algorithms of memory allocation

<wiki:toc max_depth="3" />

= Описание =
Алгоритмы выделения памяти используется для управления участками памяти, выделенными под объекты в ходе выполнения программы.

Данные алгоритмы применяются для выделения памяти под объекты различных типов. Например, под динамические объекты с заранее неизвестным размером, под таблицы виртуального режима, под множества объектов одинаковой природы и размера (скажем дескрипторов сетевых пакетов) и т.д. 

Память может выделяться не только под объекты данных, но и под инструкции некоторого процесса. В этом случае целесообразно применять [RuVirtualMemory режим виртуальной памяти], позволяющий изолировать адресные пространства процессов друг от друга. Для работы с [RuVirtualMemory виртуальной памятью] характерно выделение памяти по страницам. 

Для различных типов объектов характерны различные требования к памяти, поэтому используются различные стратегии выделения. Это позволяет повысить эффективность работы программы в целом.

При реализации той или иной стратегии обычно определяют ее эффективность по следующим параметрам:
 * ??? Область применения алгоритма (страницы, большие объемы, маленькие, частое освобождение и т.п.)
 * Время поиска подходящего блока памяти
 * Время освобождения (возврата системе) блока памяти
 * Фрагментарность памяти (внутренняя и внешняя) и ее влияние на скорость работы

Данные алгоритмы обычно реализуются на уровне операционной системы. Все они могут быть отнесены к сервису "Динамическое распределение памяти". Здесь рассматриваются несколько стратегий выделения памяти для различных задач.

= Реальный и виртуальных режимы работы памяти =
Как уже упоминалось, операционная система может работать с использованием [RuVirtualMemory виртуального режима], а может запускать процессы в реальном режиме (по реальным физическим адресам). Виртуальный режим применяется в большинстве современных ОС и поддерживается на аппаратном уровне всеми современными процессорами, поскольку существенно упрощает механизмы выделения и изоляции памяти. 

Но существует ряд вычислительных систем, в которых данный механизм может быть избыточен. К таким системам можно отнести системы реального времени, у которых на момент компиляции ПО уже известна адресная карта всех процессов (потоков), которые будут работать в системе. В таких системах часто не нужно иметь механизм выделения памяти под код ПО, и объекты зачастую можно выделять статическим способом. Но даже в таких системах целесообразно иметь механизм динамического выделения памяти.

В виртуальном режиме необходим механизм выделения страниц и групп страниц. При этом такой механизм должен разделять память, выделяемую для системы, и память, занятую диспетчером страниц. Поскольку в таком случае нужно было бы замэпировать всю доступную память в таблицах виртуальной памяти, это вызвало бы постоянную подкачку памяти с данными о страницах.
С другой стороны, многие диспетчеры виртуальной памяти реализуют malloc через механизм выделения и добавления страниц. Это удобно даже в реальном режиме работы, поскольку тогда данные страницы могут перераспределяться между разными процессами.

= Типы выделения памяти =
Все алгоритмы для управления областями памяти можно отнести к нескольким категориям, по типам объектов, с которыми они оперируют:

 # Объекты одного типа, например *sk_buff*. Для выделения памяти под эти объекты нецелесообразно использовать *malloc*. Так как размер таких объектов постоянен, лучше использовать свой [RuAlgorithmAllocationMemory#Objects_manager менеджер объектов], либо так называемый [http://www.ibm.com/developerworks/ru/library/l-linux-slab-allocator/ slab аллокатор].
 # Объекты определенного размера (например, страницы физической памяти). Для таких объектов наиболее подходят [RuAlgorithmAllocationMemory#Bitmap битовые маски] или [RuAlgorithmAllocationMemory#Buddy_system алгоритм "близнецов"]. 
 # Объекты произвольного размера и типа (malloc). Для таких целей, как правило, применяется [RuAlgorithmAllocationMemory#Boundary_markers метод граничных маркеров].

В современных системах используется двухуровневый подход. На нижнем уровне идет выделение страниц памяти, а на верхнем уровне происходит выделение кусков произвольной длины. Верхний уровень запрашивает память у системы с помощью диспетчера страниц. Существуют также системы, которые не нуждаются в нижнем уровне (диспетчере страниц), это, например, встроенные системы с ограниченными ресурсами, выполняющие статический набор процессов. В таких случаях диспетчер памяти может захватить при инициализации отведенное для него пространство и больше никогда не обращаться к диспетчеру страниц.

== Objects manager  ==
Данный метод подходит для выделения и освобождения большого количества одинаковых объектов, ограничение на количество заданно на момент компиляции системы. 

Под объекты выделяется массив памяти из максимального количества объектов данного типа, и содержащиеся в нем объекты связываются некоторой структурой данных, например списком свободных объектов. Тогда выделение объекта - это всего лишь возвращение ссылки на голову списка, а освобождение объекта - это помещение ссылки на него в конец очереди свободных объектов.

== Boundary markers ==
В основе метода - двусвязный список всех свободных и занятых блоков памяти, отсортированный по адресам. Как правило, элементами списка являются сами блоки памяти, точнее их "шапки", называемые маркерами. Модификация списка происходит в несколько простых операций.
Существует несколько алгоритм поиска свободного блока памяти заданного размера. Среди них - алгоритм первого соответствия, следующего соответствия, наилучшего и наихудшего соответствия. Кроме того, можно поддерживать списки блоков для часто используемых запросов (т.н. алгоритм быстрого соответствия).
Предназначен для выделения блоков памяти произвольной длины. Используется в аллокаторах общего назначения.

Алгоритм граничных маркеров хорошо подходит под выделение объектов произвольной длины, для  сегмента же кода обычно используют другие алгоритмы.
Алгоритм описан в книге Дэвида Кнута "Искусство программирование часть 1".

===Структуры ===
Для работы данного алгоритма в каждый свободный блок добавляется два дескриптора и два указателя. на предыдущий и последующий свободные блоки. Таким образом все свободные блоки соединяются в двунаправленный список, по которому и происходит поиск подходящего блока для выделения. 
При выделении блока памяти помимо запрашиваемой памяти выделяется память под дескрипторы блоков точно так же один дескриптор в начале блока другой в конце. (Выделяемый блок не может быть меньше чем два указателя которые могут понадобится при освобождении блока под ссылки на предыдущий и последующий свободные блоки).
Дескриптор блока представляет из себя размер блока и флаг (свободен занят блок) в терминах Кнута (Тэга блока).
Если принять ввести структуры описанные выше то процессы выделения и освобождения блока приведутся к следующим.
=== Выделение ===
Берем голову списка и итерируясь по указателям ищем подходящий блок. Может быть две стратегии ( первый подходящий и наилучший подходящий). Первый вариант быстрее но второй приводит к меньшей фрагментации памяти.
=== Освобождение ===
Именно из за процедуры освобождения и происходят достоинства данного алгоритма.
Поскольку при освобождении мы знаем адрес освобождаемого блока то на предыдущем адресе лежит дескриптор блока. А на адресах (блок - 2) и ((блок - 1) + sizeof(блок) + 1) лежат дескрипторы соседних блоков (размер блока берется из дескриптора по адресу (блок - 1)). Таким образом освобождая блок проверяется соседний младший блок(с младшими адресами), и если он свободен то эти блоки соединяются, а затем проверяется блок следующий за освобождаемым и если он свободен то блоки тоже объединяются. Последней операцией является корректировка указателей в списке. Если блок не был слит с каким нибудь блоком то в него добавляются указатели и сам он добавляется как элемент в двунаправленный список свободных блоков.



=== Свойства ===
 * Сложность поиска и накладные расходы линейны относительно количества свободных областей
==== Преимущества ====
 * Допускает использование free() без указания размера освобождаемого блока
 * Не требует отдельных структур вне самой кучи
 * Быстрое освобождение памяти
 * Склеивание пустых блоков при освобождении памяти
 * Отсутствие внутренней фрагментации
==== Недостатки ====
 * Маркеры должны присутствовать как в начале свободного блока, так и в начале каждого занятого, что осложняет использование метода при выделении выровненных блоков (например, страниц)

== Bitmap ==
Для представления памяти используется битовая карта, в которой каждому блоку соответствует один бит.
Предназначен для выделения блоков памяти, выровненных по адресу и длине, например, страниц физической памяти.

*Свойства*:
 * Сложность поиска и накладные расходы линейны относительно размера памяти
*Преимущества*:
 * Достаточно прост в реализации
 * Малые накладные расходы по использованию памяти
*Недостатки*:
 * Не поддерживает освобождение блока памяти без указания его размера, что ограничивает область применения решением достаточно низкоуровневых задач
 * Если использовать для выделения блоков размером, не кратным масштабу карты, возникает внутренняя фрагментация

== Buddy system ==
См. http://en.wikipedia.org/wiki/Buddy_memory_allocation
*Преимущества*:
 * Чрезвычайно быстр, сложность зависит только от размера запрашиваемого блока
 * Малая внешняя фрагментация
*Недостатки*:
 * Очень сильная внутренняя фрагментация (хотя, думаю, ее можно уменьшить, взяв вместо степеней двойки, скажем, последовательность Фибоначчи, хотя хз. -- Эльдар)