#summary Describes algorithms of memory allocation

<wiki:toc max_depth="2" />

= Описание =
Алгоритмы выделения памяти используется когда нужно управлять участками памяти выделенными под объекты в ходе выполнения программы. 

Данные алгоритмы применяются для выделения памяти под объекты различных типов. Например для выделения память объектов произвольной длины, или например при поиске свободной памяти для виртуального режима для множества объектов одинаковой природы и размера (скажем дескрипторов сетевых пакетов). К тому же память может выделяться не только под объекты данных, но и для инструкций некоторого процесса, в этом случае целесообразно применять [RuVirtualMemory режим виртуальной памяти], позволяющий изолировать адресные пространства процессов друг от друга. Для работы с [RuVirtualMemory виртуальной памятью] характерно выделение памяти по страницам. Для различных типов объектов используются различные стратегии, поскольку это позволяется повысить эффективность работы программы в целом.

При реализации той либо иной стратегии обычно сравнивают ее эффективность по следующим параметрам:
 * Время поиска подходящего блока памяти
 * Время освобождения (возврата системе) блока памяти
 * Фрагментарность памяти при работе алгоритма и ее влияние на скорость работы

Данные алгоритмы обычно реализуются на уровне операционной системы все они могут быть отнесены к сервису "Динамическое распределение памяти". Здесь рассматриваются несколько стратегий выделения памяти для различных задач. 

= Реальный и виртуальных режимы работы памяти =
Как уже упоминалось, операционная система может работать с использование [RuVirtualMemory виртуального режима], а может запускать процессы в реальном режиме (по реальным физическим адресам). Виртуальный режим применяется в большинстве современных ОС, поддержан на аппаратном уровне всеми современными процессорами, поскольку существенно упрощает механизмы выделения и изоляции памяти. 
Но существует ряд вычислительных систем в которых данный механизм может быть избыточен. К таким системам можно отнести системы реального времени у которых на момент компиляции ПО уже известна адресная карта всех процессов (потоков), которые будут работать в системе. В таких системах часто не нужно иметь механизм выделения памяти под код ПО и объекты очень часто можно выделять статическим способом. Но даже в таких системах хотелось бы иметь механизм динамического выделения памяти.
В виртуальном режиме необходим механизм выделения страниц и групп страниц. При этом такой механизм должен разделять память выделяемую для системы и память занятую диспетчером страниц. Поскольку в таком случае нужно было бы замепировать всю доступную память в таблицах виртуальной памяти, что вызвало бы постоянную подкачку страниц с данными о страницах.
С другой стороны многие диспетчеры виртуальной памяти реализуют malloc через механизм выделения и добавления страниц, что удобно даже в реальном режиме работы. Поскольку тогда данные страницы могут перераспределяться между разными процессами.

= Типы выделения памяти =
Все алгоритмы для управления областями памяти можно отнести к нескольким типам, по типам объектов которыми они оперируют

 # Объекты одного типа например *sk_buff* выделения памяти под эти объекты не целесообразно использовать *malloc*, то есть память произвольной длины. Для выделения объектов таких типов может быть написан свой [RuAlgorithmAllocationMemory#Objects_manager менеджер объектов]. Либо так называемый [http://www.ibm.com/developerworks/ru/library/l-linux-slab-allocator/ slab аллокатор]
 # Объекты определенного размера (например, страницы физической памяти). Для таких объектов можно применять [RuAlgorithmAllocationMemory#Bitmap битовые маски] или [RuAlgorithmAllocationMemory#Buddy_system алгоритм "близнецов"]. 
 # Объекты произвольного размера и типа (malloc). Для таких целей, как правило, применяется [RuAlgorithmAllocationMemory#Boundary_markers метод граничных маркеров].

== Objects manager  ==

== Boundary markers ==
В основе метода - двусвязный список всех свободных и занятых блоков памяти, отсортированный по адресам. Как правило, элементами списка являются сами блоки памяти, точнее их "шапки", называемые маркерами. Модификация списка происходит в несколько простых операций.
Существует несколько алгоритм поиска свободного блока памяти заданного размера. Среди них - алгоритм первого соответствия, следующего соответствия, наилучшего и наихудшего соответствия. Кроме того, можно поддерживать списки блоков для часто используемых запросов (т.н. алгоритм быстрого соответствия).
Предназначен для выделения блоков памяти произвольной длины. Используется в аллокаторах общего назначения.

*Свойства*:
 * Сложность поиска и накладные расходы линейны относительно количества свободных областей
*Преимущества*:
 * Допускает использование free() без указания размера освобождаемого блока
 * Не требует отдельных структур вне самой кучи
 * Быстрое освобождение памяти
 * Склеивание пустых блоков при освобождении памяти
 * Отсутствие внутренней фрагментации
*Недостатки*:
 * Маркеры должны присутствовать как в начале свободного блока, так и в начале каждого занятого, что осложняет использование метода при выделении выровненных блоков (например, страниц)

== Bitmap ==
Для представления памяти используется битовая карта, в которой каждому блоку соответствует один бит.
Предназначен для выделения блоков памяти, выровненных по адресу и длине, например, страниц физической памяти.

*Свойства*:
 * Сложность поиска и накладные расходы линейны относительно размера памяти
*Преимущества*:
 * Достаточно прост в реализации
 * Малые накладные расходы по использованию памяти
*Недостатки*:
 * Не поддерживает освобождение блока памяти без указания его размера, что ограничивает область применения решением достаточно низкоуровневых задач
 * Если использовать для выделения блоков размером, не кратным масштабу карты, возникает внутренняя фрагментация

== Buddy system ==
См. http://en.wikipedia.org/wiki/Buddy_memory_allocation
*Преимущества*:
 * Чрезвычайно быстр, сложность зависит только от размера запрашиваемого блока
 * Малая внешняя фрагментация
*Недостатки*:
 * Очень сильная внутренняя фрагментация (хотя, думаю, ее можно уменьшить, взяв вместо степеней двойки, скажем, последовательность Фибоначчи, хотя хз. -- Эльдар)