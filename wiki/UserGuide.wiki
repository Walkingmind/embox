#summary Описание модуля планировщика.

= Планировщик =

В ОС РВ Embox разделяют планировщик и модуль который реализует стратегию планирования. Основными задачами планировщика являются деление процессорного времени на кванты, их распределение между потоками и переключение контекста. Стратегия планирования определяет простейшие алгоритмы планирования: запуск и выключение потока, выбор следующего и т.д.
Таким образом общая схема обеспечения многопоточности выглядит следующим образом: система общается с планировщиком через предоставляемое им API (`sched api`), не зависящее от реализации стратегии. В свою очередь планировщик использует API, предоставляемое стратегией. (`sched_startegy api`) 

Если при создании потока не было специальных флагов, то поток попадает в планировщик. В зависимости от стратегии этот поток либо начнет выполняться сразу, либо дождется своей очереди. Готовые к исполнению потоки находятся в `runq`. Потоки, ожидающие события -  в `sleepq`. Алгоритмы работы с этими очередями определяет стратегия планирования. Если же поток был создан с флагами, то планировщик не знает о них, до момента возобновления (вызова функции `thread_resume()` / `sched_resume()`). При создании потоку присваивается некоторое состояние, которое меняется в соответствии с таблицей переходов.

Состояние потока может измениться в следствии совершения над потоком или самим потоком какого-либо действия. Все действия планировщика происходят атомарно при заблокированном планировщике. Когда действия закончится, планировщик разблокируется. Каждое действие планировщика отражается на состоянии потока. Стартует ли поток после смены состояния или нет зависит от того, в каком состоянии сейчас находится в системе. При переходе в состояние running поток не сразу может попасть в `runq`. Если на момент изменения состояние было прерывание, то поток попадает в некий буфер `startq`, за который отвечает планировщик.

== Startq == 

`startq`  - это буфер, содержащий в себе потоки и события, которые стали готовыми к исполнению в тот момент, когда была обработка прерывания. Это нужно для того, чтобы отложить их запуск до выхода из прерывания, так как во время этого может измениться структура очередей `runq` и `sleepq`. Если бы мы не откладывали сброс startq до выхода из прерываний, то нам бы пришлось отключать прерывания в каждой операции с этой очередью (добавление, удаление и т.п.) для обеспечения атомарности. Кроме того, откложенное добавление потока в стратегию позволяет сэкономить время. 
Так как готовыми к исполнению потоки могут стать по двум причинам, то в `startq` содержится две очереди `event_wake` и `thread_resume`. Первая состоит из потоков, вышедших из состояния ожидания (`sleeping`), вторая - из потоков, которые были приостановлены (`suspended`), а теперь возобновили свою работу. Потоки из обоих очередей стартуют только тогда, когда прерывание будет обработано, и планировщик покинет все критические секции. 

== Ожидание события и пробуждение == 

Во время своего выполнения поток может столкнуться с такой ситуацией, когда он вынужден остановиться и дождаться какого-то события. Например, когда потоку нужно выполнить атомарный код, защищенный мьютексом, а мьютекс уже занят. В таком случае поток переходит в спящее состояние и отдает процессор. 
Когда в системе происходит событие, то все потоки, ожидающие его просыпаются и вновь становятся готовыми к исполнению. Событие может произойти в период обработки прерывания. В таком случае потоку нельзя сразу возобновлять свою работу, и планировщик откладывает его старт до выхода из прерывания. В это время поток находится в буфере `startq`. Если же событие произошло в обычном режиме, то поток стартует в тоже время. 

== Приостановление и возобновление работы потока == 

Наряду с вынужденным приостановление работы поток может быть приостановлен принудительно. Система или пользователь могут приостановить исполнение потока, вызвав на нем функции `thread_suspend()`. Тогда поток будет остановлен до вызова функций `thread_resume()`. Так как возобновить можно поток, находящийся либо в состоянии `suspended`, либо `sleeping and suspended`, то после возобновления потока состояние меняется только на `running` или `sleeping` соответственно. Если после возобновления работы ничего не мешает продолжению работы, то он попадает в `runq`. Так же как и в предыдущем случае, такая ситуация может произойти в период обработки прерывания. Тогда поток попадает в startq (в очередь `thread_resume`) ждет выхода из обработки прерывания. В противном случает, поток добавляется в `runq` напрямую. 

== Переключение потоков == 

Как отмечалось выше, основной задачей планировщика является распределение процессорного времени между различными задачами. Каждый квант времени планировщик решает, какому потоку отдать следующий квант. Так как критерии важности потока могут отличаться в зависимости от реализации, то алгоритм выбора следующего вынесен в стратегию планирования. Планировщик же, когда перепланирование требуется, не зависимо от стратегии выполняет следующие действия: сбрасывает буфер `startq` (он может это сделать, так как перепланирование происходит только вне прерываний), запрашивает у стратегии следующий, меняет их контекст. Переключить потоки система может только вне прерываний, чтобы избежать изменения структур стратегии и т.п.