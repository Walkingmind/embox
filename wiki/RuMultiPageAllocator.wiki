= Алгоритм близнецов =
== Идея ==
Основная идея алгоритма заключается в том, что всю память мы разбиваем на смежные блоки размера степени 2, и храним отдельные списки для разных размеров блоков. Благодаря этому получаем скорость выделения порядка log (проходим списки ищем в них первый блок подходящего размера, распиливаем, остатки заталкиваем в соответствующие), освобождение так же в идеале имеет сложность log (помечаем блок как пустой, проверяем смежный, если тоже пустой, то помечаем блок как свободный блок уровнем выше, проверяем его смежный и т.д.).

== Проблемы и задачи реализации ==
1. Хотелось бы избавится от списков, и вместо их использовать битовый массив (проверки за O(1))
  1.1. Возникает проблема с блоками у правой границы они всегда помечены как используемые (т.к. памяти под них физически нет) их можно случайно освободить.
  1.2. Стратегия пометки занятых блоков (недостаточно пометить только выделенный, необходимо пометить блоки уровнем выше)
  1.3. Обратный вопрос: по адресу узнать блок, который мы пытаемся освободить. Т.е. его место в дереве (определяется адресом и размером).
  1.4. Стратегия освобождения и снятия меток. Вероятно из-за п. 1.1. необходимо ввести дополнительные проверки.
  1.5. С одним типом меток возникает проблема -- невозможно отличить блок занят целиком или все же имеются свободные дочерние.

П.С. На данный момент написан алгоритм с одним типом меток, который помечает все нижнее поддерево. Т.е. сложность возрастает до log(size`_`heap)`*`size`_`block`*`log(size`_`block)

== Новая реализация ==
(Пока не сделано)

=== Понятия реализации === 
БЛОК`_`СВОБОДЕН
  Блок свободен (т.е. любой блок из поддерева, включая его самого, мы можем вернуть для использования), если он помечен как 0.

БЛОК`_`НЕСВОБОДЕН
  Блок является не свободным, если он, либо его родительский помечены как частично занятые (БЛОК`_`ЧАСТИЧНО`_`ЗАНЯТ).

БЛОК`_`ЗАНЯТ
  Блок занят (занят != не свободен) (т.е. конкретно он используется для хранения данных), если его метка 3 что тоже что и 1 | 2.

БЛОК`_`ЧАСТИЧНО`_`ЗАНЯТ
  Блок частично занят, тогда, если мы не можем вернуть его самого, но существует в поддереве элемент, который не вернут системе.
  т.е. его метка 1 или 2 (занято левое или правое поддерево)
  другими словами, на каком то уровне поддерева (но не корень) есть занятый блок (БЛОК`_`ЗАНЯТ)

ПОДХОДЯЩИЙ`_`БЛОК
  Блок является подходящим, если его размер превосходит запрашиваемый и БЛОК`_`СВОБОДЕН

=== Алгоритмы ===
БЛОК`_`БЛИЗНЕЦ ИНДЕКС
  инвертируем младший бит ( xor 1 )

АДРЕС`_`НАЧАЛА`_`БЛОКА ( ИНДЕКС`_`В`_`ДЕРЕВЕ )
  произведение сдвига ИНДЕКС`_`В`_`ДЕРЕВЕ до младшего не нулевого бита и размера страницы + начало кучи.

БЛОК`_`В`_`КУЧЕ
  если его конец помещается в кучу т.е. АДРЕС`_`НАЧАЛА`_`БЛОКА + РАЗМЕР`_`БЛОКА не превосходит правой границы кучи.

ПОИСК`_`БЛОК`_`РАЗМЕРА РАЗМЕР`_`БЛОКА
  ищем первый свободный (ПОДХОДЯЩИЙ`_`БЛОК) блок размера РАЗМЕР`_`БЛОКА.  

ВЫДЕЛЕНИЕ`_`БЛОКА ( РАЗМЕР`_`БЛОКА )
  пока РАЗМЕР`_`БЛОКА не превосходит максимального ПОИСК`_`БЛОК`_`РАЗМЕРА РАЗМЕР`_`БЛОКА, если нет такого размера РАЗМЕР`_`БЛОКА увеличиваем вдвое.
  помечаем блок как БЛОК`_`ЗАНЯТ
  устанавливаем для родителей БЛОК`_`ЧАСТИЧНО`_`ЗАНЯТ в зависимости из какого мы поддерева
  возвращаем указатель на найденый блок или нулевой указатель.

ОСВОБОЖДЕНИЕ`_`БЛОКА ( АДРЕС`_`БЛОКА )
  по адресу определяем индекс в дереве
  пока последний бит индекса 0 и блок не является занятым т.е. (!БЛОК`_`ЗАНЯТ) индекс/2 ( >>= )
  помечаем блок по найденому индексу 0
  снимаем бит 1 или 2 у родителя (в зависимости от поддерева из которого движимся), если его метка и метка его близнеца стали равны 0, то выполняем все то же для его.
