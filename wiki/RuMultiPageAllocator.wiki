===Описание===

mpallocator.h предоставляет интерфейс для выделения и освобождения участка памяти кратного нескольким страницам.
 * {{{ void *mpalloc( size_t cp ) }}} выделяет cp страниц из пула и возвращает указатель на начало блока;
 * {{{ void mpfree( void *ptr ) }}} возвращает непрерывный блок из страниц системе по указателю на его начало.
Для использования необходимо добавить в зависимости модуль embox.hal.mm.mpallocator.

===Реализация===
Алгоритм исполюзуемый в системе является вариацией на тему "алгоритма близнецов". 

В начале пула выделяется несколько страниц под дерево, которое хранит информацию о разбиении пула на страницы размера 2`^`n. Каждой странице ставится в соответствие байт памяти, в котором могут выставляться некоторые биты. Они означают:
 * 1 -- левое поддерево не пусто;
 * 2 -- правое поддерево не пусто;
 * 4 -- все поддерево зарезервировано (без невыделенных участков);
 * 8 -- блок соответствующий этой вершине изначально целиком не влазил в пул (бывает верно для некоторых правых блоков).
Дерево является полным бинарным и строется на простых соображениях: индекс корня -- 1, индекс левого ребенка -- 2`*`n, индекс правого -- 2`*`n`+`1. Вершина в корне означает участок памяти равный 2`^`n страниц памяти таких, что 2`^`(n`-`1) страниц от начала пула помещается целиком. Далее блок делиться пополам и получившимся участкам ставятся в соответствие дочерние вершины текущей, так продолжается до тех пор, пока не дойдем до блоков размера 1 страницы.

Поиск подходящего свободного осуществляется сверху-вниз по дереву, изходя из меток и размера необходимой памяти. Найдя подходящий блок очевидным образом обновляем метки (поднимаясь вверх, так что ниже в дереве останутся вершины без меток). 

При освобождении находим блок, соответствующий адресу блок размера одной страницы (он будет равен сумме кол-ва страниц от начала пула до указателя и размера корневого блока), далее идем вверх по дереву пока не встретим блок с меткой 4, этот блок и будет искомым, соответствующим той области памяти, что мы хотим освободить. Следующим шагом проходя по дереву вверх вновь обновляем метки (необходимости проверять близнецов нет, так как если, допустим, правое поддерево свободно, то и соответствующий бит -- 2 будет снят).

==Некоторое промежуточное состояние дерева==

`                  |`
`[          11          ]`
`[     3    ][    10    ]`
`[  1 ][ 4  ][ 0  ][ 11 ]`
`[4][0][0][0][0][0][8][8]`
`                  |`
`11,3,10,1,4,0,11,4,0,0,0,0,0,8,8`

картинка соответствует состоянию памяти состоящей из 6 страниц, выделенных двух участках размера 1 и 2 соответственно.