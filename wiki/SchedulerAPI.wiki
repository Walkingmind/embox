#summary API планировщика.

=Интерфейс для работы с планировщиком=

С интерфейсом планировщика работают такие низкоуровневые сущности, как потоки, очередь ждущих потоков, задачи и т.д. Интерфейс позволяет влиять на процесс планирования, например, добавлять новые потоки в очередь запущенные потоков, менять приоритет у потоков и т.д.

==Запуск планировщика==

Запуск планировщика происходит во время инициализации модуля thread.core. Сначала создаются потоки boot (обертка текущего потока) и idle, затем начинается инициализация самого планировщика с помощью функции shed_init(), где он создает необходимое ему окружение:
  * Очередь потоков runq. В этой очереди находятся все потоки, которые готовы к запуску или продолжить исполнение.
  * Системный таймер. При вытесняющем планировании по истечению кванта времени планировщик может передать ресурсы процессора в распоряжение другому потоку в зависимости от стратегии планирования. Кванты времени отсчитывает этот таймер.

Runq на момент инициализации пуст. Перед тем, как запустить таймер, планировщик “будит” idle поток, по сути помещает его в runq. Теперь планировщик запускает таймер, на чем инициализация заканчивается. Поток boot продолжает выполняться.

==Вызов перепланирования==
При перепланировании происходит передача ресурсов процессора какому-то потоку исходя из стратегии планирования. При вытесняющем планировании перепланирование происходит автоматически по истечению очередного кванта времени. Иногда у потока может возникнуть необходимость вызова планировщика еще до того, как истек предназначенный ему квант времени. Например, после того, как поток закончил исполняться и освободил. За это отвечает функция schedule().

При перепланировании текущий поток кладется в runq, если в его состоянии отсутствует W (см. Машина состояний потока), иначе планировщик снимает с него R, тем самым обозначая, что поток больше не находится под управлением планировщика. Такие потоки становятся спящими, к ним управление не перейдет до тех пор, пока его не разбудят (см. Запуск и пробуждение потока, интерфейс waitq и sched_wait). Затем из очереди runq достается поток, который следующим получит ресурсы процессора. Им вполне может оказаться текущий поток. Если поток оказался другим, то происходит смена контекста (см. Контекст процессора).

==Изменение приоритета потока==
Подробнее про приоритеты потока смотри в разделе Управление приоритетами потока. Управление через интерфейс планировщика происходит на более низком уровне, чем через интерфейс потоков. Функция sched_change_priority() задает новый приоритет потоку. Причем, если указанный в аргументах поток - текущий, то происходит перепланирование.

==Запуск и пробуждение потока==
Запуск и побуждение потока происходят с вызовом одной и той же функции sched_wakeup(), так как с точки зрения планировщика не важно, начинает ли поток свое исполнение или возобновляет. Эта функция лишь передает поток под управление планировщика, то есть добавляет в runq и выставляет состояние R, и не гарантирует, что поток будет запущен или возобновлен сразу же, это зависит уже от алгоритма планирования. Однако после завершения этой функции будет выполнено перепланирование.

Если при создании потока не было специальных флагов, то поток сразу же вызывает функцию sched_wakeup(). Иначе поток нужно будет запустить самостоятельно с помощью функции thread_launch(), которая уже и вызовет sched_wakeup() (см. разделы Создание потока и Запуск потока).
