/**
 * @file
 * @brief
 *
 * @author  Anton Kozlov
 * @date    10.09.2012
 */

/**
 * exceptions table:
 * 0x00 - reset
 * 0x04 - undefined
 * 0x08 - SWI
 * 0x0C - prefetch abort
 * 0x10 - data abort
 * 0x14 - reserved
 * 0x18 - IRQ
 * 0x1C - FIQ (_fast IRQ)
 */

#include <asm/modes.h>
#include <framework/mod/options.h>

#define IRQ_STACK_SIZE OPTION_GET(NUMBER,irq_stack_size)

.weak hardware_init_hook
.weak software_init_hook
.weak kernel_start

    .align 4

.extern irq_handler

.global start
.section .trap_table, "x"
trap_table_start:
/* trap table
 * this code specific for ARM7TDMI cores
 *
 * actually, this is general for all ARM cores
 */
    ldr pc, reset_handler_addr
    ldr pc, undef_handler_addr
    ldr pc, swi_handler_addr
    ldr pc, prefetch_abt_handler_addr
    ldr pc, data_abt_handler_addr
    nop /*bad exception not_used:		.word not_used*/
    ldr pc, irq_handler_addr
    ldr pc, fiq_handler_addr

reset_handler_addr:
    .word reset_handler
undef_handler_addr:
    .word undef_handler
swi_handler_addr:
    .word swi_handler
prefetch_abt_handler_addr:
    .word prefetch_abt_handler
data_abt_handler_addr:
    .word data_abt_handler
irq_handler_addr:
    .word irq_handler
fiq_handler_addr:
    .word fiq_handler

.text
/* initialize stacks in some modes */
start:
reset_handler:

    ldr r0, =_stack_top

/* following mode now considered as unresolvable, so don't allocating stack */
    msr CPSR_c, #ARM_MODE_FIQ | I_BIT | F_BIT
    mov sp, r0
    msr CPSR_c, #ARM_MODE_SVC | I_BIT | F_BIT
    mov sp, r0
    msr CPSR_c, #ARM_MODE_ABT | I_BIT | F_BIT
    mov sp, r0
    msr CPSR_c, #ARM_MODE_UND | I_BIT | F_BIT
    mov sp, r0

    msr CPSR_c, #ARM_MODE_IRQ | I_BIT | F_BIT
    mov sp, r0
    sub r0, r0, #IRQ_STACK_SIZE

    msr CPSR_c, #ARM_MODE_SYS | I_BIT | F_BIT
    mov sp, r0

    /* setup interrupt vector */
    ldr r0, =trap_table_start
    mcr p15, 0, r0, c12, c0, 0

    /* setup c1, Control Register */
    mrc p15, 0, r0, c1, c0, 0
    //orr r0, r0, #CR_M /* enabling MMU */
    orr r0, r0, #CR_A /* enabling data abort on unaligned mem access */
    orr r0, r0, #CR_C /* enabling data caching */
    orr r0, r0, #CR_Z /* enabling program flow prediction */
    orr r0, r0, #CR_I /* enabling instruction caching */
    mcr p15, 0, r0, c1, c0, 0

    /* setup c1, Auxiliary Control Register */
    mrc p15, 0, r0, c1, c0, 1
    orr r0, r0, #ACR_L2EN /* enabling L2 cache */
    mcr p15, 0, r0, c1, c0, 1

    b bootldr_start

undef_handler:
prefetch_abt_handler:
fiq_handler:
    sub r14, r14, #4
    b arm_unresolvable_exception
data_abt_handler:
    sub r14, r14, #8

arm_unresolvable_exception:
    nop
    stmfd sp!, {r0-r12, r14}
    mrs r0, CPSR
    mrs r1, SPSR
    stmfd sp!, {r0, r1}
    mov r0, sp
    b arm_exception_handler
