/**
 * @file
 * @brief EMBOX dependency injection framework.
 *
 * @date 22.02.2010
 * @author Eldar Abusalimov
 */

#ifndef EMBOX_MOD_H_
#define EMBOX_MOD_H_

#include <stddef.h>

/*
 * Implementation note:
 * Many macros uses some of their arguments to construct symbol names. This
 * imposes well-known restrictions to the input values of these arguments.
 * To prevent a confusion all such arguments are prefixed by 's_' (symbol).
 */

#if !defined(__FRAMEWORK__) && !defined(__EMBUILD_DEPSINJECT__)
# ifndef __EMBUILD_MOD__
#  error "Do not include without __EMBUILD_MOD__ defined (e.g. from lib code)!"
# endif /* __EMBUILD_MOD__ */
#endif /* __EMBUILD_DEPSINJECT__ */

#define __STRINGIFY(str) #str

/* Linker sections stuff. */

/**
 * All mod-related sections are linked using something like
 * @code *(SORT(.mod*.rodata)) @endcode . @c SORT guarantees that the wildcard
 * is expanded in the lexicographical order, @c order argument is used to
 * control the placement of sections within a single mod. We use this facility
 * to create null-terminated arrays of module dependencies initialized
 * (populated) in multiple compilation units.
 */
#define __MOD_SECTION(s_mod, section, order, tag) \
	".mod"__STRINGIFY(__##section##__$$##s_mod##$$__##order##_##tag)".rodata"

#define __MOD_SECTION_HEAD(s_mod, section) __MOD_SECTION(s_mod, section,0,head)
#define __MOD_SECTION_BODY(s_mod, section) __MOD_SECTION(s_mod, section,1,body)
#define __MOD_SECTION_TAIL(s_mod, section) __MOD_SECTION(s_mod, section,9,tail)

/* Internal variable names. */

#define __MOD(s_mod)              __mod__$$##s_mod
#define __MOD_API(s_mod)          __mod_api__$$##s_mod
#define __MOD_TAG(s_tag)          __mod_tag__$$##s_tag
#define __MOD_NAME(s_mod)         __mod_name__$$##s_mod
#define __MOD_PRIVATE(s_mod)      __mod_private__$$##s_mod
#define __MOD_PACKAGE(s_package)  __mod_package__$$##s_package
#define __MOD_ARRAY(s_mod, s_array) __mod_##s_array##__$$##s_mod
#define __MOD_ARRAY_ENTRY(s_mod, s_array, s_entry) \
	__mod_##s_array##__$$##s_mod##$$__$$##s_entry

/* Internal declarations and definitions. */

#define __MOD_DECL(s_mod) \
	extern const struct mod __MOD(s_mod)

#define __MOD_PACKAGE_DECL(s_package) \
	extern const struct mod_package __MOD_PACKAGE(s_package)

#define __MOD_API_DECL(s_mod) \
	extern const struct mod_api __MOD_API(s_mod) __attribute__ ((weak))

#define __MOD_TAG_DECL(s_tag) \
	extern const struct mod_tag __MOD_TAG(s_tag)

#define __MOD_NAME_DEF(s_mod, _mod_name) \
	const char __MOD_NAME(s_mod)[] = _mod_name
#define __MOD_PRIVATE_DEF(s_mod) \
	static struct mod_private __MOD_PRIVATE(s_mod)

#define __MOD_ARRAY_DEF(s_mod, s_array) \
	__extension__ static const struct mod *__MOD_ARRAY(s_mod, s_array)[0] \
		__attribute__ ((section(__MOD_SECTION_HEAD(s_mod, s_array)))); \
	static const struct mod *__MOD_ARRAY_ENTRY(s_mod, s_array, __null$$) \
		__attribute__ ((used, section(__MOD_SECTION_TAIL(s_mod, s_array)))) \
		= NULL

#define __MOD_ARRAY_ADD(s_mod, s_array, s_mod_entry) \
	static const struct mod *__MOD_ARRAY_ENTRY(s_mod, s_array, s_mod_entry) \
		__attribute__ ((used, section(__MOD_SECTION_BODY(s_mod, s_array)))) \
		= MOD_PTR(s_mod_entry) \

/**
 * Used to access the self module (referenced by __EMBUILD_MOD__), e.g. to bind
 * something like #mod_data.
 */
#define __MOD_SELF(macro) \
		__MOD_SELF_EXPAND(macro, __EMBUILD_MOD__)
#define __MOD_SELF_EXPAND(macro, mod) \
		__MOD_SELF_INVOKE(macro, mod)
#define __MOD_SELF_INVOKE(macro, mod) \
		macro(mod)

/* Here goes public macros API. */

/**
 * Pointer to the #mod structure defined with #MOD_DEF() macro.
 *
 * @param s_mod the mod variable name used at definition time.
 */
#define MOD_PTR(s_mod) (&__MOD(s_mod))

/**
 * Pointer to the #mod_tag structure defined with #MOD_TAG_DEF() macro.
 *
 * @param s_tag the mod_tag variable name used at definition time.
 */
#define MOD_TAG_PTR(s_tag) (&__MOD_TAG(s_tag))

/**
 * Defines a new mod. For the new mod the @link #mod corresponding @endlink
 * structure is allocated. Also two section-driven arrays are defined for the
 * mod#provides and mod#requires lists.
 *
 * @param s_mod the variable name used later to access the mod structure
 *        using #MOD_PTR(), to define dependencies with #MOD_DEP_DEF(), or to
 *        bind mod-specific @link #mod_ops operations @endlink and data using
 *        #MOD_OPS_DEF() and #MOD_DATA_DEF() macros. For the code generated by
 *        EMBuild this argument must be the same as provided by the
 *        __EMBUILD_MOD__ macro for each mod at compilation time
 * @param s_mod_package the package variable name used in
 *        #MOD_PACKAGE_DEF()
 * @param mod_name a string containing the mod name. The name of the current
 *        mod (referenced by __EMBUILD_MOD__) can accessed at compilation time
 *        using #MOD_SELF_NAME macro
 */
#define MOD_DEF(s_mod, s_mod_package, mod_name) \
	__MOD_API_DECL(s_mod); \
	__MOD_PACKAGE_DECL(s_mod_package); \
	__MOD_ARRAY_DEF(s_mod, requires); \
	__MOD_ARRAY_DEF(s_mod, provides); \
	__MOD_NAME_DEF(s_mod, mod_name); \
	__MOD_PRIVATE_DEF(s_mod); \
	const struct mod __MOD(s_mod) = { \
			.private  = &__MOD_PRIVATE(s_mod), \
			.api      = (struct mod_api *) &__MOD_API(s_mod), \
			.package  = (struct mod_package *) &__MOD_PACKAGE(s_mod_package), \
			.name     = __MOD_NAME(s_mod), \
			.requires = (struct mod **) &__MOD_ARRAY(s_mod, requires), \
			.provides = (struct mod **) &__MOD_ARRAY(s_mod, provides), \
		}

#define MOD_TAG_DEF(s_tag, _tag_name) \
	__MOD_ARRAY_DEF(s_tag, tagged); \
	const struct mod_tag __MOD_TAG(s_tag) = { \
			.name = _tag_name, \
			.mods = (struct mod **) &__MOD_ARRAY(s_tag, tagged), \
		}

#define MOD_API_DEF(s_mod, _mod_data, _mod_ops) \
	__MOD_API_DEF(s_mod, _mod_data, _mod_ops, NULL)

#define MOD_API_TAGGED_DEF(s_mod, _mod_data, _mod_ops, s_tag) \
	__MOD_DECL(s_mod); \
	__MOD_TAG_DECL(s_tag); \
	__MOD_ARRAY_ADD(s_tag, tagged, s_mod); \
	__MOD_API_DEF(s_mod, _mod_data, _mod_ops, MOD_TAG_PTR(s_tag))

#define __MOD_API_DEF(s_mod, _mod_data, _mod_ops, _mod_tag) \
	const struct mod_api __MOD_API(s_mod) = { \
			.data = (void *) _mod_data, \
			.ops = (struct mod_ops *) _mod_ops, \
			.tag = (struct mod_tag *) _mod_tag, \
		}

#define MOD_DEP_DEF(s_mod, s_dep) \
	__MOD_DECL(s_mod); \
	__MOD_DECL(s_dep); \
	__MOD_ARRAY_ADD(s_mod, requires, s_dep); \
	__MOD_ARRAY_ADD(s_dep, provides, s_mod)

#define MOD_PACKAGE_DEF(s_package, package_name) \
	const struct mod_package __MOD_PACKAGE(s_package) = { \
			.name = package_name, \
		}

#define MOD_ROOT_DEF(s_mod) \
	static const struct mod *__mod_root__##s_mod \
		__attribute__ ((used, section(".mod.rodata"))) = MOD_PTR(s_mod)

#define MOD_SELF                     __MOD_SELF(__MOD)
#define MOD_SELF_NAME                __MOD_SELF(__MOD_NAME)
#define MOD_SELF_DEP_DEF(s_dep)       MOD_DEP_DEF(__EMBUILD_MOD__, s_dep)
#define MOD_SELF_API_TAGGED_DEF(_mod_data, _mod_ops, s_tag) \
		MOD_API_TAGGED_DEF(__EMBUILD_MOD__, _mod_data, _mod_ops, s_tag)
#define MOD_SELF_API_DEF(_mod_data, _mod_ops) \
		MOD_API_DEF(__EMBUILD_MOD__, _mod_data, _mod_ops)

#define MOD_FLAG_ENABLED       (1 << 0)
#define MOD_FLAG_OPFAILED      (1 << 1)
#define MOD_FLAG_OPINPROGRESS  (1 << 2)

struct mod;
struct mod_package;
struct mod_ops;
struct mod_api;
struct mod_tag;
struct mod_private;

/**
 * Performs an operation with the module. The semantics of the operation is
 * module-specific. If the module has no operation assigned (#mod_ops structure
 * contains @c NULL pointer fields), the meaning is that module operation
 * always succeeds (as if the corresponding function returns 0).
 *
 * @param self pointer to the #mod struct.
 * @return error code
 * @retval 0 if operation succeeds
 * @retval nonzero on error
 */
typedef int (*mod_op_t)(struct mod *self);

/**
 * The main mod operation. The semantics of the operation is module-specific.
 * Mods framework does not use this method nor its return value. Please note
 * that framework also does not track the current state of the mod or its
 * dependencies, so the mod should check its state by itself.
 *
 * The caller should use #mod_invoke() function instead of directly accessing
 * the corresponding field of the #mod_ops structure.
 *
 * @param self pointer to the #mod struct.
 * @param data optional argument
 * @return operation result
 */
typedef int (*mod_invoke_t)(struct mod *self, void *data);

/**
 * TODO Module info emitted by EMBuild dependency injection model generator.
 */
struct mod {
	/** Internal data needed by dependency resolver. */
	struct mod_private *private;
	/** (optional) Interface with mods framework and others. */
	struct mod_api *api;
	/** Module package assigned by EMBuild. */
	struct mod_package *package;
	/** Module name assigned by EMBuild. */
	const char *name;
	/** Null-terminated array containing dependency info. */
	struct mod **requires, **provides;
};

/**
 * Mods framework manages each mod through a special interface so-called
 * @c mod_api.
 */
struct mod_api {
	/** (optional) Module specific data. */
	void *data;
	/** (optional) Available operations. */
	struct mod_ops *ops;
	/** (optional) Mod tag. */
	struct mod_tag *tag;
};

/**
 * Each mod can have an optional tag. Tag is used to group similar mods, e.g.
 * which are managed by the same framework. Tag has no special meaning for the
 * mods framework.
 */
struct mod_tag {
	/** (optional) Tag name. */
	const char *name;
	/** Null-terminated array of tagged mods. */
	struct mod **mods;
};

struct mod_package {
	const char *name;
};

/**
 * Module operations.
 * @note Do not call these functions directly!
 */
struct mod_ops {
	/** (optional) Module state change operation. */
	mod_op_t enable, disable;
	/** (optional) Module main method. */
	mod_invoke_t invoke;
};

struct mod_private {
	unsigned int flags;
};

struct mod_iterator {
	struct mod **p_mod;
};
/**
 * The special package which may be used for pseudo-mods defined by other
 * frameworks.
 */
__MOD_PACKAGE_DECL(generic);

/**
 * Enables the specified mod resolving its dependencies. This implies that all
 * the mods on which the given one depends will also be enabled.
 * If the mod has already been enabled then nothing special is done and this
 * function returns zero.
 *
 * @param mod the mod to enable
 * @return operation result
 * @retval 0 if the mod has been successfully enabled
 * @retval -EINVAL if the argument is @c NULL
 * @retval -EINTR if an error has occurred while enabling the mod or one of
 *         its dependencies
 */
extern int mod_enable(const struct mod *mod);

/**
 * Disables the specified mod resolving its dependencies. This implies that all
 * the mods which depend on the given one will also be disabled.
 * If the mod has not been enabled yet then nothing special is done and this
 * function returns zero.
 *
 * @param mod the mod to disable
 * @return operation result
 * @retval 0 if the mod has been successfully disabled
 * @retval -EINVAL if the argument is @c NULL
 * @retval -EINTR if an error has occurred while disabling the mod or one of
 *         its dependencies
 */
extern int mod_disable(const struct mod *mod);

/**
 * The weak version of #mod_enable().
 * Enables the specified mod if and only if all the mods on which the given one
 * depends are also enabled. If the mod has already been enabled then nothing
 * special is done and the function returns zero.
 *
 * @param mod the mod to enable
 * @return operation result
 * @retval 0 if the mod has been successfully enabled
 * @retval -EINVAL if the argument is @c NULL
 * @retval -EBUSY if the mod cannot be enabled at the moment because of
 *         unsatisfied dependencies
 * @retval -EINTR if an error has occurred while enabling the mod
 */
extern int mod_enable_nodep(const struct mod *mod);

/**
 * The weak version of #mod_disable().
 * Disables the specified mod if and only if all the mods which depend on the
 * given one are also disabled. If the mod has not been enabled yet then
 * nothing special is done and the function returns zero.
 *
 * @param mod the mod to disable
 * @return operation result
 * @retval 0 if the mod has been successfully disabled
 * @retval -EINVAL if the argument is @c NULL
 * @retval -EBUSY if the mod cannot be disabled at the moment because of
 *         unsatisfied dependencies
 * @retval -EINTR if an error has occurred while disabling the mod
 */
extern int mod_disable_nodep(const struct mod *mod);

/**
 * Invokes the module if it has provided the corresponding operation.
 * Please note that framework does not track the current state of the mod or
 * its dependencies, this means that the mod will be invoked even if it is not
 * enabled now.
 *
 * @param mod the mod on which to call @link mod_ops#invoke @endlink method
 * @param data optional argument to pass to the @c invoke method
 * @return invocation result
 * @retval -EINVAL if the @c mod argument is @c NULL
 * @retval -ENOTSUP if the mod does not support invoke method
 */
extern int mod_invoke(const struct mod *mod, void *data);

/**
 * Gets the data associated with the specified mod (if any).
 *
 * @param mod the mod which's data to get
 * @return the mod data
 */
extern void *mod_data(const struct mod *mod);

extern struct mod_iterator *mod_requires(const struct mod *mod,
		struct mod_iterator *iterator);
extern struct mod_iterator *mod_provides(const struct mod *mod,
		struct mod_iterator *iterator);
extern struct mod_iterator *mod_tagged(const struct mod_tag *tag,
		struct mod_iterator *iterator);

extern struct mod *mod_iterator_next(struct mod_iterator *iterator);

extern bool mod_iterator_has_next(struct mod_iterator *iterator);

#if 0
/* TODO there is no way to implement these functions at now. -- Eldar */

/**
 * Sets the mod-specific data.
 *
 * @param mod the mod which's data to get
 * @param data the data to associate with the mod
 */
extern void mod_data_set(const struct mod *mod, void *data);

/**
 * Gets the #mod_ops of the specified mod.
 *
 * @param mod the mod which's ops to get
 * @return the mod operations structure
 */
extern struct mod_ops *mod_ops_get(const struct mod *mod);

/**
 * Sets the mod-specific data.
 *
 * @param mod the mod which's data to get
 * @param ops the data to associate with the mod
 */
extern void mod_ops_set(const struct mod *mod, struct mod_ops *ops);
#endif

#endif /* EMBOX_MOD_H_ */
