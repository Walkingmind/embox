/*
 * Author: Eldar Abusalimov
 */

import ecore;

fileHeader(EPackage this) :
	"# Generated by Xpand using M2Make template.";

fileName(EPackage this, String fileKind) :
	name.toLowerCase() + "-" +
	fileKind + ".mk";

includeFile(EPackage this, String fileKind, String anotherFileKind) :
	"include $(dir $(" + inclusionGuard(fileKind) + "))"
		+ fileName(anotherFileKind);

private inclusionGuardPrefix(EPackage this) :
	((String) GLOBALVAR INCLUSION_GUARD_PREFIX) + name.toLowerCase() + "_";
//	"__model_";

inclusionGuard(EPackage this, String fileKind) :
	inclusionGuardPrefix() + fileKind + "_mk"; 

inclusionGuardBegin(EPackage this, String fileKind) :
	"ifndef " + inclusionGuard(fileKind) + "\n" +
	inclusionGuard(fileKind) + " := $(lastword $(MAKEFILE_LIST))";

inclusionGuardEnd(EPackage this, String fileKind) :
	"endif # " + inclusionGuard(fileKind);

implInclusionCheck(EPackage this, String fileKind) :
	"ifndef " + inclusionGuard(fileKind) + "\n" +
	"$(error \\\n\tDo not include this file directly, include '" +
		fileName(fileKind) + "' instead!)\n" +
	"endif # " + inclusionGuard(fileKind);

comment(String this) :
	replaceAll("\n", "\n#");

nsName(String this, EPackage pkg) : pkg.nsPrefix + this.toFirstUpper();
nsName(ENamedElement this, EPackage pkg) : name.nsName(pkg);

metaModelInitializer(EPackage this) : "__" + name.toFirstLower() + "_init";
metaModelBinder(EPackage this) :      "__" + name.toFirstLower() + "_bind";

factoryName(EPackage this) :         name.toFirstUpper() + "Factory";
factoryInstanceName(EPackage this) : name.toFirstLower() + "Factory";

withModelPrefix(String this, EPackage model):
	model.name.toFirstUpper() + "_" + this;

nodeImplName(EPackage this) :        name.toFirstUpper() + "NodeImpl";

className(EClass this) :     nsName(ePackage).toFirstUpper();
classImplName(EClass this) : nsName(ePackage).toFirstUpper() + "Impl";

referenceClassImplName(EClass this) :
	"ReferenceTo" + nsName(ePackage).toFirstUpper() + "Impl";

memberCardinality(ETypedElement this) : many ? "..." : "";
memberType(ETypedElement this)        : eType.memberTypeFor();
memberTypeFor(EClassifier this)       : "";
memberTypeFor(EClass this)            : " : " + name;

propertyName(Void this) : "";
propertyName(EStructuralFeature this) : name.toFirstLower();
propertyName(EAttribute this) :
	"boolean" == eAttributeType.instanceClassName
		? "is" + name.toFirstUpper() : name.toFirstLower();

propertyLinkName(EReference this) : propertyName() + "_link" + "s".ifIs(many);
propertyLinkType(EReference this) : " : ELink";

methodName(EOperation this) : name.toFirstLower();

factoryMethodName(EClassifier this) :
	"create" + id();

id(EOperation this)         : eContainingClass.id() + "_" + methodName();
id(EStructuralFeature this) : eContainingClass.id() + "_" + propertyName();
id(EClassifier this) :        name.toFirstUpper();
id(Void this) : null;

metaVariable(EPackage this)           : name.toFirstUpper();
metaVariable(EClassifier this)        : ePackage.metaVariable() + "_" + id();
metaVariable(EStructuralFeature this) : eContainingClass.ePackage.metaVariable() + "_" + id();
metaVariable(EOperation this)         : eContainingClass.ePackage.metaVariable() + "_" + id();
metaVariable(Void this) : null;

private metaFlagsCommon(EStructuralFeature this) :
	(let attrs = { } :
		if changeable  then attrs.add("changeable")  ->
		if derived     then attrs.add("derived")     ->
		if many        then attrs.add("many")        ->
	attrs);

metaFlags(EStructuralFeature this) :
	metaFlagsCommon();
metaFlags(EReference this) :
	(let attrs = metaFlagsCommon() :
		if containment then attrs.add("containment") ->
		if container   then attrs.add("container")   ->
	attrs);

metaFlags(EClass this) :
	(let attrs = { } :
		if abstract    then attrs.add("abstract")    ->
		if interface   then attrs.add("interface")   ->
	attrs);

featureInfo(EStructuralFeature this) : name;
featureInfo(EReference this) :
	"Reference '" + name + "' [" + lowerBound + ".." + 
			(upperBound == -1 ? "*" : upperBound) + "]" +
	(let i = { } :
		if eOpposite != null then i.add("bidirectional") ->
		if containment then i.add("containment") ->
		if container   then i.add("container")   ->
		if derived     then i.add("derived")     ->
		if !changeable then i.add("read-only")   ->
		i.isEmpty ? "" : ": " + i.toString(", ")) + ".";
featureInfo(EAttribute this) :
	"Attribute '" + name + "'" +
	(let i = { } :
		if derived     then i.add("derived")     ->
		if !changeable then i.add("read-only")   ->
		i.isEmpty ? "" : ": " + i.toString(", ")) + ".";

mkExpand(String this) : "$(" + this + ")";

mkCall(String this) :             mkCall({ });
mkCall(String this, String arg) : mkCall({ arg });
mkCall(String this, List[String] args) : 
	"$(call " + { this, args }.flatten().toString(",") + ")";

mkNew(String this) :             mkNew({ });
mkNew(String this, String arg) : mkNew({ arg });
mkNew(String this, List[String] args) : 
	"$(new " + { this, args }.flatten().toString(",") + ")";

mkSuper(String name) : "$(super " + name + ")";
mkSuper(String name, String arguments) :
	"$(super " + name + ",\n\t\t" + arguments + ")";

mkMethod(String name) : "$(method " + name + ")";
mkMethod(String name, String body) :
	"$(method " + name + ",\n\t\t" + body + ")";

mkProperty(String name) : "$(property " + name + ")";

mkGetter(String name, String body) :      "$(getter "  + name + "," + body + ")";
mkSetter(String name, String body) :      "$(setter "  + name + "," + body + ")";
mkSetterPlus(String name, String body) :  "$(setter+ " + name + "," + body + ")";
mkSetterMinus(String name, String body) : "$(setter- " + name + "," + body + ")";

mkGetterWrap(String name, String body) :      mkGetter(name, "\n\t\t" + body);
mkSetterWrap(String name, String body) :      mkSetter(name, "\n\t\t" + body);
mkSetterPlusWrap(String name, String body) :  mkSetterPlus(name, "\n\t\t" + body);
mkSetterMinusWrap(String name, String body) : mkSetterMinus(name, "\n\t\t" + body);

mkField(String name) : "$(field " + name + ")";
mkField(String name, String initializer) :
	"$(field " + name + ",\n\t\t" + initializer + ")";

mkPropertyField(String name) : "$(property-field " + name + ")";
mkPropertyField(String name, String initializer) :
	"$(property-field " + name + ",\n\t\t" + initializer + ")";

mkInvoke(String this) :             mkInvoke({ });
mkInvoke(String this, String arg) : mkInvoke({ arg });
mkInvoke(String this, List[String] args) : 
	"$(invoke " + { this, args }.flatten().toString(",") + ")";

mkInvokeWrap(String this, String args) : this.mkInvoke("\n\t\t" + args);

mkGet(String this) : "$(get " + this + ")";
mkSet(String this, String value) : "$(set " + this + "," + value + ")";
mkSetWrap(String this, String value) : this.mkSet("\n\t\t" + value);

mkGetField(String this) : "$(get-field " + this + ")";
mkSetField(String this, String value) : "$(set-field " + this + "," + value + ")";
mkSetFieldWrap(String this, String value) : this.mkSetField("\n\t\t" + value);

ifIs(Object this, Object someObject) : ifIs(someObject != null);
ifIs(Object this, Boolean condition) : condition ? toString() : "";

isSubtypeOfNamed(EClass this) : eAllSuperTypes.exists(e|e.name == "ENamedObject");
isLinkableReference(EReference this) : eReferenceType.isSubtypeOfNamed() &&
	resolveProxies && !containment && !container;

subtypes(EClassifier this) :
	ePackage.eClassifiers.typeSelect(EClass)
		.select(c|c.eAllSuperTypes.contains(this));

isCrossReferenced(EClassifier this) :
	ePackage.eClassifiers.typeSelect(EClass).eReferences
		.exists(r | r.eReferenceType == this && !r.container && !r.containment);
