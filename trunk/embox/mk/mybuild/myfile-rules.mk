# Generated by GOLD Parser Builder using MyBuild program template.

# Rule productions for 'MyFile' grammar.

#
# As for symbols each rule can have a constructor that is used to produce an
# application-specific representation of the rule data.
# The signature of production function is the following:
#
# Params:
#  1..N: Each argument contains a value of the corresponding symbol
#        in the rule's RHS.
#  N+1:  Location vector with 'line:column' words each of which is a start of
#        the corresponding symbol.
#
# Return:
#   Converted value that is passed to a symbol handler corresponding to
#   the rule's LHS (if any has been defined).
#
# If production function is not defined then the rule is produced by
# concatenating the RHS through a space. To reuse this default value one can
# call 'gold_default_produce' function.
#

# Rule: <Model> ::= <Package> <Imports> <Entities>
# Args: 1..3 - Symbols; 3+1 - Location vector.
define $(gold_grammar)_produce-Model
	$(\h) Generated from $(gold_file). Do not edit!$(\n)$(\n)
	$(if $1,$1$(\n))
	$(if $2,$2$(\n))
	$(if $3,
		$(if $(findstring $$_APIS,$3),
			ifneq ($$(flavor $$_APIS),simple)$(\n)
			$$_APIS :=$$(value $$_APIS)$(\n)
			endif$(\n)
		)
		$(if $(findstring $$_MODS,$3),
			ifneq ($$(flavor $$_MODS),simple)$(\n)
			$$_MODS :=$$(value $$_MODS)$(\n)
			endif$(\n)
		)
		$(\n)$3$(\n)
	)
endef

# Rule: <Package> ::= package <QualifiedName>
# Args: 1..2 - Symbols; 2+1 - Location vector.
define $(gold_grammar)_produce-Package_package
	$$_PACKAGE := $2$(\n)
endef

# Rule: <Package> ::= 
# Args: 1..0 - Symbols; 0+1 - Location vector.
define $(gold_grammar)_produce-Package
	$(call gold_report_warning,
		Using default package
	)
endef

# Rule: <Import> ::= import <ImportFeature> <QualifiedNameWithWildcard>
# Args: 1..3 - Symbols; 3+1 - Location vector.
define $(gold_grammar)_produce-Import_import
	$(call gold_report_warning,
		Imports are not yet implemented!
	)
endef

# Rule: <Entities> ::= <Entity> <Entities>
# Args: 1..2 - Symbols; 2+1 - Location vector.
define $(gold_grammar)_produce-Entities
	$1$2
endef

# Rule: <Module> ::= <ModuleModifiers> module Identifier <SuperModule> '{' <ModuleAttributes> '}'
# Args: 1..7 - Symbols; 7+1 - Location vector.
define $(gold_grammar)_produce-Module_module_Identifier_LBrace_RBrace
	m := $3$(\n)
	$$_$(if $(filter abstract,$1),APIS,MODS) += $$m$(\n)
	$4
	$6$(\n)
endef

# Rule: <SuperModule> ::= extends <ModuleRef>
# Args: 1..2 - Symbols; 2+1 - Location vector.
define $(gold_grammar)_produce-SuperModule_extends
	$$_PROVIDES-$$m += $2$(\n)
endef

# Rule: <ModuleAttributes> ::= <ModuleAttribute> <ModuleAttributes>
# Args: 1..2 - Symbols; 2+1 - Location vector.
define $(gold_grammar)_produce-ModuleAttributes
	$1$2
endef

# Rule: <Depends> ::= depends <ModuleRefList>
# Args: 1..2 - Symbols; 2+1 - Location vector.
define $(gold_grammar)_produce-Depends_depends
	$$_DEPS-$$m += $2$(\n)
endef

# Rule: <Sources> ::= source <FilenameList>
# Args: 1..2 - Symbols; 2+1 - Location vector.
define $(gold_grammar)_produce-Sources_source
	$$_SRCS-$$m += $2$(\n)
endef

# Rule: <Objects> ::= object <FilenameList>
# Args: 1..2 - Symbols; 2+1 - Location vector.
define $(gold_grammar)_produce-Objects_object
	$(call gold_report_warning,
		Objects are not yet implemented!
	)
endef

# Rule: <Option> ::= option Identifier ':' <OptionTypeWithAssignment>
# Args: 1..4 - Symbols; 4+1 - Location vector.
define $(gold_grammar)_produce-Option_option_Identifier_Colon
	$(call gold_report_warning,
		Options are not yet implemented!
	)
endef

# Rule: <Flags> ::= make flags <StringList>
# Args: 1..3 - Symbols; 3+1 - Location vector.
define $(gold_grammar)_produce-Flags_make_flags
	$$_CFLAGS-$$m += $3$(\n)
endef

# Rule: <Rule> ::= make <Filename> <Prerequisites> <Recipes>
# Args: 1..4 - Symbols; 4+1 - Location vector.
define $(gold_grammar)_produce-Rule_make
	$(call gold_report_warning,
		Make rules are not yet implemented!
	)
endef

# Rule: <Filename> ::= StringLiteral
# Args: 1..1 - Symbols; 1+1 - Location vector.
define $(gold_grammar)_produce-Filename_StringLiteral
	$(or \
		$(singleword $1),
		$(call gold_report_warning,
			File name must be a single word
		)
	)
endef

# Rule: <InterfaceRefList> ::= <InterfaceRef> ',' <InterfaceRefList>
# Args: 1..3 - Symbols; 3+1 - Location vector.
define $(gold_grammar)_produce-InterfaceRefList_Comma
	$1 $3
endef

# Rule: <FeatureRefList> ::= <FeatureRef> ',' <FeatureRefList>
# Args: 1..3 - Symbols; 3+1 - Location vector.
define $(gold_grammar)_produce-FeatureRefList_Comma
	$1 $3
endef

# Rule: <ModuleRefList> ::= <ModuleRef> ',' <ModuleRefList>
# Args: 1..3 - Symbols; 3+1 - Location vector.
define $(gold_grammar)_produce-ModuleRefList_Comma
	$1 $3
endef

# Rule: <FilenameList> ::= <Filename> ',' <FilenameList>
# Args: 1..3 - Symbols; 3+1 - Location vector.
define $(gold_grammar)_produce-FilenameList_Comma
	$1 $3
endef

# Rule: <StringList> ::= StringLiteral ',' <StringList>
# Args: 1..3 - Symbols; 3+1 - Location vector.
define $(gold_grammar)_produce-StringList_StringLiteral_Comma
	$1 $3
endef

# Rule: <QualifiedName> ::= Identifier '.' <QualifiedName>
# Args: 1..3 - Symbols; 3+1 - Location vector.
define $(gold_grammar)_produce-QualifiedName_Identifier_Dot
	$1.$3
endef

# Rule: <QualifiedNameWithWildcard> ::= <QualifiedName> '.*'
# Args: 1..2 - Symbols; 2+1 - Location vector.
define $(gold_grammar)_produce-QualifiedNameWithWildcard_DotTimes
	$1.*
endef

