 --- tcl8.6.1/generic/tclIOCmd.c	2013-09-19 23:04:14.000000000 +0400
+++ tcl/generic/tclIOCmd.c	2014-02-28 12:25:09.222881148 +0400
@@ -862,7 +862,7 @@
  *
  *----------------------------------------------------------------------
  */
-
+#if 0
 	/* ARGSUSED */
 int
 Tcl_ExecObjCmd(
@@ -1012,6 +1012,61 @@
 
     return result;
 }
+#else
+
+int
+Tcl_ExecObjCmd(
+    ClientData dummy,		/* Not used. */
+    Tcl_Interp *interp,		/* Current interpreter. */
+    int objc,			/* Number of arguments. */
+    Tcl_Obj *const objv[])	/* Argument objects. */
+{
+	int res;
+	const struct cmd *embox_cmd;
+	const char *string;
+    const char **argv;		/* An array for the string arguments. Stored
+				 * on the _Tcl_ stack. */
+    int argc, i, skip = 1;
+
+    for (skip = 1; skip < objc; skip++) {
+    	string = TclGetString(objv[skip]);
+    	if (isalpha(string[0])) {
+    		break;
+    	}
+    }
+
+    argc = objc - skip;
+    argv = TclStackAlloc(interp, (unsigned)(argc + 1) * sizeof(char *));
+
+    /*
+     * Copy the string conversions of each (post option) object into the
+     * argument vector.
+     */
+
+    for (i = 0; i < argc; i++) {
+    	argv[i] = TclGetString(objv[i + skip]);
+    }
+    argv[argc] = NULL;
+
+    embox_cmd = cmd_lookup(argv[0]);
+
+    if (!embox_cmd) {
+    	res = TCL_ERROR;
+    	fprintf(stderr, "%s: No such command\n", argv[0]);
+    	goto out;
+    }
+
+    res = cmd_exec(embox_cmd, argc, argv);
+
+out:
+    /*
+     * Free the argv array.
+     */
+
+    TclStackFree(interp, (void *) argv);
+	return (res == 0 ? TCL_OK : TCL_ERROR);
+}
+#endif
 
 /*
  *---------------------------------------------------------------------------

  
 diff -ur tcl8.6.1/library/init.tcl tcl/library/init.tcl 
--- tcl8.6.1/library/init.tcl	2013-09-19 23:04:15.000000000 +0400
+++ tcl/library/init.tcl	2014-02-28 03:06:19.608569753 +0400
@@ -708,32 +708,10 @@
 }
 
 } else {
-# Unix version.
+# Embox version.
 #
 proc auto_execok name {
-    global auto_execs env
-
-    if {[info exists auto_execs($name)]} {
-	return $auto_execs($name)
-    }
-    set auto_execs($name) ""
-    if {[llength [file split $name]] != 1} {
-	if {[file executable $name] && ![file isdirectory $name]} {
-	    set auto_execs($name) [list $name]
-	}
-	return $auto_execs($name)
-    }
-    foreach dir [split $env(PATH) :] {
-	if {$dir eq ""} {
-	    set dir .
-	}
-	set file [file join $dir $name]
-	if {[file executable $file] && ![file isdirectory $file]} {
-	    set auto_execs($name) [list $file]
-	    return $auto_execs($name)
-	}
-    }
-    return ""
+    return $name
 }
 
 }
