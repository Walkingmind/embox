/**
 * @file
 *
 * @date 17.12.10
 * @author Nikolay Korotky
 */

#include <asm/multiboot.h>

#define EXCEPTION(n, name)       \
	.globl name             ;\
name:                           ;\
	cli                     ;\
	pushl	$(0)		;\
	pushl	$(n)		;\
	jmp	excep_stub

#define IRQ_ENTRY(n)      \
	.globl irq##n    ;\
irq##n:                  ;\
	cli              ;\
	jmp irq##n ;
	#if 0
	pushl   $(0)     ;\
	pushl   $(32 + n);\
	jmp     irq_stub
#endif
EXCEPTION(0x00, t_excep0)    /* Divide By Zero Exception */
EXCEPTION(0x01, t_excep1)    /* Debug Exception */
EXCEPTION(0x02, t_excep2)    /* Non Maskable Interrupt Exception */
EXCEPTION(0x03, t_excep3)    /* Breakpoint Exception */
EXCEPTION(0x04, t_excep4)    /* Into Detected Overflow Exception */
EXCEPTION(0x05, t_excep5)    /* Out of Bounds Exception */
EXCEPTION(0x06, t_excep6)    /* Invalid Opcode Exception */
EXCEPTION(0x07, t_excep7)    /* No Coprocessor Exception */
EXCEPTION(0x08, t_excep8)    /* Double Fault Exception */
EXCEPTION(0x09, t_excep9)    /* Coprocessor Segment Overrun Exception */
EXCEPTION(0x0a, t_excep10)   /* Bad TSS Exception */
EXCEPTION(0x0b, t_excep11)   /* Segment Not Present Exception */
EXCEPTION(0x0c, t_excep12)   /* Stack Fault Exception */
EXCEPTION(0x0d, t_excep13)   /* General Protection Fault Exception */
EXCEPTION(0x0e, t_excep14)   /* Page Fault Exception */
EXCEPTION(0x0f, t_excep15)   /* Unknown Interrupt Exception */
EXCEPTION(0x10, t_excep16)   /* Coprocessor Fault Exception */
EXCEPTION(0x11, t_excep17)   /* Alignment Check Exception */
EXCEPTION(0x12, t_excep18)   /* Machine Check Exception */
EXCEPTION(0x13, t_excep19)   /* Reserved Exception */
EXCEPTION(0x14, t_excep20)   /* Reserved Exception */
EXCEPTION(0x15, t_excep21)   /* Reserved Exception */
EXCEPTION(0x16, t_excep22)   /* Reserved Exception */
EXCEPTION(0x17, t_excep23)   /* Reserved Exception */
EXCEPTION(0x18, t_excep24)   /* Reserved Exception */
EXCEPTION(0x19, t_excep25)   /* Reserved Exception */
EXCEPTION(0x1a, t_excep26)   /* Reserved Exception */
EXCEPTION(0x1b, t_excep27)   /* Reserved Exception */
EXCEPTION(0x1c, t_excep28)   /* Reserved Exception */
EXCEPTION(0x1d, t_excep29)   /* Reserved Exception */
EXCEPTION(0x1e, t_excep30)   /* Reserved Exception */
EXCEPTION(0x1f, t_excep31)   /* Reserved Exception */

IRQ_ENTRY(0) /* system timer (cannot be changed) */
IRQ_ENTRY(1) /* keyboard controller (cannot be changed) */
IRQ_ENTRY(2) /* cascaded signals from IRQs 8â€“15 */
IRQ_ENTRY(3) /* serial port controller for COM2(shared with COM4, if present) */
IRQ_ENTRY(4) /* serial port controller for COM1(shared with COM3, if present) */
IRQ_ENTRY(5) /* LPT port 2  or  sound card */
IRQ_ENTRY(6) /* floppy disk controller */
IRQ_ENTRY(7) /* LPT port 1 or sound card(8-bit Sound Blaster and compatibles) */

IRQ_ENTRY(8)  /* real-time clock */
IRQ_ENTRY(9)  /* open interrupt/available or SCSI host adapter */
IRQ_ENTRY(10) /* open interrupt / available  or  SCSI  or  NIC */
IRQ_ENTRY(11) /* open interrupt / available  or  SCSI  or  NIC */
IRQ_ENTRY(12) /* mouse on PS/2 connector */
IRQ_ENTRY(13) /* math co-processor/integrated FPU/inter-processor interrupt(use depends on OS) */
IRQ_ENTRY(14) /* primary ATA channel */
IRQ_ENTRY(15) /* secondary ATA channel */

excep_stub:
	pusha
	pushl	%ds
	pushl	%es
	pushl	%fs
	pushl	%gs
	movl	%ss, %eax
	movl	%eax, %ds
	movl	%eax, %es
	movl	%esp, %eax

	call    EXT_C(exception_handler)
	
	pop     %gs
	pop     %fs
	pop     %es
	pop     %ds
	popa
	add     $8, %esp
	iret

irq_stub:
	pusha
	pushl   %ds
	pushl   %es
	pushl   %fs
	pushl   %gs
	movl    %ss, %eax
	movl    %eax, %ds
	movl    %eax, %es
	movl    %esp, %eax	

	call    EXT_C(irq_handler)
	
	pop     %gs
	pop     %fs
	pop     %es
	pop     %ds
	popa
	add     $8, %esp
	iret

    #if 1
	.globl idt_ptr
idt_ptr:
	.word   _idt_end - _idt - 1
	.long   _idt
#endif

	.align 0x1000
#if 1
    .global _idt
_idt:
	.fill   256, 8, 0
_idt_end:
#endif

#if 0
	.globl gdt_ptr, _gdt
gdt_ptr:
	.word   _gdt_end - _gdt - 1
	.long   _gdt
_gdt:
	.fill   8, 8, 0
_gdt_end:
#endif

	.global gdt_flush
gdt_flush:
	movl 4(%esp), %eax
	lgdt (%eax)

	movw $0x10, %ax
	movw %ax, %ds
	movw %ax, %es
	movw %ax, %fs
	movw %ax, %gs
	movw %ax, %ss
	ljmp  $(0x8),$flush
flush:
	ret
