/**
 * @file
 * @brief EMBOX dependency injection framework.
 *
 * @date 22.02.2010
 * @author Eldar Abusalimov
 */

#ifndef EMBOX_MOD_H_
#define EMBOX_MOD_H_

#include <stddef.h>

#if !defined(__FRAMEWORK__) && !defined(__EMBUILD_DEPSINJECT__)
# ifndef __EMBUILD_MOD__
#  error "Do not include without __EMBUILD_MOD__ defined (e.g. from lib code)!"
# endif /* __EMBUILD_MOD__ */
#endif /* __EMBUILD_DEPSINJECT__ */

#define __STRINGIFY(str) #str

/* Linker sections stuff. */

/**
 * All mod-related sections are linked using something like
 * @code *(SORT(.mod*.rodata)) @endcode . @c SORT guarantees that the wildcard
 * is expanded in the lexicographical order, @c order argument is used to
 * control the placement of sections within a single mod. We use this facility
 * to create null-terminated arrays of module dependencies initialized
 * (populated) in multiple compilation units.
 */
#define __MOD_SECTION(_mod, section, order, tag) \
	".mod"__STRINGIFY(__##section##__$$##_mod##$$__##order##_##tag)".rodata"

#define __MOD_SECTION_HEAD(_mod, section) __MOD_SECTION(_mod, section, 0,head)
#define __MOD_SECTION_BODY(_mod, section) __MOD_SECTION(_mod, section, 1,body)
#define __MOD_SECTION_TAIL(_mod, section) __MOD_SECTION(_mod, section, 9,tail)

/* Internal variable names. */

#define __MOD(_mod)              __mod__$$##_mod
#define __MOD_DATA_REF(_mod)     __mod_data_ref__##_mod
#define __MOD_OPS_REF(_mod)      __mod_ops_ref__##_mod
#define __MOD_NAME(_mod)         __mod_name__##_mod
#define __MOD_PRIVATE(_mod)      __mod_private__$$##_mod
#define __MOD_PACKAGE(_package)  __mod_package__$$##_package
#define __MOD_ARRAY(_mod, array) __mod_##array##__$$##_mod
#define __MOD_ARRAY_ENTRY(_mod, array, entry) \
	__mod_##array##__$$##_mod##$$__$$##entry

/* Internal declarations and definitions. */

#define __MOD_DECL(_mod) \
	extern const struct mod __MOD(_mod)

#define __MOD_PACKAGE_DECL(_mod_package) \
	extern const struct mod_package __MOD_PACKAGE(_mod_package)

#define __MOD_DATA_REF_DECL(_mod) \
	extern const struct mod_data_ref __MOD_DATA_REF(_mod) __attribute__ ((weak))
#define __MOD_OPS_REF_DECL(_mod) \
	extern const struct mod_ops_ref __MOD_OPS_REF(_mod) __attribute__ ((weak))

#define __MOD_NAME_DEF(_mod, _mod_name) \
	const char __MOD_NAME(_mod)[] = _mod_name
#define __MOD_PRIVATE_DEF(_mod) \
	static struct mod_private __MOD_PRIVATE(_mod)

#define __MOD_ARRAY_DEF(_mod, array) \
	static const struct mod *__MOD_ARRAY(_mod, array)[1] \
		__attribute__ ((section(__MOD_SECTION_HEAD(_mod, array)))); \
	static const struct mod *__MOD_ARRAY_ENTRY(_mod, array, __null$$) \
		__attribute__ ((used, section(__MOD_SECTION_TAIL(_mod, array)))) = NULL

#define __MOD_ARRAY_ADD(_mod, array, entry) \
	static const struct mod *__MOD_ARRAY_ENTRY(_mod, array, entry) \
		__attribute__ ((used, section(__MOD_SECTION_BODY(_mod, array)))) \
		= MOD_PTR(entry) \

/**
 * Used to access the self module (referenced by __EMBUILD_MOD__), e.g. to bind
 * something like #mod_data.
 */
#define __MOD_SELF(macro) \
		__MOD_SELF_EXPAND(macro, __EMBUILD_MOD__)
#define __MOD_SELF_EXPAND(macro, mod) \
		__MOD_SELF_INVOKE(macro, mod)
#define __MOD_SELF_INVOKE(macro, mod) \
		macro(mod)

/* Here goes public macros API. */

/**
 * Pointer to the #mod structure defined with #MOD_DEF() macro.
 *
 * @param _mod the mod variable name used at definition time.
 */
#define MOD_PTR(_mod) (&__MOD(_mod))

/**
 * Defines a new mod. For the new mod the @link #mod corresponding @endlink
 * structure is allocated. Also two section-driven arrays are defined for the
 * mod#provides and mod#requires lists.
 *
 * @param _mod the variable name used later to access the mod structure using
 *        #MOD_PTR(), to define dependencies with #MOD_DEP_DEF(), or to bind
 *        mod-specific @link #mod_ops operations @endlink and data using
 *        #MOD_OPS_DEF() and #MOD_DATA_DEF() macros. For the code generated by
 *        EMBuild this argument must be the same as provided by the
 *        __EMBUILD_MOD__ macro for each mod at compilation time
 * @param _mod_package the package variable name used in #MOD_PACKAGE_DEF()
 * @param mod_name a string containing the mod name. The name of the current
 *        mod (referenced by __EMBUILD_MOD__) can accessed at compilation time
 *        using #MOD_SELF_NAME macro
 */
#define MOD_DEF(_mod, _mod_package, mod_name) \
	__MOD_DATA_REF_DECL(_mod); \
	__MOD_OPS_REF_DECL(_mod); \
	__MOD_PACKAGE_DECL(_mod_package); \
	__MOD_ARRAY_DEF(_mod, requires); \
	__MOD_ARRAY_DEF(_mod, provides); \
	__MOD_NAME_DEF(_mod, mod_name); \
	__MOD_PRIVATE_DEF(_mod); \
	const struct mod __MOD(_mod) = { \
			.private  = &__MOD_PRIVATE(_mod), \
			.data_ref = (struct mod_data_ref *) &__MOD_DATA_REF(_mod), \
			.ops_ref  = (struct mod_ops_ref *) &__MOD_OPS_REF(_mod), \
			.package  = (struct mod_package *) &__MOD_PACKAGE(_mod_package), \
			.name     = __MOD_NAME(_mod), \
			.requires = (struct mod **) &__MOD_ARRAY(_mod, requires)[1], \
			.provides = (struct mod **) &__MOD_ARRAY(_mod, provides)[1], \
		}

#define MOD_DEP_DEF(_mod, _dep) \
	__MOD_DECL(_mod); \
	__MOD_DECL(_dep); \
	__MOD_ARRAY_ADD(_mod, requires, _dep); \
	__MOD_ARRAY_ADD(_dep, provides, _mod)

#define MOD_PACKAGE_DEF(_mod_package, package_name) \
	const struct mod_package __MOD_PACKAGE(_mod_package) = { \
			.name = package_name, \
		}

#define MOD_ROOT_DEF(_mod) \
	static const struct mod *__mod_root__##_mod \
		__attribute__ ((used, section(".mod.rodata"))) = MOD_PTR(_mod)

#define MOD_DATA_DEF(_mod, _mod_data) \
	const struct mod_data_ref __MOD_DATA_REF(_mod) = \
		{ .data = (void *) _mod_data }
#define MOD_OPS_DEF(_mod, _mod_ops) \
	const struct mod_ops_ref __MOD_OPS_REF(_mod) = \
		{ .ops = (struct mod_ops *) _mod_ops }

#define MOD_SELF                     __MOD_SELF(__MOD)
#define MOD_SELF_NAME                __MOD_SELF(__MOD_NAME)
#define MOD_SELF_DATA_DEF(_mod_data) MOD_DATA_DEF(__EMBUILD_MOD__, _mod_data)
#define MOD_SELF_OPS_DEF(_mod_ops)   MOD_OPS_DEF(__EMBUILD_MOD__, _mod_ops)
#define MOD_SELF_DEP_DEF(_dep)       MOD_DEP_DEF(__EMBUILD_MOD__, _dep)

#define MOD_FLAG_ENABLED       (1 << 3)
#define MOD_FLAG_OPFAILED      (1 << 1)
#define MOD_FLAG_OPINPROGRESS  (1 << 2)

struct mod;
struct mod_package;
struct mod_ops;
struct mod_private;

struct mod_ops_ref;
struct mod_data_ref;

/**
 * Performs an operation with the module. The semantics of the operation is
 * module-specific. If the module has no operation assigned (#mod_ops structure
 * contains @c NULL pointer fields), the meaning is that module operation
 * always succeeds (as if the corresponding function returns 0).
 *
 * @param self pointer to the #mod struct.
 * @return error code
 * @retval 0 if operation succeeds
 * @retval nonzero on error
 */
typedef int (*mod_op_t)(struct mod *self);

/**
 * The main mod operation. The semantics of the operation is module-specific.
 * Mods framework does not use this method nor its return value. Please note
 * that framework also does not track the current state of the mod or its
 * dependencies, so the mod should check its state by itself.
 *
 * The caller should use #mod_invoke() function instead of directly accessing
 * the corresponding field of the #mod_ops structure.
 *
 * @param self pointer to the #mod struct.
 * @param data optional argument
 * @return operation result
 */
typedef int (*mod_invoke_t)(struct mod *self, void *data);

/**
 * TODO Module info emitted by EMBuild dependency injection model generator.
 */
struct mod {
	/** Internal data needed by dependency resolver. */
	struct mod_private *private;
	/** (optional) Module specific data. */
	struct mod_data_ref *data_ref;
	/** (optional) Available operations. */
	struct mod_ops_ref *ops_ref;
	/** Module package assigned by EMBuild. */
	struct mod_package *package;
	/** Module name assigned by EMBuild. */
	const char *name;
	/** Dependency info. */
	struct mod **requires, **provides;
};

struct mod_package {
	const char *name;
};

/**
 * Module operations.
 * @note Do not call these functions directly!
 */
struct mod_ops {
	/** (optional) Module state change operation. */
	mod_op_t enable, disable;
	/** (optional) Module main method. */
	mod_invoke_t invoke;
};

struct mod_ops_ref {
	struct mod_ops *ops;
};

struct mod_data_ref {
	void *data;
};

struct mod_private {
	unsigned int flags;
};
/**
 * The special package which may be used for pseudo-mods defined by other
 * frameworks (e.g. tag mods and so on).
 */
__MOD_PACKAGE_DECL(generic);

/**
 * Enables the specified mod resolving its dependencies. This implies that all
 * the mods on which the given one depends will also be enabled.
 * If the mod has already been enabled then nothing special is done and this
 * function returns zero.
 *
 * @param mod the mod to enable
 * @return operation result
 * @retval 0 if the mod has been successfully enabled
 * @retval -EINVAL if the argument is @c NULL
 * @retval -EINTR if an error has occurred while enabling the mod or one of
 *         its dependencies
 */
extern int mod_enable(const struct mod *mod);

/**
 * Disables the specified mod resolving its dependencies. This implies that all
 * the mods which depend on the given one will also be disabled.
 * If the mod has not been enabled yet then nothing special is done and this
 * function returns zero.
 *
 * @param mod the mod to disable
 * @return operation result
 * @retval 0 if the mod has been successfully disabled
 * @retval -EINVAL if the argument is @c NULL
 * @retval -EINTR if an error has occurred while disabling the mod or one of
 *         its dependencies
 */
extern int mod_disable(const struct mod *mod);

/**
 * The weak version of #mod_enable().
 * Enables the specified mod if and only if all the mods on which the given one
 * depends are also enabled. If the mod has already been enabled then nothing
 * special is done and the function returns zero.
 *
 * @param mod the mod to enable
 * @return operation result
 * @retval 0 if the mod has been successfully enabled
 * @retval -EINVAL if the argument is @c NULL
 * @retval -EBUSY if the mod cannot be enabled at the moment because of
 *         unsatisfied dependencies
 * @retval -EINTR if an error has occurred while enabling the mod
 */
extern int mod_enable_nodep(const struct mod *mod);

/**
 * The weak version of #mod_disable().
 * Disables the specified mod if and only if all the mods which depend on the
 * given one are also disabled. If the mod has not been enabled yet then
 * nothing special is done and the function returns zero.
 *
 * @param mod the mod to disable
 * @return operation result
 * @retval 0 if the mod has been successfully disabled
 * @retval -EINVAL if the argument is @c NULL
 * @retval -EBUSY if the mod cannot be disabled at the moment because of
 *         unsatisfied dependencies
 * @retval -EINTR if an error has occurred while disabling the mod
 */
extern int mod_disable_nodep(const struct mod *mod);

/**
 * Invokes the module if it has provided the corresponding operation.
 * Please note that framework does not track the current state of the mod or
 * its dependencies, this means that the mod will be invoked even if it is not
 * enabled now.
 *
 * @param mod the mod on which to call @link mod_ops#invoke @endlink method
 * @param data optional argument to pass to the @c invoke method
 * @return invocation result
 * @retval -EINVAL if the @c mod argument is @c NULL
 * @retval -ENOTSUP if the mod does not support invoke method
 */
extern int mod_invoke(const struct mod *mod, void *data);

/**
 * Gets the data associated with the specified mod (if any).
 *
 * @param mod the mod which's data to get
 * @return the mod data
 */
extern void *mod_data(const struct mod *mod);

#if 0
/* TODO there is no way to implement these functions at now. -- Eldar */

/**
 * Sets the mod-specific data.
 *
 * @param mod the mod which's data to get
 * @param data the data to associate with the mod
 */
extern void mod_data_set(const struct mod *mod, void *data);

/**
 * Gets the #mod_ops of the specified mod.
 *
 * @param mod the mod which's ops to get
 * @return the mod operations structure
 */
extern struct mod_ops *mod_ops_get(const struct mod *mod);

/**
 * Sets the mod-specific data.
 *
 * @param mod the mod which's data to get
 * @param ops the data to associate with the mod
 */
extern void mod_ops_set(const struct mod *mod, struct mod_ops *ops);
#endif

#endif /* EMBOX_MOD_H_ */
