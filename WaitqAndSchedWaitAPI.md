# Интерфейсы ожидания событий #

Иногда потокам временно нужно прервать свою работу, например для синхронизации. В таком случае поток засыпает и ждет до тех пор, пока снова не сможет продолжить работу. За реализацию этих возможностей отвечают интерфейсы waitq и sched\_wait. Интерфейс sched\_wait является частью API планировщика, так как непосредственно влияет на состояния потоков. Интерфейс waitq использует sched\_wait, и в целом они похожи, поэтому следует их рассмотреть сразу вместе.

waitq отличается от sched\_wait главным образом тем, что он работает с очередью потоков. Это удобно, например, при использовании мьютексов. Мьютекс хранит в себе  очередь спящих потоков waitq, и когда какой-то поток освобождает мьютекс, просыпается один из потоков, ожидающий мьютекса.

## Подготовка к ожиданию и его прекращение ##

При работе с waitq нам, во-первых, нужно инициализировать саму очередь с помощью функции waitq\_init(). Во-вторых, в очереди хранятся не сами потоки, а wait\_link, которые тоже нужно создать. Делается это в функии waitq\_link\_init(), которая создает wait\_link для текущего потока.
В обоих интерфейсах есть функции prepare() и cleanup(). Их использование необходимо для корректной работы ожидания.

Функция prepare() должна использоваться перед засыпанием. Она подготавливает состояние потока, а в случае с waitq еще и добавляет поток в очередь.

Функция cleanup() завершающая в процессе ожидания, она должна вызваться потоком после того, как он дождался нужного события. Она возвращает потоку нормальное состояние, ну а в случае с waitq удаляет поток из очереди.

## Функции ожидания ##

Эти две функции используются для того, чтобы начать ожидание. Если поток для ожидания использует sched\_wait(), то проснется он только тогда, когда его разбудят, тогда как при использовании sched\_wait\_timout() управление потоку вернется по истечению указанного времени. Во второй функции заводится таймер, если таймаут конечный, по истечению которого просыпается уснувший поток. Если таймаут бесконечный, то таймер не заводится. После этого вызывается перепланирование. Когда поток разбудят, функция продолжится исполнятся. Она закроет таймер и вернет то время, которое осталось до истечения таймаута. Если таймаут истек, то функция возвращает соответствующую ошибку, иначе 0.

## Функции пробуждения ##

В описании интерфейса работы с планировщик уже говорилось о функции sched\_wakeup(). Ее мы используем, чтобы разбудить спящий поток. Когда бы работаем с очередью waitq, нам, как правило, нужно разбудить те потоки из очереди, приоритет которых наивысший. Для этого используется функция waitq\_wakeup(), один из аргументов которых - сколько потоков в очереди нужно разбудить. Если нужно разбудить все потоки в очереди, мы используем функцию waitq\_wakeup\_all().

## Макросы ##
Для многих прикладных задач удобно пользоваться макросами SCHED\_WAIT\_TIMEOUT и WAITQ\_WAIT\_TIMEOUT, а не напрямую использовать интерфейс. Оба потока реализуют ожидание истинности аргумента cond\_expr с одной лишь разницей, что в первом макросе поток ждет самостоятельно, а во втором - в очереди. Аргумент timeout означает то, сколько мы готовы ждать истинности условного выражения.